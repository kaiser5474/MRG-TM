<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />



<style type="text/css">
html { -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-select: none; -ms-touch-action: none;}
iframe {-webkit-user-select: text;}
.A5container {float:left;padding:0px;}
.A5CWLayout {padding: 4px; float: left; box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box;}
.A5GridHideErrorCol .A5GridErrorCol {display:none; }
.A5GridRowErrorIcon {display:none;}
.A5GridHasRowError .A5GridRowErrorIcon {display:inline-block;}
.A5GridRowViewMode {display:block;}
.A5GridRowEditMode {display:none;}
.A5GridRowInEditMode .A5GridRowViewMode {display:none;}
.A5GridRowInEditMode .A5GridRowEditMode {display:block;}
.A5GridRowDirty {display:none;}
.A5GridRowClean {display:inline;}
.A5GridRowIsDirty .A5GridRowDirty {display:inline;}
.A5GridRowIsDirty .A5GridRowClean {display:none;}
.errorText {color:red;font-size:8pt;}
.errorTextHighlight {font-weight:bold;font-size:8pt;}
.errorTip {color:red;background:#fffafa url('a5images/boxsize8x8fillUp5FDiagonalWhite3A232552C2392C239.png');border:1px solid #f88;margin-top:2px;padding:2px;font-size:8pt;}
.errorInput {color:red;border:1px solid red;margin:1px;}
.errorInputHighlight {color:red;border:2px solid red;margin:0px;}
.A5SelectedButton {opacity:.5;filter:alpha(opacity=50);}
.A5InvisibleLock {background: rgba(0,0,0,0); }
.A5floatClear { clear: both; font-size: 0px; width: 0px; height: 0px; overflow: hidden; padding: 0px; margin: 0px; border:none; visibility:hidden; }
.A5ListGroupHeaders {z-index:5;	position:relative;}



.A5ContainerAlignCenter {padding: 4px; margin-left:auto;margin-right:auto;text-align: center; box-sizing: border-box;}
.A5ContainerAlignLeft {padding: 4px; margin-right:auto;text-align: left; box-sizing: border-box;} 
.A5ContainerAlignRight {padding: 4px; margin-left:auto;text-align: right; box-sizing: border-box;}

.A5ContainerAlignCenter > .A5CWLayout, .A5ContainerAlignLeft > .A5CWLayout, .A5ContainerAlignRight > .A5CWLayout, .A5ContainerAlignCenter > .A5container, .A5ContainerAlignLeft > .A5container, .A5ContainerAlignRight > .A5container  {display: inline-block; float: none;}



.A5FloatingLabelCont {	position: relative;	margin-top: 20px;}
.A5FloatingLabelInsideCont {	position: relative;	}
.A5FloatingLabelInsideCont input, .A5FloatingLabelInsideCont select, .A5FloatingLabelInsideCont textarea {	padding-top: 20px !important;}

.A5FloatingLabel, .A5FloatingLabelInside {pointer-events:none;	position: absolute;	opacity: .5;	top: 50%;	left: 10px;;	right: 10px;; transform: translate(0px,-51%);	transition: transform 300ms, top 300ms, font-size 300ms;}
.A5FloatingLabelFloat .A5FloatingLabel {	font-size: 10px;	top: 0px;	opacity: 1;	transform: translate(0px,-100%);}
.A5FloatingLabelFloat .A5FloatingLabelInside {	font-size: 10px;	top: 0px;	opacity: 1;	transform: translate(0px,6px);}





.A5AccordionTitleOn, .A5AccordionTitleOff, .A5AccordionTitleDisabled {display: block;border: 1px solid #999;padding: 2px;text-decoration: none;cursor: pointer;margin-bottom: 2px; padding: 2px}
.A5AccordionPane {border: 1px solid #999;border-top: none;margin-bottom: 2px;margin-top: -2px;}
.A5TabTopOn, .A5TabTopOff, .A5TabTopDisabled {display: block;float: left;border: 1px solid #999;border-bottom: none;margin-right: 2px;padding: 2px;text-decoration: none;cursor: pointer;}
.A5TabTopOn {margin-bottom: -1px;padding-bottom: 3px;}
.A5TabBottomOn, .A5TabBottomOff, .A5TabBottomDisabled {display: block;float: left;border: 1px solid #999;margin-right: 2px;padding: 2px;text-decoration: none;cursor: pointer;}
.A5TabBottomOn {border-top: none;padding-top: 3px;}
.A5TabLeftOn, .A5TabLeftOff, .A5TabLeftDisabled {display: block;border: 1px solid #999;margin-bottom: 2px;padding: 2px;text-decoration: none;cursor: pointer;}
.A5TabLeftOn {margin-right: -1px;padding-right: 3px;border-right: none;}
.A5TabRightOn, .A5TabRightOff, .A5TabRightDisabled {display: block;border: 1px solid #999;border-left: none;margin-bottom: 2px;padding: 2px;text-decoration: none;cursor: pointer;}
.A5TabRightOn {margin-left: -1px;padding-left: 3px;}
.A5TabTopPane, .A5TabBottomPane, .A5TabLeftPane, .A5TabRightPane {border: 1px solid #999; padding: 2px;}


.A5TabBand {border: 1px solid #999; padding: 0px;}
.A5TabBandTabOn, .A5TabBandTabOff, .A5TabBandTabDisabled {position: relative;display: block;border: 1px solid #999;border-bottom: none;margin-right: 2px;margin-top: 2px;padding: 2px;text-decoration: none;cursor: pointer;white-space: nowrap;}
.A5TabBandTabOn {margin-bottom: -1px;padding-bottom: 3px;}
.A5TabBandSeparator {border: none;border-top: 1px solid #999;height: 3px;padding: 0px;font: 0pt arial;}
.A5TabBandLeftScroll {position: relative;display: block;padding: 2px;margin-bottom: -1px;padding-bottom: 3px;text-decoration: none;border: 1px solid #999;border-left: none;border-bottom: none;}
.A5TabBandRightScroll {position: relative;display: block;padding: 2px;margin-bottom: -1px;padding-bottom: 3px;text-decoration: none;border: 1px solid #999;border-right: none;border-bottom: none;}
.A5TabBandTabDisabled, .A5TabTopDisabled, .A5TabLeftDisabled, .A5TabRightDisabled, .A5TabBottomDisabled, .A5AccordionTitleDisabled {opacity: .5; filter: alpha(opacity: 50)}
.A5Window {-moz-border-radius: 3px; -webkit-border-radius: 3px;}
.A5WindowLock{border: 1px solid #000;background: #222;opacity: .25;filter: alpha(opacity: 25);}

.A5AccordionTitleOn:hover, .A5AccordionTitleOff:hover, .A5TabBandTabOff:hover, .A5TabTopOff:hover, .A5TabLeftOff:hover, .A5TabRightOff:hover, .A5TabBottomOff:hover{text-decoration: underline;}

.A5MenuItem {text-decoration:none;}
.A5DialogRSSeparator {border-top: 1px dotted #ccc; line-height:5px; margin-top: 5px;}
.A5DialogRSFooter {margin-top: 10px;}

.A5AnimRotate90, .A5AnimRotate90CCW, .A5AnimRotate180, .A5AnimRotate180CCW {display: inline-block;transition: transform 300ms;}
.A5AnimRotate90[a5-checked=on] {transform: rotate(90deg);}
.A5AnimRotate90CCW[a5-checked=on] {transform: rotate(-90deg);}
.A5AnimRotate180[a5-checked=on] {transform: rotate(180deg);}
.A5AnimRotate180CCW[a5-checked=on] {transform: rotate(-180deg);}
.A5AnimSwap.A5AnimRotate90 > *:last-child {transform: rotate(-90deg);}
.A5AnimSwap.A5AnimRotate90CCW > *:last-child {transform: rotate(90deg);}
.A5AnimSwap.A5AnimRotate180 > *:last-child {transform: rotate(-180deg);}
.A5AnimSwap.A5AnimRotate180CCW > *:last-child {transform: rotate(180deg);}
.A5AnimSwap {position: relative;display: inline-block;transition: transform 300ms;}
.A5AnimSwap > * {transition: opacity 300ms;}
.A5AnimSwap > *:last-child {position: absolute;top: 0px;left: 0px;opacity: 0;}
.A5AnimSwap[a5-checked=on] > *:first-child {opacity: 0;}
.A5AnimSwap[a5-checked=on] > *:last-child {opacity: 1;}




</style>

<link palette="" rel="stylesheet" type="text/css" href="css/Alpha-Aqua/style.css ">
<link rel="stylesheet" type="text/css" href="css/_sharedStyles/style.css">

<style type="text/css">
.iconSizeable {
  vertical-align: middle;
  height: auto;
  width: auto; }
.iconDisabled {
  opacity: .75; }
</style>
<style>
</style>

<script src="cordova.js"></script>

<script type="text/javascript" src="javascript/a5.js"></script>
<script type="text/javascript" src="javascript/a5_url.js"></script>
<script type="text/javascript" src="css/Alpha-Aqua/style.js"></script>
<script type="text/javascript" src="javascript/A5jQueryWithUI.js"></script>
<script>
	if(typeof jQuery != 'undefined') jQuery.noConflict();
</script>
<script type="text/javascript" src="_phoneGapSettings.js"></script>

<title></title></head>
<body class="page  pulse">
<iframe style="display:none;" id="DLG1.__IFRAME1"></iframe>
<input type="hidden" value="" id="DLG1.PARAMETERBUCKET"/>
<input type="file" style="position:absolute; top:-1000px;visibility:hidden;" accept="image/*" id="DLG1._GETPHOTO"/><input type="file" style="position:absolute; top:-1000px;visibility:hidden;" name="files[]" multiple = "" id="DLG1._GETFILEMULTI"/><input type="file" style="position:absolute; top:-1000px;visibility:hidden;" name="files[]" id="DLG1._GETFILE"/>

<div class="errorTip" style="margin-bottom: 2px; display: none; width: 8in; " id="DLG1.GLOBALERRORS"></div>


<div id="DLG1.R1">
<div class="A5CWLayout" style="width: " >
	<button type="button" id="DLG1.V.R1.BUTTON_2"    ></button>
</div><br  style="clear:both; " />


</div>

<div class="" style="display: none; " id="DLG1.DEBUGUPDATECOMMANDS"></div>


<script type="text/javascript" language="javascript">

//mark 2

if(!A5.controlBar) { 	
/*
Copyright (c) 2001, 2021 Alpha Software Corporation
All Rights Reserved.
This JavaScript library is licensed exclusively for use with Alpha Anywhere, Alpha Five,
Alpha Five Application Server, Alpha Anywhere Application Server,
Alpha Five Run Engine, and Alpha Anywhere Run Engine. It is specifically
not licensed for use on a server that does not have installed on it a
licensed copy of the Alpha Five Application Server or the Alpha Anywhere Application Server.
*/
A5.controlBar={disclosure:{defaultContainer:''},items:{'html':{initialize:function(name,id,s,theme){$u.o.assign(s,{size:'',html:'',bind:{show:''}},true);var html=s.html;html='<div class="A5ControlBarItem" style="'+$if(s.size!='','A5CONTROLBARITEMSIZE: '+s.size+';','')+'">'+html+'</div>';if(s.bind.show!=''){html='{*if '+s.bind.show+'}'+html+'{*endif}';}
s.template=html;}},'button':{initialize:function(name,id,s,theme){$u.o.assign(s,{size:'',settings:{theme:theme,style:''},actions:{},bind:{show:'',disabled:''},autoHideDisclosure:'auto'},true);s.settings.style='width: 100%;'+s.settings.style;if(s.size!='')s.settings.style='A5CONTROLBARITEMSIZE: 100%;'+s.settings.style;var html=A5.buttons.html(id,s.settings,'a5-item="'+name+'"','',true);if(s.bind.disabled!=''){var dHTML=A5.buttons.html(id,s.settings,'a5-item="'+name+'"','disabled',true);html='{*if '+s.bind.disabled+'}'+dHTML+'{*else}'+html+'{*endif}';}
html='<div class="A5ControlBarItem" style="'+$if(s.size!='','A5CONTROLBARITEMSIZE: '+s.size+';','')+'">'+html+'</div>';if(s.bind.show!=''){html='{*if '+s.bind.show+'}'+html+'{*endif}';}
s.template=html;},event:function(type,name,value,item,ele,e){if(type=='down'){var id=ele.id;var pcn=item.settings.pressedClassName;if(pcn!='')$acn(ele,pcn);if(item.settings.pressedIcon!=''){A5.u.icon.update($(ele.id+'.ICON'),item.settings.pressedIcon);A5.buttons._p[id]={c:pcn,i:item.settings.icon};}else A5.buttons._p[id]=pcn;}
if(item.actions[type]){var data={item:{name:name,value:value,def:item},element:ele,event:e}
this.action(item.actions[type],data);}}},'button-toggle':{initialize:function(name,id,s,theme){$u.o.assign(s,{size:'',settings:{theme:theme,style:'',type:'two-state',keepPressed:true},actions:{},bind:{value:'',data:'',show:'',disabled:''},autoHideDisclosure:'auto'},true);s.settings.style='width: 100%;'+s.settings.style;if(s.size!='')s.settings.style='A5CONTROLBARITEMSIZE: 100%;'+s.settings.style;if(s.settings.type=='multi-state'){var sStr=JSON.stringify(s.settings);sStr=sStr.replace(/\{/g,'\\{');sStr=sStr.replace(/\}/g,'\\}');sStr=sStr.replace(/:/g,'\\:');html='{A5.buttons.html(\''+id+'\',function(od)\\{var o = '+sStr+'; $u.o.assign(o,od); return o;\\}('+s.bind.data+'['+s.bind.value+']),\'a5-item="'+name+'"\')}';}else{var html=A5.buttons.html(id,s.settings,'a5-item="'+name+'"','',true);if(s.settings.keepPressed){html='{*if '+s.bind.value+'}'+A5.buttons.html(id,s.settings,'a5-item="'+name+'"','pressed',true)+'{*else}'+html+'{*endif}';}
if(s.bind.disabled!=''){var dHTML=A5.buttons.html(id,s.settings,'a5-item="'+name+'"','disabled',true);html='{*if '+s.bind.disabled+'}'+dHTML+'{*else}'+html+'{*endif}';}}
html='<div class="A5ControlBarItem" style="'+$if(s.size!='','A5CONTROLBARITEMSIZE: '+s.size+';','')+'">'+html+'</div>';if(s.bind.show!=''){html='{*if '+s.bind.show+'}'+html+'{*endif}';}
s.template=html;},event:function(type,name,value,item,ele,e){if(type=='down'){var id=ele.id;var pcn=item.settings.pressedClassName;if(pcn!='')$acn(ele,pcn);if(item.settings.pressedIcon!=''){A5.u.icon.update($(ele.id+'.ICON'),item.settings.pressedIcon);A5.buttons._p[id]={c:pcn,i:item.settings.icon};}else A5.buttons._p[id]=pcn;}
if(type=='click'){var curV=A5.u.object.get(this.data,item.bind.value);if(item.settings.type=='multi-state'){curV++;var d=A5.u.object.get(this.data,item.bind.data);if(curV>=d.length)curV=0;this.update(item.bind.value,curV);}else{this.update(item.bind.value,!curV);}}
if(item.actions[type]){var data={item:{name:name,value:value,def:item},element:ele,event:e}
this.action(item.actions[type],data);}}},'button-list':{initialize:function(name,id,s,theme){$u.o.assign(s,{size:'',settings:{theme:theme,allowNullSelection:false,multiple:false,className:'',nullSelectionClassName:'',button:{keepPressed:true}},actions:{},bind:{data:'',value:'',show:''},autoHideDisclosure:'auto'},true);var ts={};A5.themes.assign(ts,s.settings.theme,'buttonList');$u.o.assign(s.settings,ts,true);var sStr=JSON.stringify(s.settings);sStr=sStr.replace(/\{/g,'\\{');sStr=sStr.replace(/\}/g,'\\}');sStr=sStr.replace(/:/g,'\\:');html='{A5.buttonLists.html(\''+id+'\','+sStr+','+s.bind.data+','+$if(s.settings.button.keepPressed,s.bind.value,'\'\'')+',\'a5-item="'+name+'" a5-value="\\{index\\}"\')}';var cStyle='';if(s.size=='')cStyle=' style="display: inline-block;"';if(s.settings.nullSelectionClassName!=''){html='<div class="'+s.settings.className+'{*if ('+s.bind.value+').toString() == \'\'}'+s.settings.nullSelectionClassName+'{*endif}"'+cStyle+'>'+html+'</div>';}else{html='<div class="'+s.settings.className+'"'+cStyle+'>'+html+'</div>';}
html='<div class="A5ControlBarItem" style="'+$if(s.size!='','A5CONTROLBARITEMSIZE: '+s.size+';','')+'">'+html+'</div>';if(s.bind.show!=''){html='{*if '+s.bind.show+'}'+html+'{*endif}';}
s.template=html;},event:function(type,name,value,item,ele,e){if(type=='down'){var id=ele.id;var pcn=item.settings.button.pressedClassName;if(pcn!=''){$acn(ele,pcn);A5.buttons._p[id]=pcn;}}
if(type=='click'){var d=A5.u.object.get(this.data,item.bind.data);var v=d[Number(value)];if(v){if(typeof v=='object'){v=v.value;}
var curV=A5.u.object.get(this.data,item.bind.value);if(item.settings.multiple){if(curV.constructor==Array){var cIndx=curV.indexOf(v);if(cIndx==-1){curV.push(v);v=curV;}else curV.splice(cIndx,1);if(item.settings.allowNullSelection===false&&curV.length==0)v=[v];else v=curV;}else console.log('ERROR - button-list value must be array if multiple select is set to true.');}else{if(item.settings.allowNullSelection===true&&v.toString()==curV.toString()){if(curV.constructor==Array)v=[];else v='';}else if(curV.constructor==Array)v=[v];}
this.update(item.bind.value,v);}}
if(item.actions[type]){var data={item:{name:name,value:value,def:item},element:ele,event:e}
this.action(item.actions[type],data);}}},'disclosure-button':{initialize:function(name,id,s,theme){$u.o.assign(s,{size:'',autoHideDisclosure:'always',disclosure:{name:'',type:''},actions:{},settings:{show:{theme:theme,style:''},hide:{theme:theme,style:''}},bind:{show:'',disabled:''}},true);s.settings.show.style='width: 100%;'+s.settings.show.style;s.settings.hide.style='width: 100%;'+s.settings.hide.style;if(s.size!=''){s.settings.show.style='A5CONTROLBARITEMSIZE: 100%;'+s.settings.show.style;s.settings.hide.style='A5CONTROLBARITEMSIZE: 100%;'+s.settings.hide.style;}
var showHTML=A5.buttons.html(id,s.settings.show,'a5-item="'+name+'"','',true);var hideHTML=A5.buttons.html(id,s.settings.hide,'a5-item="'+name+'"','',true);if(s.bind.disabled!=''){var dHTML=A5.buttons.html(id,s.settings.show,'a5-item="'+name+'"','disabled',true);showHTML='{*if '+s.bind.disabled+'}'+dHTML+'{*else}'+showHTML+'{*endif}';dHTML=A5.buttons.html(id,s.settings.hide,'a5-item="'+name+'"','disabled',true);hideHTML='{*if '+s.bind.disabled+'}'+dHTML+'{*else}'+hideHTML+'{*endif}';}
var html='{*if [temp].state.disclosure.shown && [temp].state.disclosure.name == \''+s.disclosure.name+'\'}'+hideHTML+'{*else}'+showHTML+'{*endif}';html='<div class="A5ControlBarItem" style="'+$if(s.size!='','A5CONTROLBARITEMSIZE: '+s.size+';','')+'">'+html+'</div>';if(s.bind.show!=''){html='{*if '+s.bind.show+'}'+html+'{*endif}';}
s.template=html;},event:function(type,name,value,item,ele,e){var id=ele.id;if(this._d.shown)var bs=item.settings.hide;else var bs=item.settings.show;if(type=='down'){var pcn=bs.pressedClassName;if(pcn!='')$acn(ele,pcn);if(bs.pressedIcon!=''){A5.u.icon.update($(ele.id+'.ICON'),bs.pressedIcon);A5.buttons._p[id]={c:pcn,i:bs.icon};}else A5.buttons._p[id]=pcn;}
if(type=='click'){if(this._d.shown)var html=A5.buttons.html(id,item.settings.hide,'a5-item="'+name+'"','',true);else var html=A5.buttons.html(id,item.settings.show,'a5-item="'+name+'"','',true);var pEle=ele.parentNode;pEle.innerHTML=A5.u.template.expand(this.data,html);A5.buttons._p[id]=pcn;}
if(item.actions[type]){var data={item:{name:name,value:value,def:item},element:ele,event:e}
this.action(item.actions[type],data);}}},'edit':{initialize:function(name,id,s,theme){$u.o.assign(s,{size:'',update:'default',actions:{},settings:{theme:theme,style:'',watermark:{text:'',className:''}},bind:{value:'',show:''}},true);var ts={};A5.themes.assign(ts,s.settings.theme,'edit');$u.o.assign(s.settings,ts,true);if(s.size!='')s.settings.style='A5CONTROLBARITEMSIZE: 100%;'+s.settings.style;s.settings.style='display: inline-block; overflow: hidden;'+s.settings.style;var wm=s.settings.watermark.text;if(wm=='')wm='&nbsp;';var html='{*if '+s.bind.value+' != \'\'}<div id="'+id+'" a5-item="'+name+'" class="'+s.settings.className+'" style="box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box; '+s.settings.style+'{*if [temp].state.edit.shown && [temp].state.edit.item == \''+name+'\'}visibility: hidden;{*endif}">{'+s.bind.value+'}</div>{*else}<div id="'+id+'" a5-item="'+name+'" class="'+s.settings.className+' '+s.settings.watermark.className+'" style="box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box; '+s.settings.style+'{*if [temp].state.edit.shown && [temp].state.edit.item == \''+name+'\'}visibility: hidden;{*endif}"><escape<'+wm+'>></div>{*endif}';html='<div class="A5ControlBarItem" style="'+$if(s.size!='','A5CONTROLBARITEMSIZE: '+s.size+';','')+'; text-align: left;">'+html+'</div>';if(s.bind.show!=''){html='{*if '+s.bind.show+'}'+html+'{*endif}';}
s.template=html;},event:function(type,name,value,item,ele,e){if(item.actions[type]){var data={item:{name:name,value:value,def:item},element:ele,event:e}
this.action(item.actions[type],data);}}}},_:{lDefs:{type:'default',className:'',style:'',bind:{show:''},before:{items:[]},middle:{items:[]},after:{items:[]}},initDone:false,init:function(){if(!A5.controlBar._.initDone){A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLine','position: relative; text-align: center;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLineCust','position: relative;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLineBefore','text-align: left;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLineAfter','text-align: right;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarItem','display: inline-block;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLineContentBefore','position: absolute; top: 0px; left: 0px;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLineContentAfter','position: absolute; top: 0px; right: 0px;');A5.u.css.setSelector('.A5ControlBarHorz .A5ControlBarLineBefore .A5ControlBarLineContentBefore, .A5ControlBarHorz .A5ControlBarLineAfter .A5ControlBarLineContentAfter','position: static;');A5.u.css.setSelector('.A5ControlBarCollapse .A5ControlBarHorz .A5ControlBarLine > div','position: static; display: inline;');A5.u.css.setSelector('.A5ControlBarCollapse .A5ControlBarHorz .A5ControlBarLine','text-align: inherit;');A5.u.css.setSelector('.A5ControlBarVert','display: table; height: 100%;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLine','display: table-cell; vertical-align: middle;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLineCust','display: table-cell;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLineBefore','display: table-cell; vertical-align: top;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLineAfter','display: table-cell; vertical-align: bottom;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLineContentBefore','position: absolute; top: 0px;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLineContentAfter','position: absolute; bottom: 0px;');A5.u.css.setSelector('.A5ControlBarVert .A5ControlBarLineBefore .A5ControlBarLineContentBefore, .A5ControlBarVert .A5ControlBarLineAfter .A5ControlBarLineContentAfter','position: static;');A5.u.css.setSelector('.A5ControlBarCollapse .A5ControlBarVert .A5ControlBarLine > div','position: static; display: block;');A5.u.css.setSelector('.A5ControlBarCollapse .A5ControlBarVert .A5ControlBarLine','vertical-align: top;');A5.controlBar._.initDone=true;}}}}
A5.ControlBar=Class.create({initialize:function(contId,data,settings){if(typeof settings=='undefined'){settings=data;data=null;}
this.contId=contId;A5.controlBar._.init();$u.o.assign(this,{theme:'',override:'base',edge:'top',className:'',disclosuresClassName:'',topClassName:'',bottomClassName:'',leftClassName:'',rightClassName:'',separator:{horizontalClassName:'',verticalClassName:''},items:{},actions:{},layout:'',layouts:{},disclosure:{container:A5.controlBar.disclosure.defaultContainer,animation:{duration:300,tween:'ease-in-out'},coverClassName:'',cover:{topClassName:'',bottomClassName:'',leftClassName:'',rightClassName:''},extend:{topClassName:'',bottomClassName:'',leftClassName:'',rightClassName:''},expand:{topClassName:'',bottomClassName:'',leftClassName:'',rightClassName:''},defaults:{type:'static',html:'',className:'',onInitialize:false,onBeforeDraw:false,onDraw:false,onSize:false,onShow:false,onShowComplete:false,onHide:false}},disclosures:{},data:{},state:{layout:'',edit:{shown:false,item:'',part:'',path:''},disclosure:{shown:false,name:'',type:'',edge:''}},onDraw:false,onBeforeDraw:false,onPopulate:false,onBeforePopulate:false,onChange:false});if(typeof settings.theme!='undefined')A5.themes.assign(this,settings.theme,'controlBar');$u.o.assign(this,settings);A5.overrides.assign(this,'controlBar',this.override);this.initializeItems();var cEle=$(contId);cEle.innerHTML='<div></div><input id="'+this.contId+'.EDIT" style="position: absolute; top: 0px; left: 0px; margin: 0px; display: none; box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box;" />';if(cEle.style.position!='absolute')cEle.style.position='relative';cEle.style.padding='0px';cEle.style.overflow='hidden';$acn(cEle,this.className);this._bindEvents(cEle);this._m={anim:false,next:{has:false,args:[]},async:{}};var egName='CONTROLBAR.'+this.contId;var dEle=document.createElement('div');dEle.id=this.contId+'.DISCLOSURES';$ss(dEle,'z-index: 100000; position: absolute; top: 0px; left: 0px; right: 0px; bottom: 0px; display: none;');dEle.innerHTML='<div style="position: absolute; overflow: hidden;"><div class="'+this.disclosure.defaults.className+'" id="'+this.contId+'.DISCLOSURE.A5CONTROLBARDYNAMIC" style="z-index: 100002; position: absolute; display: none;"><div></div><input id="'+this.contId+'.EDITDIS" style="position: absolute; top: 0px; left: 0px; margin: 0px; display: none; box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box;" /></div></div><div id="'+this.contId+'.DISCLOSURE.CLOSE" style="z-index: 100001; position: absolute; display: none;">&nbsp;</div>';$acn(dEle,this.disclosuresClassName);if(this.disclosure.container!='')$(this.disclosure.container).appendChild(dEle);else document.body.insertBefore(dEle,document.body.firstChild);this._bindEvents(dEle.children[0].children[0]);$e.add(dEle,A5.d.evnts.click,this._disClick,this,false,egName);$e.add(this.contId+'.DISCLOSURE.CLOSE',A5.d.evnts.click,this._disCloseClick,this,false,egName);if(A5.flags.supportsTouch){$e.add(dEle,'touchmove',function(e){var tempT=$e.getTouches(e);var pDef=true;if(tempT){if(tempT.length){if(tempT.length>1)pDef=false;}}
if(pDef)$e.preventDefault(e);});}
this._d={ele:dEle,shown:false,current:false,next:false};var dd=null;for(var d in this.disclosures){dd=this.disclosures[d];this.addDisclosure(d,dd,true);}
var eEle=$(this.contId+'.EDIT');var edEle=$(this.contId+'.EDITDIS');$e.add(eEle,'keyup',this._editKeyup,this,false,egName);$e.add(edEle,'keyup',this._editKeyup,this,false,egName);$e.add(eEle,'blur',this._editBlur,this,false,egName);$e.add(edEle,'blur',this._editBlur,this,false,egName);this._e={ele:eEle,dEle:edEle,shown:0,current:false};if(data!=null)this.populate(data);else this.refresh();if(!A5.flags.isMobile)$e.add(window,'resize',this._relayout,this,true,egName);else{$e.add(window,'orientationchange',this._relayout,this,true,egName);if(A5.flags.iOSVersion==-1)$e.add(window,'resize',this._relayout,this,true,egName);}
$e.add(document,'webkitfullscreenchange',this._relayout,this,true,egName);$e.add(document,'mozfullscreenchange',this._relayout,this,true,egName);$e.add(document,'fullscreenchange',this._relayout,this,true,egName);$e.add(document,'fullscreenchange',this._relayout,this,true,egName);},initializeItems:function(){var iObj=null;var iTObj=null;var theme=this.theme;theme=theme.split(':').shift();for(var item in this.items){iObj=this.items[item];iTObj=A5.controlBar.items[iObj.type];if(iTObj)iTObj.initialize(item,this.contId+'.'+item,iObj,theme);else iObj.template='ERROR '+item+' - Item type "'+iObj.type+'" not found!';}
for(var layout in this.layouts){if(typeof this.layouts[layout]._t!='undefined'){delete this.layouts[layout]._t.top;delete this.layouts[layout]._t.bottom;delete this.layouts[layout]._t.left;delete this.layouts[layout]._t.right;}}},destroy:function(){$e.removeGroup('CONTROLBAR.'+this.contId);var dEle=this._d.ele;if(dEle){var pEle=dEle.parentNode;if(pEle)pEle.removeChild(dEle);}},populate:function(data){var anim=typeof arguments[1]!='undefined'?arguments[1]:false;var fEvnts=typeof arguments[2]!='undefined'?arguments[2]:true;var async=typeof arguments[3]!='undefined'?arguments[3]:false;if(this.onBeforePopulate.constructor==Function&&fEvnts){var res=this.onBeforePopulate.call(this,data);if(typeof res=='boolean'){if(!res)return false;}}
this.data={};$u.o.assign(this.data,data);this.refresh(anim,async);if(this.onPopulate.constructor==Function&&fEvnts)this.onPopulate.call(this,data);},update:function(p,v){var anim=typeof arguments[2]!='undefined'?arguments[2]:false;var fEvnts=typeof arguments[3]!='undefined'?arguments[3]:true;var async=typeof arguments[4]!='undefined'?arguments[4]:false;if(typeof p=='string'){p=[p];v=[v];}
for(var i=0;i<p.length;i++)A5.u.object.set(this.data,p[i],v[i],true);if(fEvnts){if(this.onChange.constructor==Function)this.onChange.call(this,p,v);}
this.refresh(anim,async);},setLayout:function(l){if(this.layouts[l]){var anim=typeof arguments[1]!='undefined'?arguments[1]:false;var async=typeof arguments[2]!='undefined'?arguments[2]:false;this.layout=l;this.refresh(anim,async);}else console.log('ERROR - control bar layout "'+l+'" not found');},refresh:function(){var anim=typeof arguments[0]!='undefined'?arguments[0]:false;var async=typeof arguments[1]!='undefined'?arguments[1]:false;if(this._m.anim){this._m.next.has=true;this._m.next.args=[anim,async];return false;}
if(async){clearTimeout(this._m.async.to);var ci=this;this._m.async.to=setTimeout(function(){ci.refresh.apply(ci,ci._m.async.args);delete ci;},0);this._m.async.args=[anim];return false;}
if(this.onBeforeDraw.constructor==Function)this.onBeforeDraw.call(this,'main');var l='';if(this.layout.constructor==Function)l=this.layout.call(this);else l=this.layout;this._cl=this.layouts[l];this.state.layout=l;this._compileTemplate(this._cl,this.edge);var cEle=$(this.contId);var html=A5.u.template.expand(this.data,{template:this._cl._t[this.edge]},{state:this.state},this);var animDo=false;var cn='class="'+this[this.edge+'ClassName']+'" ';var hCSS='';if(this.edge=='left'||this.edge=='right')hCSS=' height: 100%;';if(anim){if(typeof anim!='object')anim={type:anim,duration:500};if(!anim.tween)anim.tween='ease-in-out';if(anim.type.indexOf('-in')!=-1||anim.type.indexOf('-out')!=-1||anim.type.indexOf('-before')!=-1||anim.type.indexOf('-after')!=-1){if(this.edge=='top'){anim.type=anim.type.replace('-in','-top').replace('-out','-bottom').replace('-before','-left').replace('-after','-right');}else if(this.edge=='bottom'){anim.type=anim.type.replace('-in','-bottom').replace('-out','-top').replace('-before','-left').replace('-after','-right');}else if(this.edge=='left'){anim.type=anim.type.replace('-in','-left').replace('-out','-right').replace('-before','-top').replace('-after','-bottom');}else if(this.edge=='right'){anim.type=anim.type.replace('-in','-right').replace('-out','-left').replace('-before','-top').replace('-after','-bottom');}}
var oldHTML='';var ccEle=$(this.contId+'.CONTENT');if(ccEle){oldHTML=ccEle.innerHTML;oldHTML=oldHTML.replace(/id="[^"]+"/g,'').replace(/a5-item="[^"]+"/g,'');}
var tProp=A5.u.css.properties.transform;var tPropDOM=A5.u.css.properties.transformDOM;var taProp=tProp.replace('transform','transition');if(anim.type.indexOf('slide-')==0){var vals=['0px','100%','0px','-100%'];if(anim.type=='slide-left')vals=['100%','0px','-100%','0px'];else if(anim.type=='slide-right')vals=['-100%','0px','100%','0px'];else if(anim.type=='slide-bottom')vals=['0px','-100%','0px','100%'];var taVal=taProp+': '+tProp+' '+anim.duration+'ms '+anim.tween+';';html='<div '+cn+'id="'+this.contId+'.CONTENTOLD" style="position: absolute; width: 100%;'+hCSS+' '+tProp+': '+A5.u.css.transform2D('0px','0px')+'; '+taVal+'">'+oldHTML+'</div><div '+cn+'id="'+this.contId+'.CONTENT" style="'+hCSS+''+tProp+': '+A5.u.css.transform2D(vals[0],vals[1])+'; '+taVal+'">'+html+'</div>';animDo=[{p:tPropDOM,v:A5.u.css.transform2D('0px','0px')},{p:tPropDOM,v:A5.u.css.transform2D(vals[2],vals[3])}];}else if(anim.type.indexOf('swap-')==0){var vals=['0px','-100%'];if(anim.type=='swap-left')vals=['-100%','0px'];else if(anim.type=='swap-right')vals=['100%','0px'];else if(anim.type=='swap-bottom')vals=['0px','100%'];var hDur=(anim.duration/2);var taVal=taProp+': '+tProp+' '+hDur+'ms '+anim.tween+';';html='<div '+cn+'id="'+this.contId+'.CONTENTOLD" style="position: absolute; width: 100%;'+hCSS+' '+tProp+': '+A5.u.css.transform2D('0px','0px')+'; '+taVal+'">'+oldHTML+'</div><div '+cn+'id="'+this.contId+'.CONTENT" style="'+hCSS+''+tProp+': '+A5.u.css.transform2D(vals[0],vals[1])+'; '+taVal+' transition-delay: '+hDur+'ms;">'+html+'</div>';animDo=[{p:tPropDOM,v:A5.u.css.transform2D('0px','0px')},{p:tPropDOM,v:A5.u.css.transform2D(vals[0],vals[1])}];}else if(anim.type=='fade'){var taVal=taProp+': opacity '+anim.duration+'ms '+anim.tween+';';html='<div '+cn+'id="'+this.contId+'.CONTENTOLD" style="position: absolute; width: 100%;'+hCSS+' opacity: 1; '+taVal+'">'+oldHTML+'</div><div '+cn+'id="'+this.contId+'.CONTENT" style="'+hCSS+'opacity: 0; '+taVal+'">'+html+'</div>';animDo=[{p:'opacity',v:'1'},{p:'opacity',v:'0'}];}else html='<div id="'+this.contId+'.CONTENT" style="'+hCSS+'">'+html+'</div>';}else html='<div '+cn+'id="'+this.contId+'.CONTENT" style="'+hCSS+'">'+html+'</div>';if(hCSS=='')cEle.children[0].style.height='';else cEle.children[0].style.height='100%';cEle.children[0].innerHTML=html;this._m.anim=false;if(animDo){var lcEle=$(this.contId+'.CONTENT');var lcoEle=$(this.contId+'.CONTENTOLD');lcEle.offsetWidth;lcEle.style[animDo[0].p]=animDo[0].v;lcoEle.style[animDo[1].p]=animDo[1].v;var ci=this;setTimeout(function(){var ele=$(ci.contId+'.CONTENTOLD');pEle=ele.parentNode;pEle.removeChild(ele);ci._refreshAnimComplete();delete ci;delete ele;delete pEle;},anim.duration);this._m.anim=true;}
if(this.onDraw.constructor==Function)this.onDraw.call(this,'main',cEle);if(this._d.shown){if(this._d.current.s.isTemplate){if(this._d.current.s.name.substr(0,7)=='layout:'){var dEle=$(this.contId+'.DISCLOSURE.A5CONTROLBARDYNAMIC');if(this.onBeforeDraw.constructor==Function)this.onBeforeDraw.call(this,'disclosure');var layoutEdge=this._d.current.layoutEdge;var cn='class="'+this[layoutEdge+'ClassName']+'" ';var hCSS='';if(layoutEdge=='left'||layoutEdge=='right')hCSS='height: 100%;';if(hCSS=='')dEle.children[0].style.height='';else dEle.children[0].style.height='100%';dEle.children[0].innerHTML='<div '+cn+' style="'+hCSS+'">'+A5.u.template.expand(this.data,{template:this._cdl._t[layoutEdge]},{state:this.state},this)+'</div>';if(this.onDraw.constructor==Function)this.onDraw.call(this,'disclosure',dEle);}else{var dd=this.disclosures[this._d.current.s.name];var dEle=$(this.contId+'.DISCLOSURE.'+this._d.current.s.name);if(dd.onBeforeDraw.constructor==Function)dd.onBeforeDraw.call(this,dEle);A5.u.element.setContent(dEle,A5.u.template.expand(this.data,{template:dd._t},{state:this.state},this));if(dd.onDraw.constructor==Function)dd.onDraw.call(this,dEle);}}}},action:function(action){if(this.actions[action]){var data=typeof arguments[1]!='undefined'?arguments[1]:false;this.actions[action].call(this,data);}else console.log('ERROR - control bar action "'+action+'" not found');},focus:function(name){var iObj=this.items[name];if(iObj){var id=this.contId+'.'+name;var ele=$(id);if(iObj.type=='edit'){if(ele){var part='disclosure';while(ele!=document.body){if(ele.id==this.contId){part='main';break;}
ele=ele.parentNode;}
if(this.state.edit.shown){var tEle=$(this._e.current.id);tEle.innerHTML=this._e.ele.value;tEle.style.visibility='';}
this._e.current={item:iObj,id:id,p:part};if(part=='main')var eEle=this._e.ele;else var eEle=this._e.dEle;eEle.className=iObj.settings.className;$ss(eEle,iObj.settings.style+'; position: absolute; top: 0px; left: 0px; margin: 0px; display: none; box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box;');var ev=A5.u.object.get(this.data,iObj.bind.value);eEle.value=ev;this._editPos();eEle.focus();eEle.select();this.state.edit.shown=true;this.state.edit.item=name;this.state.edit.part=part;this.state.edit.path=iObj.bind.value;}}else ele.focus();}},addDisclosure:function(n,s,ow){if(this.disclosures[n]&&!ow)return false;var cdEle=$(this.contId+'.DISCLOSURES').children[0];A5.u.object.assign(s,this.disclosure.defaults,true);if(!ow)this.disclosures[n]=s;var tdEle=document.createElement('div');tdEle.id=this.contId+'.DISCLOSURE.'+n;tdEle.className=s.className;tdEle.style.position='absolute';tdEle.style.display='none';tdEle.style.zIndex='100002';cdEle.appendChild(tdEle);if(s.type=='template')this._bindEvents(tdEle);else tdEle.innerHTML=s.html;if(s.onInitialize.constructor==Function)s.onInitialize.call(this,tdEle);return true;},showDisclosure:function(s){if(this._d.shown){this._d.next=s;this.hideDisclosure();}else{var ele=typeof arguments[1]!='undefined'?arguments[1]:false;ele=$(ele);$u.o.assign(s,{name:'',type:'extend',size:false,margin:{top:0,left:0,right:0,bottom:0},animation:true,autoHide:true,className:'',coverClassName:this.disclosure.coverClassName},true);if(typeof s.margin.top!='number')s.margin.top=A5.u.convertUnits(s.margin.top.toString(),'px');if(typeof s.margin.left!='number')s.margin.left=A5.u.convertUnits(s.margin.left.toString(),'px');if(typeof s.margin.right!='number')s.margin.right=A5.u.convertUnits(s.margin.right.toString(),'px');if(typeof s.margin.bottom!='number')s.margin.bottom=A5.u.convertUnits(s.margin.bottom.toString(),'px');var type=s.type;if(type.indexOf('element')!=-1&&!ele){type=type.split('-').shift();if(type=='expand')type='expand-after';}
this._cdl=false;var dd=false;if(s.name.substr(0,7)=='layout:'){var dEle=$(this.contId+'.DISCLOSURE.A5CONTROLBARDYNAMIC');this._cdl=this.layouts[s.name.substr(7)];if(!this._cdl)return false;if(s.className=='')s.className=this.disclosure.defaults.className;s.isTemplate=true;}else{dd=this.disclosures[s.name];if(!dd)return false;var dEle=$(this.contId+'.DISCLOSURE.'+s.name);if(s.className=='')s.className=dd.className;if(dd.type=='template'){s.isTemplate=true;if(typeof dd._t=='undefined'){var tPH='';var tHTML=dd.html;for(var item in this.items){tPH='['+item+']';if(tHTML.indexOf(tPH)!=-1)tHTML=tHTML.split(tPH).join(this.items[item].template);}
tHTML=tHTML.replace(/A5CONTROLBARITEMSIZE/gi,'width');tHTML=tHTML.replace(/A5CONTROLBARSEPCLASSNAME/gi,this.separator.horizontalClassName);dd._t=A5.u.template.parse(tHTML);}
if(dd.onBeforeDraw.constructor==Function)dd.onBeforeDraw.call(this,dEle);A5.u.element.setContent(dEle,A5.u.template.expand(this.data,{template:dd._t},{state:this.state},this));if(dd.onDraw.constructor==Function)dd.onDraw.call(this,dEle);}else s.isTemplate=false;}
dEle.className=s.className;dEle.style.top='';dEle.style.bottom='';dEle.style.left='';dEle.style.right='';dEle.style.width='';dEle.style.height='';if(type=='explicit'){if(s.rectangle.constructor==Function)var rect=s.rectangle.call(this,s,ele);else var rect=s.rectangle;}else var rect=this._getDisclosureRect(type,ele);var layoutEdge=this.edge;if(s.name.substr(0,7)=='layout:'){if(type=='outside-before'||type=='outside-after'||type.split('-').shift()=='screen')layoutEdge=rect.edge;this._compileTemplate(this._cdl,layoutEdge);if(this.onBeforeDraw.constructor==Function)this.onBeforeDraw.call(this,'disclosure');var cn='class="'+this[layoutEdge+'ClassName']+'" ';var hCSS='';if(layoutEdge=='left'||layoutEdge=='right')hCSS='height: 100%;';if(hCSS=='')dEle.children[0].style.height='';else dEle.children[0].style.height='100%';dEle.children[0].innerHTML='<div '+cn+' style="'+hCSS+'">'+A5.u.template.expand(this.data,{template:this._cdl._t[layoutEdge]},{state:this.state},this)+'</div>';if(this.onDraw.constructor==Function)this.onDraw.call(this,'disclosure',dEle);}
var dcEle=this._d.ele.children[0];if(typeof rect.className!='undefined')dcEle.className=rect.className;else dcEle.className='';dcEle.style.top=(rect.top+s.margin.top)+'px';dcEle.style.bottom=(rect.bottom+s.margin.bottom)+'px';dcEle.style.left=(rect.left+s.margin.left)+'px';dcEle.style.right=(rect.right+s.margin.right)+'px';var setMargin=false;dEle.style[rect.edge]='0px';dEle.style.marginLeft='';dEle.style.marginTop='';if(rect.fill=='both'||s.size=='fill'){dEle.style.top='0px';dEle.style.bottom='0px';dEle.style.left='0px';dEle.style.right='0px';}else if(rect.fill=='width'){dEle.style.left='0px';dEle.style.right='0px';}else if(rect.fill=='height'){dEle.style.top='0px';dEle.style.bottom='0px';}else{if(!rect.align)rect.align='middle';if(rect.align=='before'){if(rect.edge=='top'||rect.edge=='bottom')dEle.style.left='0px';else dEle.style.top='0px';}else if(rect.align=='after'){if(rect.edge=='top'||rect.edge=='bottom')dEle.style.right='0px';else dEle.style.bottom='0px';}else{if(rect.edge=='top'||rect.edge=='bottom')dEle.style.left='50%';else dEle.style.top='50%';setMargin=true;}}
var startTrans='';if(rect.edge=='top'){startTrans=A5.u.css.transform2D('0px','-100%');if(s.size&&s.size!='fill'&&type!='cover'){dEle.style.height=s.size;}}else if(rect.edge=='bottom'){startTrans=A5.u.css.transform2D('0px','100%');if(s.size&&s.size!='fill'&&type!='cover'){dEle.style.height=s.size;}}else if(rect.edge=='left'){startTrans=A5.u.css.transform2D('-100%','0px');if(s.size&&s.size!='fill'&&type!='cover'){dEle.style.width=s.size;}}else if(rect.edge=='right'){startTrans=A5.u.css.transform2D('100%','0px');if(s.size&&s.size!='fill'&&type!='cover'){dEle.style.width=s.size;}}
dEle.style.display='';if(type.split('-').shift()=='expand'&&!s.size)this._d.ele.className=this.disclosuresClassName+' '+s.coverClassName+' A5ControlBarCollapse';else this._d.ele.className=this.disclosuresClassName+' '+s.coverClassName;var dur=this.disclosure.animation.duration;var tween=this.disclosure.animation.tween;var completeDelay=false;if(s.animation){if(typeof s.animation=='object'){if(s.animation.duration)dur=s.animation.duration;if(s.animation.tween)tween=s.animation.tween;}
var cssDOMProp=A5.u.css.properties.transformDOM;var cssAnimProp=A5.u.css.properties.transitionDOM;dEle.style[cssDOMProp]=startTrans;dEle.style[cssAnimProp]='';this._d.ele.style.display='';dEle.offsetHeight;dEle.style[cssAnimProp]=A5.u.css.properties.transform+' '+dur+'ms '+tween;dEle.style[cssDOMProp]=A5.u.css.transform2D('0px','0px');completeDelay=true;}else{var cssDOMProp=A5.u.css.properties.transformDOM;var cssAnimProp=A5.u.css.properties.transitionDOM;dEle.style[cssDOMProp]=A5.u.css.transform2D('0px','0px');dEle.style[cssAnimProp]='';this._d.ele.style.display='';dEle.offsetHeight;dEle.style[cssAnimProp]=A5.u.css.properties.transform+' '+dur+'ms '+tween;}
if(setMargin){if(rect.edge=='top'||rect.edge=='bottom')dEle.style.marginLeft='-'+(dEle.offsetWidth/2)+'px';else dEle.style.marginTop='-'+(dEle.offsetHeight/2)+'px';}
var eleId=false
if(ele)eleId=ele.id;this._d.current={s:s,eleId:eleId,dEle:dEle,trans:startTrans,dur:dur,layoutEdge:layoutEdge,internalShow:false};this._d.next=false;this._d.shown=true;var dbcEle=$(this.contId+'.DISCLOSURE.CLOSE');dbcEle.style.display='none';if(this._d.internalShow&&ele){this._d.current.internalShow=true;var eBRect=ele.getBoundingClientRect();var tOff=0;var lOff=0;if(this.disclosure.container!=''){var cEle=$(this.disclosure.container);if(cEle){var ceBRect=cEle.getBoundingClientRect();tOff=ceBRect.top;lOff=ceBRect.left;}}
dbcEle.style.top=(eBRect.top-tOff)+'px';dbcEle.style.left=(eBRect.left-lOff)+'px';dbcEle.style.width=eBRect.width+'px';dbcEle.style.height=eBRect.height+'px';dbcEle.style.display='block';}
this.state.disclosure.shown=true;this.state.disclosure.name=s.name;this.state.disclosure.type=type;this.state.disclosure.edge=layoutEdge;if(dd){$e.execute(dEle,'a5resize');if(dd.onShow.constructor==Function)dd.onShow.call(this,dEle);if(dd.onSize.constructor==Function)dd.onSize.call(this,dEle);if(completeDelay){var ci=this;setTimeout(function(){ci._showDisclosureComplete();delete ci;},dur+10);}else this._showDisclosureComplete();}}},hideDisclosure:function(){if(this._d.shown){if(this.state.edit.shown&&this.state.edit.part!='main'){this._e.dEle.blur();this._editBlur.call(this._e.dEle,false,this);}
var anim=typeof arguments[0]!='undefined'?arguments[0]:true;var dur=0;if(anim){this._d.current.dEle.style[A5.u.css.properties.transformDOM]=this._d.current.trans;dur=this._d.current.dur;}
clearTimeout(this._hdcTO);var ci=this;this._hdcTO=setTimeout(function(){ci._hideDisclosureComplete();delete ci;},dur);}},resizeDisclosure:function(){if(this._d.shown){var s=this._d.current.s;var type=s.type
if(type=='explicit'){if(s.rectangle.constructor==Function)var rect=s.rectangle.call(this,s,$(this._d.current.eleId));else var rect=s.rectangle;}else var rect=this._getDisclosureRect(type,$(this._d.current.eleId));var dcEle=this._d.ele.children[0];dcEle.style.top=(rect.top+s.margin.top)+'px';dcEle.style.bottom=(rect.bottom+s.margin.bottom)+'px';dcEle.style.left=(rect.left+s.margin.left)+'px';dcEle.style.right=(rect.right+s.margin.right)+'px';var dd=this.disclosures[s.name];if(dd){$e.execute(this._d.current.dEle,'a5resize');if(dd.onSize.constructor==Function)dd.onSize.call(this,this._d.current.dEle);}
if(this._d.current.internalShow){var dbcEle=$(this.contId+'.DISCLOSURE.CLOSE');var eBRect=$(this._d.current.eleId).getBoundingClientRect();var tOff=0;var lOff=0;if(this.disclosure.container!=''){var cEle=$(this.disclosure.container);if(cEle){var ceBRect=cEle.getBoundingClientRect();tOff=ceBRect.top;lOff=ceBRect.left;}}
dbcEle.style.top=(eBRect.top-tOff)+'px';dbcEle.style.left=(eBRect.left-lOff)+'px';dbcEle.style.width=eBRect.width+'px';dbcEle.style.height=eBRect.height+'px';}}},_getDisclosureRect:function(type,ele){var rect={top:0,left:0,right:0,bottom:0,edge:this.edge,fill:'',className:''};var cBRect=$(this.contId).getBoundingClientRect();var eBRect=false;if(ele)eBRect=ele.getBoundingClientRect();if(this.disclosure.container!=''){var tBRect=$(this.disclosure.container).getBoundingClientRect();var leftOff=tBRect.left;var topOff=tBRect.top;var docWidth=tBRect.width;var docHeight=tBRect.height;}else{var leftOff=0;var topOff=0;var docWidth=document.documentElement.clientWidth;var docHeight=document.documentElement.clientHeight;}
if(type.split('-').shift()=='expand'){rect.top=cBRect.top-topOff;rect.bottom=docHeight-cBRect.bottom+topOff;rect.left=cBRect.left-leftOff;rect.right=docWidth-cBRect.right+leftOff;if(this.edge=='top'||this.edge=='bottom'){rect.fill='height';if(type=='expand-before'){rect.edge='left';}else if(type=='expand-after'){rect.edge='right';}else if(type=='expand-element'||type=='expand-element-cover'){if(eBRect.left>(cBRect.left+(cBRect.width/2))){rect.edge='right';if(type=='expand-element')rect.right=(docWidth-eBRect.left+leftOff);else rect.right=(docWidth-eBRect.right+leftOff);}else{rect.edge='left';if(type=='expand-element')rect.left=eBRect.right-leftOff;else rect.left=eBRect.left-leftOff;}}}else{rect.fill='width';if(type=='expand-before'){rect.edge='top';}else if(type=='expand-after'){rect.edge='bottom';}else if(type=='expand-element'||type=='expand-element-cover'){if(eBRect.top>(cBRect.top+(cBRect.height/2))){rect.edge='bottom';if(type=='expand-element')rect.bottom=(docHeight-eBRect.top+topOff);else rect.bottom=(docHeight-eBRect.bottom+topOff);}else{rect.edge='top';if(type=='expand-element')rect.top=eBRect.bottom-topOff;else rect.top=eBRect.top-topOff;}}}
rect.className=this.disclosure.expand[rect.edge+'ClassName'];}else if(type.split('-').shift()=='flyout'){if(this.edge=='top'||this.edge=='bottom'){if(this.edge=='top'){if(type=='flyout-element')rect.top=eBRect.bottom-topOff;else if(type=='flyout-element-cover')rect.top=eBRect.top-topOff;else rect.top=cBRect.bottom-topOff;}else{if(type=='flyout-element')rect.bottom=docHeight-eBRect.top+topOff;else if(type=='flyout-element-cover')rect.bottom=docHeight-eBRect.bottom+topOff;else rect.bottom=docHeight-cBRect.top+topOff;}
if(eBRect.left>(cBRect.left+(cBRect.width/2))){rect.align='after';rect.right=(docWidth-eBRect.right+leftOff);}else{rect.align='before';rect.left=eBRect.left-leftOff;}}else{if(this.edge=='left'){if(type=='flyout-element')rect.left=eBRect.right-leftOff;else if(type=='flyout-element-cover')rect.left=eBRect.left-leftOff;else rect.left=cBRect.right-leftOff;}else{if(type=='flyout-element')rect.right=docWidth-eBRect.left+leftOff;else if(type=='flyout-element-cover')rect.right=docWidth-eBRect.right+leftOff;else rect.right=docWidth-cBRect.left+leftOff;}
if(eBRect.top>(cBRect.top+(cBRect.height/2))){rect.align='after';rect.bottom=(docHeight-eBRect.bottom+topOff);}else{rect.align='before';rect.top=eBRect.top-topOff;}}}else if(type=='cover'){rect.top=cBRect.top-topOff;rect.bottom=docHeight-cBRect.bottom+topOff;rect.left=cBRect.left-leftOff;rect.right=docWidth-cBRect.right+leftOff;rect.fill='both';rect.className=this.disclosure.cover[rect.edge+'ClassName'];}else if(type.split('-').shift()=='screen'){rect.edge=type.split('-').pop();if(rect.edge=='left'||rect.edge=='right')rect.fill='height';else rect.fill='width';}else{if(this.edge=='top'){rect.left=cBRect.left-leftOff;rect.right=docWidth-cBRect.right+leftOff;rect.fill='width';if(type=='extend-element'){rect.top=eBRect.bottom-topOff;}else if(type=='extend-element-cover'){rect.top=eBRect.top-topOff;}else{rect.top=cBRect.bottom-topOff;if(type=='outside-before'){rect.fill='height';rect.edge='left';}else if(type=='outside-after'){rect.fill='height';rect.edge='right';}}}else if(this.edge=='bottom'){rect.left=cBRect.left-leftOff;rect.right=docWidth-cBRect.right+leftOff;rect.fill='width';if(type=='extend-element'){rect.bottom=docHeight-eBRect.top+topOff;}else if(type=='extend-element-cover'){rect.bottom=docHeight-eBRect.bottom+topOff;}else{rect.bottom=docHeight-cBRect.top+topOff;if(type=='outside-before'){rect.fill='height';rect.edge='left';}else if(type=='outside-after'){rect.fill='height';rect.edge='right';}}}else if(this.edge=='left'){rect.top=cBRect.top-topOff;rect.bottom=docHeight-cBRect.bottom+topOff;rect.fill='height';if(type=='extend-element'){rect.left=eBRect.right-leftOff;}else if(type=='extend-element-cover'){rect.left=eBRect.left-leftOff;}else{rect.left=cBRect.right-leftOff;if(type=='outside-before'){rect.fill='width';rect.edge='top';}else if(type=='outside-after'){rect.fill='width';rect.edge='bottom';}}}else if(this.edge=='right'){rect.top=cBRect.top-topOff;rect.bottom=docHeight-cBRect.bottom+topOff;rect.fill='height';if(type=='extend-element'){rect.right=docWidth-eBRect.left+leftOff;}else if(type=='extend-element-cover'){rect.right=docWidth-eBRect.right+leftOff;}else{rect.right=docWidth-cBRect.left+leftOff;if(type=='outside-before'){rect.fill='width';rect.edge='top';}else if(type=='outside-after'){rect.fill='width';rect.edge='bottom';}}}
rect.className=this.disclosure.extend[rect.edge+'ClassName'];}
return rect;},_showDisclosureComplete:function(){if(this._d.shown){var dd=this.disclosures[this._d.current.s.name];if(dd){if(dd.onShowComplete.constructor==Function)dd.onShowComplete.call(this,this._d.current.dEle);}}},_hideDisclosureComplete:function(){if(this._d.shown){this._d.shown=false;this.state.disclosure.shown=false;this._d.current.dEle.style.display='none';var dd=this.disclosures[this._d.current.s.name];if(dd){if(dd.onHide.constructor==Function)dd.onHide.call(this,this._d.current.dEle);}
if(this._d.next){this.showDisclosure(this._d.next,this._d.current.eleId);}else{this._d.ele.style.display='none';this._d.current=false;}
this.refresh();}},_refreshAnimComplete:function(){this._m.anim=false;if(this._m.next.has){this._m.next.has=false;this.refresh.apply(this,this._m.next.args);delete this._m.next.args;}},_relayout:function(){if(this._d.shown){var ci=this
clearTimeout(this._rdTO);this._rdTO=setTimeout(function(){ci.resizeDisclosure();delete ci},50);}
if(this._e.shown){var ci=this
clearTimeout(this._reTO);this._reTO=setTimeout(function(){ci._editPos();delete ci},50);}},_disClick:function(e,ci){if(ci._d.current){var cEle=$(ci.contId);var coor=$e.getCoors(e);var ele=document.elementFromPoint(coor.clientX,coor.clientY);if(!ele)return true;while(ele!=cEle&&ele!=document.body){if(ele.hasAttribute('a5-action'))ci.action(ele.getAttribute('a5-action'),{element:ele,event:e});else if(ele==ci._d.current.dEle)return true;ele=ele.parentNode;}
if(ci._d.current){if(!ci._d.current.s.autoHide)return true;ci.hideDisclosure();}}},_disCloseClick:function(e,ci){ci.hideDisclosure();},_editKeyup:function(e,ci){if(ci.state.edit.item!=''){if(ci._e.current.item.update!='done')ci.update(ci.state.edit.path,this.value);A5.controlBar.items.edit.event.call(ci,'keyup',ci.state.edit.item,this.value,ci.items[ci.state.edit.item],this,e);var keyCode=e.charCode||e.keyCode;if(keyCode==13)this.blur();}},_editBlur:function(e,ci){if(document.activeElement!=ci._e.ele&&document.activeElement!=ci._e.dEle&&ci.state.edit.item!=''){ci._e.shown=false;$(ci._e.current.id).style.visibility='';A5.controlBar.items.edit.event.call(ci,'done',ci.state.edit.item,this.value,ci.items[ci.state.edit.item],this,e);this.style.display='none';ci.state.edit.shown=false;ci.state.edit.item='';ci.state.edit.part='';if(ci._e.current.item.update=='done')ci.update(ci.state.edit.path,this.value);}},_editPos:function(){var tEle=$(this._e.current.id);if(tEle){if(this._e.current.p=='main')var ele=this._e.ele;else var ele=this._e.dEle;var eBRect=tEle.getBoundingClientRect();var peBRect=ele.parentNode.getBoundingClientRect();ele.style.top=(eBRect.top-peBRect.top)+'px';ele.style.left=(eBRect.left-peBRect.left)+'px';ele.style.width=eBRect.width+'px';ele.style.height=eBRect.height+'px';ele.style.display='';tEle.style.visibility='hidden';this._e.shown=true;}else{this._e.ele.style.display='none';this._e.dEle.style.display='none';this._e.shown=false;}},_down:function(e,ci){var r=ci._aEle(e);ci._startItem=false;if(r){ci._startItem={i:r.i,v:r.v,id:r.ele.id};if($ga(r.ele,'a5-disabled')!='true'&&!r.ele.disabled){var iObj=ci.items[r.i];if(iObj){var iTObj=A5.controlBar.items[iObj.type];if(iTObj){if(iTObj.event)iTObj.event.call(ci,'down',r.i,r.v,iObj,r.ele,e);}}}}
delete r;},_up:function(e,ci){var r=ci._aEle(e);if(r){if($ga(r.ele,'a5-disabled')!='true'&&!r.ele.disabled){var iObj=ci.items[r.i];if(iObj){var iTObj=A5.controlBar.items[iObj.type];if(iTObj){if(iTObj.event)iTObj.event.call(ci,'up',r.i,r.v,iObj,r.ele,e);}
if(A5.u.drag._sDif<$e.abstractEvents.click.scrollMax){var id='';if(ci._startItem){if(ci._startItem.i==r.i){id=r.ele.id;var dShown=ci._d.shown;if(iObj.disclosure){if(iObj.autoHideDisclosure!='auto')ci._d.internalShow=true;ci.showDisclosure(iObj.disclosure,r.ele);ci._d.internalShow=false;}else if(iObj.type=='edit'){if(ci.state.edit.shown){var tEle=$(ci._e.current.id);tEle.innerHTML=ci._e.ele.value;tEle.style.visibility='';}
ci._e.current={item:iObj,id:id,p:r.p};if(r.p=='main')var eEle=ci._e.ele;else var eEle=ci._e.dEle;eEle.className=iObj.settings.className;$ss(eEle,iObj.settings.style+'; position: absolute; top: 0px; left: 0px; margin: 0px; display: none; box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box;');var ev=A5.u.object.get(ci.data,iObj.bind.value);eEle.value=ev;ci._editPos();eEle.focus();eEle.select();ci.state.edit.shown=true;ci.state.edit.item=r.i;ci.state.edit.part=r.p;ci.state.edit.path=iObj.bind.value;}
if(iTObj){if(iTObj.event)iTObj.event.call(ci,'click',r.i,r.v,iObj,r.ele,e);}
if(dShown&&!ci._d.next&&ci._d.current){if(iObj.autoHideDisclosure){var hide=false;if(iObj.autoHideDisclosure=='always')hide=true;else if(iObj.autoHideDisclosure!='never'&&ci._d.current.s.autoHide)hide=true;if(hide)ci.hideDisclosure();}}}}
if(this._oid==id)this._isdc=true;else{this._isdc=false;this._oid=id;}}}}}
delete r;},_dblClick:function(e,ci){if(!this._isdc)return false;var r=ci._aEle(e);if(r){if($ga(r.ele,'a5-disabled')!='true'&&!r.ele.disabled){var iObj=ci.items[r.i];if(iObj){var iTObj=A5.controlBar.items[iObj.type];if(iTObj){if(iTObj.event)iTObj.event.call(ci,'dblclick',r.i,r.v,iObj,r.ele,e);}}}}
delete r;},_rClick:function(e,ci){var r=ci._aEle(e);if(r){if($ga(r.ele,'a5-disabled')!='true'&&!r.ele.disabled){var iObj=ci.items[r.i];if(iObj){var iTObj=A5.controlBar.items[iObj.type];if(iTObj){if(iTObj.event)iTObj.event.call(ci,'contextclick',r.i,r.v,iObj,r.ele,e);}}}}
delete r;},_downHold:function(e,ci){var r=ci._aEle(e);if(r){if($ga(r.ele,'a5-disabled')!='true'&&!r.ele.disabled){var iObj=ci.items[r.i];if(iObj){var iTObj=A5.controlBar.items[iObj.type];if(iTObj){if(iTObj.event)iTObj.event.call(ci,'downhold',r.i,r.v,iObj,r.ele,e);}}}}
delete r;},_swipe:function(e,ci){if(ci._startItem){var r=ci._startItem;var ele=$(r.id);if($ga(ele,'a5-disabled')!='true'&&!ele.disabled){var iObj=ci.items[r.i];if(iObj){var iTObj=A5.controlBar.items[iObj.type];if(iTObj){if(iTObj.event)iTObj.event.call(ci,'swipe',r.i,r.v,iObj,ele,e);}}}}},_aEle:function(e){var cEle=$(this.contId);var coor=$e.getCoors(e);var ele=document.elementFromPoint(coor.clientX,coor.clientY);if(!ele)return false;var result=false;var i='';while(ele!=cEle&&ele!=document.body){if(!result){i=$ga(ele,'a5-item');if(i!=null&&i!=''){var v=this._getValue(ele);result={i:i,v:v,ele:ele,p:'disclosure'};}}
ele=ele.parentNode;}
if(ele==cEle&&result)result.p='main';return result;},_getValue:function(ele){var v=$ga(ele,'a5-value');if(v==''||v==null)v=ele.id;return v;},_bindEvents:function(ele){var egName='CONTROLBAR.'+this.contId;$e.add(ele,A5.d.evnts.dblClick,this._dblClick,this,false,egName);$e.add(ele,'contextmenu',this._rClick,this,false,egName);$e.add(ele,A5.d.evnts.down,this._down,this,false,egName);$e.add(ele,A5.d.evnts.up,this._up,this,false,egName);$e.add(ele,'abstractdownhold',this._downHold,this,false,egName);$e.add(ele,'abstractswipe',this._swipe,this,false,egName);},_compileTemplate:function(cl,edge){if(typeof cl._t=='undefined')cl._t={};if(typeof cl._t[edge]=='undefined'){var tLines=[];var l=null;var ti=null;var cn='';var temp=[];var name='';var tHTML='';var tPH='';for(var i=0;i<cl.lines.length;i++){l=cl.lines[i];$u.o.assign(l,A5.controlBar._.lDefs,true);cn='A5ControlBarLine';if(l.type!='custom'){if(l.middle.items.length==0){if(l.before.items.length==0)cn='A5ControlBarLine A5ControlBarLineAfter';else cn='A5ControlBarLine A5ControlBarLineBefore';}}else cn='A5ControlBarLineCust';temp=['<div class="'+cn+' '+l.className+'" style="'+l.style+'">'];if(l.type=='custom'){tHTML=l.html;for(var item in this.items){tPH='['+item+']';if(tHTML.indexOf(tPH)!=-1)tHTML=tHTML.split(tPH).join(this.items[item].template);}
temp.push(tHTML);}else{if(l.before.items.length!=0){temp.push('<div class="A5ControlBarLineContentBefore">&#65279;');for(var k=0;k<l.before.items.length;k++){name=l.before.items[k];if(name=='-'){temp.push('<div class="A5ControlBarItem A5CONTROLBARSEPCLASSNAME">&#65279;</div>');}else if(name[0]=='<'){name=name.substring(1,name.length-1).trim();temp.push('<div class="A5ControlBarItem" style="A5CONTROLBARITEMSIZE: '+name+';"></div>');}else if(this.items[name])temp.push(this.items[name].template);}
temp.push('</div>');}
if(l.middle.items.length!=0){temp.push('<div class="A5ControlBarLineContentMiddle">&#65279;');for(var k=0;k<l.middle.items.length;k++){name=l.middle.items[k];if(name=='-'){temp.push('<div class="A5ControlBarItem A5CONTROLBARSEPCLASSNAME">&#65279;</div>');}else if(name[0]=='<'){name=name.substring(1,name.length-1).trim();temp.push('<div class="A5ControlBarItem" style="A5CONTROLBARITEMSIZE: '+name+';"></div>');}else if(this.items[name])temp.push(this.items[name].template);}
temp.push('</div>');}
if(l.after.items.length!=0){temp.push('<div class="A5ControlBarLineContentAfter">&#65279;');for(var k=0;k<l.after.items.length;k++){name=l.after.items[k];if(name=='-'){temp.push('<div class="A5ControlBarItem A5CONTROLBARSEPCLASSNAME">&#65279;</div>');}else if(name[0]=='<'){name=name.substring(1,name.length-1).trim();temp.push('<div class="A5ControlBarItem" style="A5CONTROLBARITEMSIZE: '+name+';"></div>');}else if(this.items[name])temp.push(this.items[name].template);}
temp.push('</div>');}}
temp.push('</div>');if(l.bind.show!=''){temp.unshift('{*if '+l.bind.show+'}')
temp.push('{*endif}');}
tLines.push(temp.join(''));}
if(edge=='left'){tLines.unshift('<div class="A5ControlBarVert">');tLines.push('</div>');}else if(edge=='bottom'){tLines.reverse();tLines.unshift('<div class="A5ControlBarHorz">');tLines.push('</div>');}else if(edge=='right'){tLines.reverse();tLines.unshift('<div class="A5ControlBarVert">');tLines.push('</div>');}else{tLines.unshift('<div class="A5ControlBarHorz">');tLines.push('</div>');}
tLines=tLines.join('');if(edge=='left'||edge=='right'){tLines=tLines.replace(/A5CONTROLBARITEMSIZE/gi,'height');tLines=tLines.replace(/A5CONTROLBARSEPCLASSNAME/gi,this.separator.verticalClassName);}else{tLines=tLines.replace(/A5CONTROLBARITEMSIZE/gi,'width');tLines=tLines.replace(/A5CONTROLBARSEPCLASSNAME/gi,this.separator.horizontalClassName);}
cl._t[edge]=A5.u.template.parse(tLines);}}});};
A5._windowDefaults={title:{tools:{defaults:{'close':{action:'close',name:'close',image:'a5images/windowbuttonclose.png'}}}}}
A5.serverSideDateFormat = 'MM/dd/yyyy';
A5.u.drag.useDragScrolling = 'auto';
if(typeof DLG1_DlgObj == 'object') DLG1_DlgObj._destroy();
var DLG1_DlgObj = new A5.DialogComponentHelper('DLG1',{
	ajaxURL: 'https://www.mariloginsatm.com/APP_DESCARGA.a5wcmp?__virtualPage=__a5RunDialog.a5w&__dialogFilename=APP_DESCARGA&__alias=DLG1&__unsaved=no',
	_embeddedMode: false,
	_livePreviewInBuilder: false,
	componentGUID: 'ed9a90e3-2902-48e3-aa6a-b7a17cf9a41e',
	columnInfo: {},
	originalValues: [{
}],
	defaultValues: {
},
	datePickerMonthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
	datePickerDayNames: ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
	datePickerTodayButton: 'Today',
	datePickerCloseButton: '',
	datePickerFirstDayOfWeek: 1,
	resetFormMessage: 'Are you sure you want to reset the form?',
	resetFormTitle: 'Warning',
	resetFormIcon: 'svgIcon=#alpha-icon-questionCircle:icon',
	dirtyFormMessage: 'You must first save your changes or cancel changes by clicking the Reset button.',
	dirtyFormTitle: 'Notice',
	dirtyFormIcon: 'svgIcon=#alpha-icon-infoCircle:icon',
	deleteRecordDialogTitle: 'Delete Record',
	deleteRecordDialogMessage: 'Are you sure you want to delete this record?',	
	ssDateFormat: 'MM/dd/yyyy',
	styleName: 'Alpha-Aqua',
	_fieldHelpers_DIALOG2: [],
	parentComponentAlias: '',
	submitIfHasClientSideErrors: true, 
	rowErrors: {
				showMessageBox: false,
				messageBoxTitle: 'Error',
				style: 'color: red; width: 6in; height: 2in;'
		},
	fieldErrors: {
		type: 'block', 
		className: 'errorText',
		inputClassName: 'editError',
		edit: { 
			container: { className: 'editError'}
		},
		icon: 'svgIcon=#alpha-icon-exclamationCircle:icon',
		global: {
			contId: 'DLG1.GLOBALERRORS',
			hoverClassName: 'errorTextHighlight',
			hoverInputClassName: 'errorInputHighlight'
		}
	},
		onOrientationChange: function(e) {
var pObj = DLG1_DlgObj.getPanelObject();
if(pObj) pObj.resize();
		},
		_onWindowResize: function(e) {
var arr = DLG1_DlgObj._listControls;
if(arr) {
 var obj;
 for(var i = 0; i < arr.length; i++) {
  obj = DLG1_DlgObj.getControl(arr[i]);
  if(obj) obj.resize()
 }
}
		},
_onInitializeBegin: function(e) { /*systemOnInitializeBegin*/ ;
   },
	});
A5.__componentObj = DLG1_DlgObj;
A5.map._fn='https://maps.googleapis.com/maps/api/js?key=AIzaSyCwJ3t4qfu7_Z0VQdc0XrFDse_3mWRQADk&libraries=geometry&callback=A5.map.init';;
	if(typeof A5.map.defaults == 'undefined') A5.map.defaults = {};
	if(typeof A5.map.defaults.staticMap == 'undefined') A5.map.defaults.staticMap = {};
A5.map.defaults.staticMap.key='AIzaSyCwJ3t4qfu7_Z0VQdc0XrFDse_3mWRQADk';
DLG1_DlgObj._tabObjects = [];
A5.loadJavascript(';\n;');
DLG1_DlgObj.lookups = {
};
DLG1_DlgObj._onOrientationChange =  function(e) {   };
DLG1_DlgObj.setStateInfo({
	"__dialogGuid": "ed9a90e3-2902-48e3-aa6a-b7a17cf9a41e",
	"argumentsBoundToCotrols": "",
	"__sgr": "",
	"__dtfmt": "MM/dd/yyyy",
	"__tfmt": ""
});
DLG1_DlgObj._cascadingControls = [];
DLG1_DlgObj._cascadingControlsChildren = [];
A5.msgBox.theme = 'Alpha-Aqua';
A5.msgBox.buttonWidth = '1in';
DLG1_DlgObj._defaultWindowTitleDirection = 'ltr';
DLG1_DlgObj._controlContainers = {}
DLG1_DlgObj._buttons = {};
DLG1_DlgObj._buttons['BUTTON_2'] = new A5.Button({
	layout: 'text',
	style: 'box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box;',
	html: 'descarga2',
	onClick: function() { 
},
	theme: 'Alpha-Aqua:base'
});
DLG1_DlgObj._buttons['BUTTON_2'].bind('DLG1.V.R1.BUTTON_2');
DLG1_DlgObj._buttons['BUTTON_2'].bind('DLG1.V.R1.BUTTON_2');
DLG1_DlgObj.setVariables({});
DLG1_DlgObj._dataBoundControls = [];
DLG1_DlgObj._primaryTableAlias = '';
DLG1_DlgObj._hasPanels = false;
DLG1_DlgObj._hasOnSynchronizeEvent = false;
A5.__dtfmt = 'MM/dd/yyyy';A5.__tfmt = '';
A5.__flagWorkingPreview = false;
A5.__flagIIS = false;
A5.__flagSimulateIIS = true;
DLG1_DlgObj._functions.calcOrientation = function() {
	if(typeof DLG1_DlgObj == 'undefined') return '';
	var orientation = DLG1_DlgObj.getOrientation();
	if( orientation == 'landscape') {
			//landscape
			if(DLG1_DlgObj._orientation != 'landscape') {
				DLG1_DlgObj._fireWatches(1);
				DLG1_DlgObj._orientation = 'landscape';
				DLG1_DlgObj._executeEvent('onOrientationChange',{orientation: 'landscape'});
			}
	} else {
		//portrait
		if(DLG1_DlgObj._orientation != 'portrait') {
				DLG1_DlgObj._fireWatches(1);
				DLG1_DlgObj._orientation = 'portrait';
				DLG1_DlgObj._executeEvent('onOrientationChange',{orientation: 'portrait'});
			}
	}
}
	A5.flags.cordovaLoaded = true;
	try {
		document.addEventListener('deviceready', function() {
			DLG1_DlgObj._cordovaReady = true;
			//alert('fire on cordova ready 2')
			DLG1_DlgObj._executeEvent('onCordovaReady',{});
			DLG1_DlgObj._executeEvent('onPhoneGapReady',{});
			navigator.geolocation.getAccuratePosition = function(geolocationSuccess, geolocationError, options) {
 var _lastCheckedPosition = null;
 var _locationEventCount = 0;
 options = options || {};
 options.context = this;
    function _checkLocation(pos) {
        _lastCheckedPosition = pos;
        _locationEventCount++;
        if ((pos.coords.accuracy <= options.desiredAccuracy) && (_locationEventCount > options.ignoreResultCount)) {
            clearTimeout(_timerID);
            navigator.geolocation.clearWatch(_watchID);
            _foundPosition(pos);
        }
    }
    function _stopLocationCheck() {
      var error = {};
      error.code = 0;
      error.message = 'Timeout: No results';
        navigator.geolocation.clearWatch(_watchID);
        _lastCheckedPosition ? _foundPosition(_lastCheckedPosition) : geolocationError.call(options.context,error);
    }
    function _onError(error) {
        clearTimeout(_timerID);
        navigator.geolocation.clearWatch(_watchID);
        geolocationError.call(options.context,error);
    }
    function _foundPosition(pos) {
        geolocationSuccess.call(options.context,pos);
    }
    if (!options.maxWait) {
     options.maxWait = 10000;
    }
    if (!options.desiredAccuracy) {
       options.desiredAccuracy = 20;
    }
    if (!options.timeout) {
        options.timeout = options.maxWait;
  }
  if (!options.ignoreResultCount) {
    options.ignoreResultCount = 1;
  }
    options.maximumAge = 0;
    options.enableHighAccuracy = true;
    var _watchID = navigator.geolocation.watchPosition(_checkLocation, _onError, options);
    var _timerID = setTimeout(_stopLocationCheck, options.maxWait);
}
		} , false);
		DLG1_DlgObj._onPhoneGapReady = function() { 
			DLG1_DlgObj._executePhoneGapDelayed(); 
			if(DLG1_DlgObj) {
				var obj = DLG1_DlgObj.getPanelObject();
				if(obj) obj.resize();
				if(DLG1_DlgObj.instantUpdateOnRenderComplete) DLG1_DlgObj.instantUpdateOnRenderComplete()
			};
		}
	}
	catch(err) {}
DLG1_DlgObj._waitGif = 'css/A5System/Images/wait.gif';
var EXIF=(function(){var debug=false;var ExifTags={0x9000:"ExifVersion",0xA000:"FlashpixVersion",0xA001:"ColorSpace",0xA002:"PixelXDimension",0xA003:"PixelYDimension",0x9101:"ComponentsConfiguration",0x9102:"CompressedBitsPerPixel",0x927C:"MakerNote",0x9286:"UserComment",0xA004:"RelatedSoundFile",0x9003:"DateTimeOriginal",0x9004:"DateTimeDigitized",0x9290:"SubsecTime",0x9291:"SubsecTimeOriginal",0x9292:"SubsecTimeDigitized",0x829A:"ExposureTime",0x829D:"FNumber",0x8822:"ExposureProgram",0x8824:"SpectralSensitivity",0x8827:"ISOSpeedRatings",0x8828:"OECF",0x9201:"ShutterSpeedValue",0x9202:"ApertureValue",0x9203:"BrightnessValue",0x9204:"ExposureBias",0x9205:"MaxApertureValue",0x9206:"SubjectDistance",0x9207:"MeteringMode",0x9208:"LightSource",0x9209:"Flash",0x9214:"SubjectArea",0x920A:"FocalLength",0xA20B:"FlashEnergy",0xA20C:"SpatialFrequencyResponse",0xA20E:"FocalPlaneXResolution",0xA20F:"FocalPlaneYResolution",0xA210:"FocalPlaneResolutionUnit",0xA214:"SubjectLocation",0xA215:"ExposureIndex",0xA217:"SensingMethod",0xA300:"FileSource",0xA301:"SceneType",0xA302:"CFAPattern",0xA401:"CustomRendered",0xA402:"ExposureMode",0xA403:"WhiteBalance",0xA404:"DigitalZoomRation",0xA405:"FocalLengthIn35mmFilm",0xA406:"SceneCaptureType",0xA407:"GainControl",0xA408:"Contrast",0xA409:"Saturation",0xA40A:"Sharpness",0xA40B:"DeviceSettingDescription",0xA40C:"SubjectDistanceRange",0xA005:"InteroperabilityIFDPointer",0xA420:"ImageUniqueID"};var TiffTags={0x0100:"ImageWidth",0x0101:"ImageHeight",0x8769:"ExifIFDPointer",0x8825:"GPSInfoIFDPointer",0xA005:"InteroperabilityIFDPointer",0x0102:"BitsPerSample",0x0103:"Compression",0x0106:"PhotometricInterpretation",0x0112:"Orientation",0x0115:"SamplesPerPixel",0x011C:"PlanarConfiguration",0x0212:"YCbCrSubSampling",0x0213:"YCbCrPositioning",0x011A:"XResolution",0x011B:"YResolution",0x0128:"ResolutionUnit",0x0111:"StripOffsets",0x0116:"RowsPerStrip",0x0117:"StripByteCounts",0x0201:"JPEGInterchangeFormat",0x0202:"JPEGInterchangeFormatLength",0x012D:"TransferFunction",0x013E:"WhitePoint",0x013F:"PrimaryChromaticities",0x0211:"YCbCrCoefficients",0x0214:"ReferenceBlackWhite",0x0132:"DateTime",0x010E:"ImageDescription",0x010F:"Make",0x0110:"Model",0x0131:"Software",0x013B:"Artist",0x8298:"Copyright"};var GPSTags={0x0000:"GPSVersionID",0x0001:"GPSLatitudeRef",0x0002:"GPSLatitude",0x0003:"GPSLongitudeRef",0x0004:"GPSLongitude",0x0005:"GPSAltitudeRef",0x0006:"GPSAltitude",0x0007:"GPSTimeStamp",0x0008:"GPSSatellites",0x0009:"GPSStatus",0x000A:"GPSMeasureMode",0x000B:"GPSDOP",0x000C:"GPSSpeedRef",0x000D:"GPSSpeed",0x000E:"GPSTrackRef",0x000F:"GPSTrack",0x0010:"GPSImgDirectionRef",0x0011:"GPSImgDirection",0x0012:"GPSMapDatum",0x0013:"GPSDestLatitudeRef",0x0014:"GPSDestLatitude",0x0015:"GPSDestLongitudeRef",0x0016:"GPSDestLongitude",0x0017:"GPSDestBearingRef",0x0018:"GPSDestBearing",0x0019:"GPSDestDistanceRef",0x001A:"GPSDestDistance",0x001B:"GPSProcessingMethod",0x001C:"GPSAreaInformation",0x001D:"GPSDateStamp",0x001E:"GPSDifferential"};var StringValues={ExposureProgram:{0:"Not defined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0x0000:"Flash did not fire",0x0001:"Flash fired",0x0005:"Strobe return light not detected",0x0007:"Strobe return light detected",0x0009:"Flash fired, compulsory flash mode",0x000D:"Flash fired, compulsory flash mode, return light not detected",0x000F:"Flash fired, compulsory flash mode, return light detected",0x0010:"Flash did not fire, compulsory flash mode",0x0018:"Flash did not fire, auto mode",0x0019:"Flash fired, auto mode",0x001D:"Flash fired, auto mode, return light not detected",0x001F:"Flash fired, auto mode, return light detected",0x0020:"No flash function",0x0041:"Flash fired, red-eye reduction mode",0x0045:"Flash fired, red-eye reduction mode, return light not detected",0x0047:"Flash fired, red-eye reduction mode, return light detected",0x0049:"Flash fired, compulsory flash mode, red-eye reduction mode",0x004D:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",0x004F:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",0x0059:"Flash fired, auto mode, red-eye reduction mode",0x005D:"Flash fired, auto mode, return light not detected, red-eye reduction mode",0x005F:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Not defined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},Components:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"}};function imageHasData(img){return!!(img.exifdata)}function findEXIFinJPEG(file){if(file.getByteAt(0)!=0xFF||file.getByteAt(1)!=0xD8){return false}var offset=2,length=file.getLength(),marker;while(offset<length){if(file.getByteAt(offset)!=0xFF){if(debug)console.log("Not a valid marker at offset "+offset+", found: "+file.getByteAt(offset));return false}marker=file.getByteAt(offset+1);if(marker==22400){if(debug)console.log("Found 0xFFE1 marker");return readEXIFData(file,offset+4,file.getShortAt(offset+2,true)-2)}else if(marker==225){if(debug)console.log("Found 0xFFE1 marker");return readEXIFData(file,offset+4,file.getShortAt(offset+2,true)-2)}else{offset+=2+file.getShortAt(offset+2,true)}}}function readTags(file,tiffStart,dirStart,strings,bigEnd){var entries=file.getShortAt(dirStart,bigEnd),tags={},entryOffset,tag,i;for(i=0;i<entries;i++){entryOffset=dirStart+i*12+2;tag=strings[file.getShortAt(entryOffset,bigEnd)];if(!tag&&debug)console.log("Unknown tag: "+file.getShortAt(entryOffset,bigEnd));tags[tag]=readTagValue(file,entryOffset,tiffStart,dirStart,bigEnd)}return tags}function readTagValue(file,entryOffset,tiffStart,dirStart,bigEnd){var type=file.getShortAt(entryOffset+2,bigEnd),numValues=file.getLongAt(entryOffset+4,bigEnd),valueOffset=file.getLongAt(entryOffset+8,bigEnd)+tiffStart,offset,vals,val,n,numerator,denominator;switch(type){case 1:case 7:if(numValues==1){return file.getByteAt(entryOffset+8,bigEnd)}else{offset=numValues>4?valueOffset:(entryOffset+8);vals=[];for(n=0;n<numValues;n++){vals[n]=file.getByteAt(offset+n)}return vals}case 2:offset=numValues>4?valueOffset:(entryOffset+8);return file.getStringAt(offset,numValues-1);case 3:if(numValues==1){return file.getShortAt(entryOffset+8,bigEnd)}else{offset=numValues>2?valueOffset:(entryOffset+8);vals=[];for(n=0;n<numValues;n++){vals[n]=file.getShortAt(offset+2*n,bigEnd)}return vals}case 4:if(numValues==1){return file.getLongAt(entryOffset+8,bigEnd)}else{vals=[];for(var n=0;n<numValues;n++){vals[n]=file.getLongAt(valueOffset+4*n,bigEnd)}return vals}case 5:if(numValues==1){numerator=file.getLongAt(valueOffset,bigEnd);denominator=file.getLongAt(valueOffset+4,bigEnd);val=new Number(numerator/denominator);val.numerator=numerator;val.denominator=denominator;return val}else{vals=[];for(n=0;n<numValues;n++){numerator=file.getLongAt(valueOffset+8*n,bigEnd);denominator=file.getLongAt(valueOffset+4+8*n,bigEnd);vals[n]=new Number(numerator/denominator);vals[n].numerator=numerator;vals[n].denominator=denominator}return vals}case 9:if(numValues==1){return file.getSLongAt(entryOffset+8,bigEnd)}else{vals=[];for(n=0;n<numValues;n++){vals[n]=file.getSLongAt(valueOffset+4*n,bigEnd)}return vals}case 10:if(numValues==1){return file.getSLongAt(valueOffset,bigEnd)/file.getSLongAt(valueOffset+4,bigEnd)}else{vals=[];for(n=0;n<numValues;n++){vals[n]=file.getSLongAt(valueOffset+8*n,bigEnd)/file.getSLongAt(valueOffset+4+8*n,bigEnd)}return vals}}}function readEXIFData(file,start){if(file.getStringAt(start,4)!="Exif"){if(debug)console.log("Not valid EXIF data! "+file.getStringAt(start,4));return false}var bigEnd,tags,tag,exifData,gpsData,tiffOffset=start+6;if(file.getShortAt(tiffOffset)==0x4949){bigEnd=false}else if(file.getShortAt(tiffOffset)==0x4D4D){bigEnd=true}else{if(debug)console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)");return false}if(file.getShortAt(tiffOffset+2,bigEnd)!=0x002A){if(debug)console.log("Not valid TIFF data! (no 0x002A)");return false}if(file.getLongAt(tiffOffset+4,bigEnd)!=0x00000008){if(debug)console.log("Not valid TIFF data! (First offset not 8)",file.getShortAt(tiffOffset+4,bigEnd));return false}tags=readTags(file,tiffOffset,tiffOffset+8,TiffTags,bigEnd);if(tags.ExifIFDPointer){exifData=readTags(file,tiffOffset,tiffOffset+tags.ExifIFDPointer,ExifTags,bigEnd);for(tag in exifData){switch(tag){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":exifData[tag]=StringValues[tag][exifData[tag]];break;case"ExifVersion":case"FlashpixVersion":exifData[tag]=String.fromCharCode(exifData[tag][0],exifData[tag][1],exifData[tag][2],exifData[tag][3]);break;case"ComponentsConfiguration":exifData[tag]=StringValues.Components[exifData[tag][0]]+StringValues.Components[exifData[tag][1]]+StringValues.Components[exifData[tag][2]]+StringValues.Components[exifData[tag][3]];break}tags[tag]=exifData[tag]}}if(tags.GPSInfoIFDPointer){gpsData=readTags(file,tiffOffset,tiffOffset+tags.GPSInfoIFDPointer,GPSTags,bigEnd);for(tag in gpsData){switch(tag){case"GPSVersionID":gpsData[tag]=gpsData[tag][0]+"."+gpsData[tag][1]+"."+gpsData[tag][2]+"."+gpsData[tag][3];break}tags[tag]=gpsData[tag]}}return tags}function getData(img,callback){if(!img.complete)return false;if(!imageHasData(img)){getImageData(img,callback)}else{if(callback){callback.call(img)}}return true}function getTag(img,tag){if(!imageHasData(img))return;return img.exifdata[tag]}function getAllTags(img){if(!imageHasData(img))return{};var a,data=img.exifdata,tags={};for(a in data){if(data.hasOwnProperty(a)){tags[a]=data[a]}}return tags}function pretty(img){if(!imageHasData(img))return"";var a,data=img.exifdata,strPretty="";for(a in data){if(data.hasOwnProperty(a)){if(typeof data[a]=="object"){if(data[a]instanceof Number){strPretty+=a+" : "+data[a]+" ["+data[a].numerator+"/"+data[a].denominator+"]\r\n"}else{strPretty+=a+" : ["+data[a].length+" values]\r\n"}}else{strPretty+=a+" : "+data[a]+"\r\n"}}}return strPretty}function readFromBinaryFile(file){return findEXIFinJPEG(file)}function BinaryFile(strData,iDataOffset,iDataLength){var data=strData;var dataOffset=iDataOffset||0;var dataLength=0;this.getRawData=function(){return data};if(typeof strData=="string"){dataLength=iDataLength||data.length;this.getByteAt=function(iOffset){return data.charCodeAt(iOffset+dataOffset)&0xFF};this.getBytesAt=function(iOffset,iLength){var aBytes=[];for(var i=0;i<iLength;i++){aBytes[i]=data.charCodeAt((iOffset+i)+dataOffset)&0xFF}return aBytes}}else if(typeof strData=="unknown"){dataLength=iDataLength||IEBinary_getLength(data);this.getByteAt=function(iOffset){return IEBinary_getByteAt(data,iOffset+dataOffset)};this.getBytesAt=function(iOffset,iLength){return new VBArray(IEBinary_getBytesAt(data,iOffset+dataOffset,iLength)).toArray()}}this.getLength=function(){return dataLength};this.getSByteAt=function(iOffset){var iByte=this.getByteAt(iOffset);if(iByte>127)return iByte-256;else return iByte};this.getShortAt=function(iOffset,bBigEndian){var iShort=bBigEndian?(this.getByteAt(iOffset)<<8)+this.getByteAt(iOffset+1):(this.getByteAt(iOffset+1)<<8)+this.getByteAt(iOffset);if(iShort<0)iShort+=65536;return iShort};this.getSShortAt=function(iOffset,bBigEndian){var iUShort=this.getShortAt(iOffset,bBigEndian);if(iUShort>32767)return iUShort-65536;else return iUShort};this.getLongAt=function(iOffset,bBigEndian){var iByte1=this.getByteAt(iOffset),iByte2=this.getByteAt(iOffset+1),iByte3=this.getByteAt(iOffset+2),iByte4=this.getByteAt(iOffset+3);var iLong=bBigEndian?(((((iByte1<<8)+iByte2)<<8)+iByte3)<<8)+iByte4:(((((iByte4<<8)+iByte3)<<8)+iByte2)<<8)+iByte1;if(iLong<0)iLong+=4294967296;return iLong};this.getSLongAt=function(iOffset,bBigEndian){var iULong=this.getLongAt(iOffset,bBigEndian);if(iULong>2147483647)return iULong-4294967296;else return iULong};this.getStringAt=function(iOffset,iLength){var aStr=[];var aBytes=this.getBytesAt(iOffset,iLength);for(var j=0;j<iLength;j++){aStr[j]=String.fromCharCode(aBytes[j])}return aStr.join("")};this.getCharAt=function(iOffset){return String.fromCharCode(this.getByteAt(iOffset))};this.toBase64=function(){return window.btoa(data)};this.fromBase64=function(strBase64){data=window.atob(strBase64)}}return{findEXIFinJPEG:findEXIFinJPEG,pretty:pretty,getTag:getTag,getAllTags:getAllTags,getData:getData,Tags:ExifTags,TiffTags:TiffTags,GPSTags:GPSTags,StringValues:StringValues,BinaryFile:BinaryFile}})();
(function(){function detectSubsampling(img){var iw=img.naturalWidth,ih=img.naturalHeight;if(iw*ih>1024*1024){var canvas=document.createElement('canvas');canvas.width=canvas.height=1;var ctx=canvas.getContext('2d');ctx.drawImage(img,-iw+1,0);return ctx.getImageData(0,0,1,1).data[3]===0}else{return false}}function detectVerticalSquash(img,iw,ih){var canvas=document.createElement('canvas');canvas.width=1;canvas.height=ih;var ctx=canvas.getContext('2d');ctx.drawImage(img,0,0);var data=ctx.getImageData(0,0,1,ih).data;var sy=0;var ey=ih;var py=ih;while(py>sy){var alpha=data[(py-1)*4+3];if(alpha===0){ey=py}else{sy=py}py=(ey+sy)>>1}var ratio=(py/ih);return(ratio===0)?1:ratio}function renderImageToDataURL(img,options){var canvas=document.createElement('canvas');renderImageToCanvas(img,canvas,options);return canvas.toDataURL("image/jpeg",options.quality||0.8)}function renderImageToCanvas(img,canvas,options){var iw=img.naturalWidth,ih=img.naturalHeight;var width=options.width,height=options.height;var ctx=canvas.getContext('2d');ctx.save();transformCoordinate(canvas,width,height,options.orientation);var subsampled=detectSubsampling(img);if(subsampled){iw/=2;ih/=2}var d=1024;var tmpCanvas=document.createElement('canvas');tmpCanvas.width=tmpCanvas.height=d;var tmpCtx=tmpCanvas.getContext('2d');var vertSquashRatio=detectVerticalSquash(img,iw,ih);var dw=Math.ceil(d*width/iw);var dh=Math.ceil(d*height/ih/vertSquashRatio);var sy=0;var dy=0;while(sy<ih){var sx=0;var dx=0;while(sx<iw){tmpCtx.clearRect(0,0,d,d);tmpCtx.drawImage(img,-sx,-sy);ctx.drawImage(tmpCanvas,0,0,d,d,dx,dy,dw,dh);sx+=d;dx+=dw}sy+=d;dy+=dh}ctx.restore();tmpCanvas=tmpCtx=null}function transformCoordinate(canvas,width,height,orientation){switch(orientation){case 5:case 6:case 7:case 8:canvas.width=height;canvas.height=width;break;default:canvas.width=width;canvas.height=height}var ctx=canvas.getContext('2d');switch(orientation){case 2:ctx.translate(width,0);ctx.scale(-1,1);break;case 3:ctx.translate(width,height);ctx.rotate(Math.PI);break;case 4:ctx.translate(0,height);ctx.scale(1,-1);break;case 5:ctx.rotate(0.5*Math.PI);ctx.scale(1,-1);break;case 6:ctx.rotate(0.5*Math.PI);ctx.translate(0,-height);break;case 7:ctx.rotate(0.5*Math.PI);ctx.translate(width,-height);ctx.scale(-1,1);break;case 8:ctx.rotate(-0.5*Math.PI);ctx.translate(-width,0);break;default:break}}function MegaPixImage(srcImage){if(srcImage instanceof Blob){var img=new Image();var URL=window.URL&&window.URL.createObjectURL?window.URL:window.webkitURL&&window.webkitURL.createObjectURL?window.webkitURL:null;if(!URL){throw Error("No createObjectURL function found to create blob url");}img.src=URL.createObjectURL(srcImage);srcImage=img}if(!srcImage.naturalWidth&&!srcImage.naturalHeight){var _this=this;srcImage.onload=function(){var listeners=_this.imageLoadListeners;if(listeners){_this.imageLoadListeners=null;for(var i=0,len=listeners.length;i<len;i++){listeners[i]()}}};this.imageLoadListeners=[]}this.srcImage=srcImage}MegaPixImage.prototype.render=function(target,options){if(this.imageLoadListeners){var _this=this;this.imageLoadListeners.push(function(){_this.render(target,options)});return}options=options||{};var imgWidth=this.srcImage.naturalWidth,imgHeight=this.srcImage.naturalHeight,width=options.width,height=options.height,maxWidth=options.maxWidth,maxHeight=options.maxHeight;if(width&&!height){height=(imgHeight*width/imgWidth)<<0}else if(height&&!width){width=(imgWidth*height/imgHeight)<<0}else{width=imgWidth;height=imgHeight}if(maxWidth&&width>maxWidth){width=maxWidth;height=(imgHeight*width/imgWidth)<<0}if(maxHeight&&height>maxHeight){height=maxHeight;width=(imgWidth*height/imgHeight)<<0}var opt={width:width,height:height};for(var k in options)opt[k]=options[k];var tagName=target.tagName.toLowerCase();if(tagName==='img'){target.src=renderImageToDataURL(this.srcImage,opt)}else if(tagName==='canvas'){renderImageToCanvas(this.srcImage,target,opt)}if(typeof this.onrender==='function'){this.onrender(target)}};if(typeof define==='function'&&define.amd){define([],function(){return MegaPixImage})}else{this.MegaPixImage=MegaPixImage}})();
/*
Copyright (c) 2001, 2019 Alpha Software Corporation
All Rights Reserved.
This Javascript library is licensed exclusively for use with Alpha Anywhere, Alpha Five,
Alpha Five Application Server, Alpha Anywhere Application Server,
Alpha Five Run Engine, and Alpha Anywhere Run Engine. It is specifically
not licensed for use on a server that does not have installed on it a
licensed copy of the Alpha Five Application Server or the Alpha Anywhere Application Server.
*/
	DLG1_DlgObj.imageCaptureUsingCamera = function(options) {
		options.specialMode = 'callback';
		try{
			if(options.pictureSourceVal == '0') options.phonegapMoveFileToPermanentStorage = false;
		}catch(e) { };
		this.detailViewImageCapture(options);
	}
	DLG1_DlgObj.detailViewImageCapture = function(options) {
		if(typeof options.specialMode == 'undefined') options.specialMode = 'detailview';
		var flagPhoneGapLoaded = false;
		var flagUseCordova = false;
		if (typeof window['cordova'] != 'undefined') {
			flagPhoneGapLoaded = true;
			if(options.captureMethod == 'phonegappreferred' || options.captureMethod == 'phonegap') {
				flagUseCordova = true;
			}
		}
		if(options.captureMethod == 'phonegap' && flagPhoneGapLoaded == false) {
			alert('PhoneGap not available'); return false;
		}
		if(!flagUseCordova) {
			this.detailViewImageCaptureHTML5(options);
		} else {
			this.detailViewImageCapturePhoneGap(options);
		}
	}
	DLG1_DlgObj.detailViewImageCaptureHTML5 = function(options) {
		if(typeof options.specialMode == 'undefined') options.specialMode = 'detailview';
		if(options.onBeforeCaptureJavascript) {
			var result = options.onBeforeCaptureJavascript.call();
			if(typeof result != 'undefined') {
				if(!result) return false;
			}
		}
		if(A5.flags.isAndroid == false) {
			if(A5.flags.isIPhone || A5.flags.isIPad){
				if (typeof A5.flags.iOSVersion != 'undefined') {
					var majorNum = A5.flags.iOSVersion.split('.')[0];
					if(parseInt(majorNum) < 6) {
						alert('HTML5 camera access not supported on this version of iOS');
						return false;
					}
				}
			}
		}
		if(A5.u.css.supportsTransition == false) {
			alert('Browser does not support HTML5 camera access');
			return false;
		}
		if(typeof options.resizePolicyHTML5 == 'undefined') options.resizePolicyHTML5 = 'Always';
		options.resizePolicyHTML5 = options.resizePolicyHTML5.toLowerCase();
		if(options.resizePolicyHTML5 != 'always') {
			var maxSize = 99999999999;
			if(typeof options.maxImageSizeHTML5 != 'undefined') maxSize = Number(options.maxImageSizeHTML5);
		}
		//if(typeof options.resizeImageHTML5 == 'undefined') options.resizeImageHTML5 = true;
		var ops = {};
		ops.dialogObj = this;
		if(options.specialMode == 'callback' ) {
			options.controlName = '';
		}
	 	ops.targetImage = options.controlName;
	 	ops.targetImage = ops.targetImage.toUpperCase();
	 	ops.html5 = {};
	 	ops.html5.resizeFlag = options.resizeImageHTML5;
	 	ops.html5.compressionFactor = options.imageCompressionHTML5;
	 	ops.html5.maxWidth = options.maxImageWidth;
	 	ops.html5.maxHeight = options.maxImageHeight;
	 	ops.fieldPrefix = this.dialogId + '.V.R1';
	 	ops.imageFieldName = (ops.fieldPrefix + '.' + ops.targetImage).toUpperCase();
	 	ops.hiddenFileName =  (ops.fieldPrefix + '.' + ops.targetImage + '_HIDDENA5FN').toUpperCase();
 		ops.handleFileSelect = function(evt) {
			// creates a FileList object
			var files = evt.target.files;
			// Even if multiple files are presented, only the first file will be uploaded.
			if (!files.length){
				// alerts should be ok here when fired by a timer
				setTimeout(function(){
					//alert('No files selected.');
				},50);
				return false;
			} else {
				// we're processing only 1 file at this point
				var f = files[0];
				ops.updateImage(f);
			}
		}
		$e.removeGroup('__detailViewImageCapture')
		$e.add($(this.dialogId + '._GETPHOTO'),'change',ops.handleFileSelect,'','','__detailViewImageCapture');
		ops.updateImage = function(_thisFile) {
			var _sourceFileName = _thisFile.name;
			var _thisImageName = ops.imageFieldName;
			var _thisImage = $(_thisImageName);
			var reader = new FileReader();
			reader.onload = function(e) {
				var flagResize = false;
				if(options.resizePolicyHTML5 == 'always') {
					flagResize = true;
				} else {
					if(e.target.result.length > maxSize) {
						flagResize = true;
					}
				}
				if(!flagResize) {
					//not resizing
					if(options.specialMode == 'detailview') {
						_thisImage.src = e.target.result;
						var eleH = $(ops.hiddenFileName);
						if(eleH) eleH.src = _thisImage.src;
						$sa(eleH,'a5isdirty','true');
						$sa(eleH,'a5imageSourceName',_sourceFileName);
						ops.dialogObj.refreshClientSideComputations();
						if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : e.target.result});
					} else {
						if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : e.target.result});
					}
				} else {
					//resizing
					if(options.displaySpinnerWhileResizingImage) {
						_thisImage.src = options.spinnerURI.replace(/\|/gi,'/');
					}
					var _orientation = ops.parseExifOrientation(e.target.result);
					ops.renderImgToCanvas(_thisFile,_orientation,_sourceFileName);
				}
			}
			reader.onerror = function(e) {
				setTimeout(function(){
				alert('Error reading file.');
				},0);
			}
			reader.readAsDataURL(_thisFile);
		}
		ops.parseExifOrientation = function(dataUrl) {
			try {
				// Some of the more current browsers set the default image_orientation property to from-image
				// It was previously always set to none. This check insures that the image is not rotated twice.
				/* -----------------
				* // 8-13-2020: modified to return null for all iOS browsers
				* if (parseFloat(A5.flags.iOSVersion)>= 13.2) {
				* // if running on an iOS device then check version, do not rotate for versions 13.2 snd greater
				* return null;
				* ------------------
				*/
				if (A5.flags.browserSpecs.name == "Safari") {
					return null;
				} else if ((A5.flags.browserSpecs.name == "Chrome") && (parseFloat(A5.flags.browserSpecs.version) >= 83)) {
					//if running on Chrome version 81 or greater, do not rotate
					return null;
				} else if ((A5.flags.browserSpecs.name == "Firefox") && (parseFloat(A5.flags.browserSpecs.version) >= 75)) {
					//if running on Firefox version 75 or greater, do not rotate
					return null;
				}
				// This universal check should work with all modern browsers (Opera, etc.) that set the default value of imageOrientation to "from-image"
				var _obj = getComputedStyle(document.body);
				if (obj.imageOrientation == "from-image") {
					return null;
				}
				var _byteString = atob(dataUrl.split(',')[1]);
				var _binaryFile = new EXIF.BinaryFile(_byteString, 0, _byteString.length);
				var _exif = EXIF.findEXIFinJPEG(_binaryFile);
				// Store EXIF orientation (if available) in data property.
				if (_exif && _exif['Orientation']) {
					return _exif['Orientation'];
				} else {
					return null;
				}
			} catch (e) {
				// Error parsing EXIF data.
				console.log('Error loading EXIF data', e);
				return null;
			}
		}
		ops.renderImgToCanvas = function(_file,_orientation,_sourceFileName) {
			// using megapix-image.js here which handles(?) sub-sampling issue with large images and Canvas on iOS6 Safari
			var mpImg = new MegaPixImage(_file);
			mpImg.onrender = function(){
				// this timeout required to ensure _thisCanvas render complete
				setTimeout(function(){
					var dataURL = _thisCanvas.toDataURL('image/jpeg', ops.html5.compressionFactor);
					//alert('html5 size after resizing image:' + dataURL.length);
					if(options.specialMode == 'detailview') {
						var ele = $(ops.imageFieldName);
						//put the scaled image in the element
						ele.src = dataURL;
						var eleH = $(ops.hiddenFileName);
						if(eleH) eleH.src = dataURL;
						$sa(eleH,'a5isdirty','true');
						$sa(eleH,'a5imageSourceName',_sourceFileName);
						ops.dialogObj.refreshClientSideComputations();
						if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : dataURL, sourceFileName: _sourceFileName});
					} else {
						if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : dataURL, sourceFileName: _sourceFileName});
					}
				},0);
			}
			var _thisCanvas = document.createElement('canvas');
			var ctx = _thisCanvas.getContext('2d');
			// adjust based on extracted _orientation
			if (_orientation) {
				mpImg.render(_thisCanvas,{maxWidth: ops.html5.maxWidth, maxHeight:ops.html5.maxHeight, orientation:_orientation});
			} else {
				mpImg.render(_thisCanvas,{maxWidth: ops.html5.maxWidth, maxHeight:ops.html5.maxHeight});
			}
		}
		//click the hidden image control
		var ele = $(this.dialogId + '._GETPHOTO');
		if (ele) {
			ele.value = '';
			ele.click();
		}
	}
	/////\\\\\
	DLG1_DlgObj.detailViewVideoCapturePhoneGap = function(opsIn) {
		//ops.fieldPrefix = this.dialogId + '.V.R1';
		//ops.videoFieldName = (ops.fieldPrefix + '.' + ops.controlName).toUpperCase();
		opsIn.dialogObj = this;
		var options = opsIn.options;
		var onSuccess = function(mediaFiles) { var e = {filename: mediaFiles[0].fullPath};
			var e_filename = e.filename;
			if(e_filename.indexOf('file:') != 0) {
				e_filename = e_filename.replace('/private','file:\/\/');
			}
			if(e_filename.indexOf('file:') != 0 && e_filename.indexOf('.wav') > 0) {
				e_filename = 'file:\/\/' + e_filename;
				//alert(e_filename);
			}
			opsIn.dialogObj.setValue(opsIn.controlName,e_filename);
			//var ele = $(ops.imageFieldName);
			//if(ele) ele.src = thisImageURL;
			//var eleH = $(ops.hiddenFileName);
			//if(eleH) eleH.src = thisImageURL;
			//$sa(eleH,'a5isdirty','true');
			opsIn.dialogObj.refreshClientSideComputations();
		};
		var onFailed = function() {
		};
		var flagAudio = false;
		if(typeof opsIn.audio != 'undefined') flagAudio = opsIn.audio;
		if(!flagAudio) {
			navigator.device.capture.captureVideo(onSuccess,onFailed,options);
		} else {
			//alert('audio');
			//debugger;
			var options = { limit: 1, duration: 10 };
			//navigator.device.capture.captureAudio(captureSuccess, captureError, options);
			//navigator.device.capture.captureAudio(onSuccess,onFailed,options);
			var _media = {
				recorder: null,
				recFile: 'myaudio/myrecording3.amr'  //if device.platform is 'Android' then use .amr, otherwise .wav
			}
			function captureStatus(e) {
				console.log('status....' + JSON.stringify(e));
			}
			var onSuccessAudio = function() {
				console.log('try to play it now');
				setTimeout(function() { _media.recorder.play(); },1000);
				//var e_filename = _media.recFile;
				//opsIn.dialogObj.setValue(opsIn.controlName,e_filename);
				//opsIn.dialogObj.refreshClientSideComputations();
			};
			_media.recorder = new Media(_media.recFile,onSuccessAudio,onFailed,captureStatus);
			console.log('about to record');
			_media.recorder.startRecord();
			console.log('start');
			setTimeout(function() { console.log('stop'); _media.recorder.stopRecord();  },5000);
			//_media.recorder.play();
		}
	}
	DLG1_DlgObj.detailViewImageCapturePhoneGap =  function(options) {
		var flagCustomOnError = false;
		if(typeof DLG1_DlgObj.customWindowErrorEvents != 'undefined') flagCustomOnError = DLG1_DlgObj.customWindowErrorEvents;
		//if(!flagCustomOnError) window.onerror = function(err) { alert('Unhandled Javascript Error - phoneGapImageCapture:  ' + JSON.stringify(err));}
		if(options.onBeforeCaptureJavascript) {
			var result = options.onBeforeCaptureJavascript.call();
			if(typeof result != 'undefined') {
				if(!result) return false;
			}
		}
		if (typeof window['cordova'] == 'undefined') {
			alert('PhoneGap not loaded');
			return false;
		}
		if(typeof options.imageSelectionCanceledMessage == 'undefined') options.imageSelectionCanceledMessage = 'Image Selection Canceled';
		if(typeof options.imageSelectionCanceledButton == 'undefined') options.imageSelectionCanceledButton = 'Done';
		if(typeof options.cameraCanceledMessage == 'undefined') options.cameraCanceledMessage = 'Camera Action Canceled';
		if(typeof options.cameraCanceledButton == 'undefined') options.cameraCanceledButton = 'Done';
		var maxSize = -1;
		if(typeof options.maxImageSizePhoneGap != 'undefined') maxSize = Number(options.maxImageSizePhoneGap);
		if(maxSize == -1) maxSize = 9999999999;
		if(typeof options.specialMode == 'undefined') options.specialMode = 'detailview';
		var ops = {};
		ops.dialogObj = this;
		if(options.specialMode == 'callback') {
			options.controlName = '';
		}
		ops.targetImage = options.controlName.toUpperCase();
		ops.cordova = {};
		ops.cordova.pictureSourceVal = options.pictureSourceVal;
		ops.cordova.imageQuality = options.imageQualityPhonegap;
		ops.cordova.allowEdit = options.allowPictureEditing
		ops.cordova.targetWidth = options.maxImageWidth;
		ops.cordova.targetHeight = options.maxImageHeight;
		ops.cordova.saveToPhotoAlbum = options.saveToPhotoAlbum
		ops.cordova.iPadEleId = '';
		ops.fieldPrefix = this.dialogId + '.V.R1';
		ops.imageFieldName = (ops.fieldPrefix + '.' + ops.targetImage).toUpperCase();
		ops.hiddenFileName = (ops.fieldPrefix + '.' + ops.targetImage + '_HIDDENA5FN').toUpperCase();
		ops.onCameraSuccess = function(imageURI) {
			if(typeof options.captureDataMode == 'undefined') options.captureDataMode = 'base64';
			try {
			    var iOps = JSON.parse(imageURI);
			    var filename = iOps.filename;
			    var metadata = iOps.json_metadata;
			    var iMD = JSON.parse(metadata);
			    if(typeof iMD.GPS != 'undefined') {
			    	//running on iOS
			    	var gpsObj = {};
			    	gpsObj.latitude = iMD.GPS.Latitude;
			    	gpsObj.longitude = iMD.GPS.Longitude;
			    	if(iMD.GPS.LongitudeRef == 'W') gpsObj.longitude = Number(gpsObj.longitude) * -1;
			    	if(iMD.GPS.LatitudeRef == 'S') gpsObj.latitude = Number(gpsObj.latitude) * -1;
			    	gpsObj.altitude = iMD.GPS.Altitude;
			    	gpsObj.dateTime = iMD.GPS.DateStamp + ' ' + iMD.GPS.TimeStamp;
			    	gpsObj.ExifJSON = metadata;
			    } else {
			    	//android
			    	var latRaw = iMD.gpsLatitude;   //":"42/1,28/1,50093/1000",
			    	var latRef = iMD.gpsLatitudeRef;  //":"N",
			    	var lngRaw = iMD.gpsLongitude; //":"71/1,12/1,16183/1000",
			    	var lngRef = iMD.gpsLongitudeRef; //":"W",
			    	var altRaw = iMD.gpsAltitude;
			    	var altRef = iMD.gpsAltitudeRef;
			    	ops.fixGPS = function(raw,ref) {
			    		//alert( ' raw: ' + raw + ' ref: ' + ref);
			    		if(raw == null) return null;
						var lat_d, lat_m, lat_s, lat;
						lat_d = eval(raw.split(',')[0]);
						lat_m = eval(raw.split(',')[1]) * ( 1/60);
						lat_s = eval(raw.split(',')[2]) * ( 1/60);
						lat = Number(lat_d) + Number(lat_m) + Number(lat_s);
						if(ref != null) {
							if(ref.toUpperCase() == 'S') lat = Number(lat) * -1;
							if(ref.toUpperCase() == 'W') lat = Number(lat) * -1;
						}
						return lat;
			    	}
			    	var lat = ops.fixGPS(latRaw,latRef);
			    	var lng = ops.fixGPS(lngRaw,lngRef);
			    	var alt = ops.fixGPS(altRaw,altRef);
			    	var gpsObj = {};
					gpsObj.latitude = lat;
					gpsObj.longitude = lng;
					gpsObj.altitude = alt;
					gpsObj.dateTime = iMD.datetime;
					gpsObj.ExifJSON = metadata;
			    }
			    options.EXIF = gpsObj;
			    ops._moveFile(filename);
				//do not call onCaptureJavascript() here ... it gets called by ops._move() ....window.resolveLocalFileSystemURL(imageURI,ops.fsOK,ops.fsError);
			    //if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : imageURI});
			} catch(err) {
				//if you get here then you were not using the AA camera plugin, so EXIF info is not available
				ops._moveFile(imageURI);
				//do not call onCaptureJavascript() here ... it gets called by ops._move() ....window.resolveLocalFileSystemURL(imageURI,ops.fsOK,ops.fsError);
				//if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : imageURI});
			}
		}
		ops._moveFile = function(filename) {
			var flagMove = false;
			if(typeof options.phonegapMoveFileToPermanentStorage != 'undefined') flagMove = options.phonegapMoveFileToPermanentStorage;
			if(flagMove) {
				if(typeof device == 'undefined') {
					alert('ERROR The PhoneGap \'device\' plugin is not installed.');
				}
				var _dir = DLG1_DlgObj.phoneGapGetLocalDirURL(options.phonegapFileSystemType);
				var _onFolderEnsured = function() {
					var pos = filename.indexOf('?'); // look for ?, not part of a filename when moving files
					if (pos>=0) filename = filename.substring(0,pos); // remove query parts if present
					var objFn = A5.parseFilename(filename);
					var extension = objFn.name.split('.');
					extension = extension[extension.length-1];
					var targetName = A5.UUID() + '.' + extension;
					var subfolder = '';
					if(options.phonegapPermanentStorageFolder != '') {
						subfolder = options.phonegapPermanentStorageFolder + '/';
					}
					var _moveOK = function() {
						var fn = _dir + subfolder + targetName;
						window.resolveLocalFileSystemURL(fn,ops.fsOK,ops.fsError);
					}
					var _moveFail = function(e) {
						alert('Move error: '+e.code);
					}
					DLG1_DlgObj.phoneGapMoveFileURL(filename,_dir, subfolder + targetName,_moveOK,_moveFail)
				}
				var _onError = function() {
					alert('could not create folder');
				}
				if(options.phonegapPermanentStorageFolder != '') {
					DLG1_DlgObj.phoneGapEnsureDirPathURL(_dir, options.phonegapPermanentStorageFolder, _onFolderEnsured, _onError)
				} else {
					//storing in the root of the requested filesystem --
					_onFolderEnsured();
				}
			} else {
				//do not need to move the file
				window.resolveLocalFileSystemURL(filename,ops.fsOK,ops.fsError);
			}
		}
		ops.onImageSelectFail = function(msg) {
			if(typeof options.onCaptureCancel == 'function') {
				options.onCaptureCancel.call();
			} else {
				navigator.notification.alert(msg,null,options.imageSelectionCanceledMessage,options.imageSelectionCanceledButton);
			}
		}
		ops.onCameraCaptureFail = function(msg) {
			if(typeof options.onCaptureCancel == 'function') {
					options.onCaptureCancel.call(this,msg);
			} else {
				navigator.notification.alert(msg,null,options.cameraCanceledMessage,options.cameraCanceledButton);
			}
		}
		ops.fsOK = function(fileEntry) {
			// HTML5 File system available as fileEntry
			// Using standard HTML5 file handling here
			// get fileEntry URL for upload
			var thisImageURL = fileEntry.toURL();
			if(options.captureDataMode == 'filename') {
				if(options.specialMode == 'detailview') {
					//better be - only mode we are supporting for 'filename'
					var ele = $(ops.imageFieldName);
					if(ele) ele.src = DLG1_DlgObj.addCustomSchemeForAlphaWkWebView(thisImageURL);
					var eleH = $(ops.hiddenFileName);
					if(eleH) eleH.src = thisImageURL;
					$sa(eleH,'a5isdirty','true');
					var exifData = '';
					if(typeof options.EXIF != 'undefined') exifData = JSON.stringify(options.EXIF);
					$sa(eleH,'a5EXIF',exifData);
					ops.dialogObj.refreshClientSideComputations();
					if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : thisImageURL, options: options.EXIF});
				}
			} else {
				fileEntry.file(function(file){
					var reader = new FileReader();
					reader.onloadend = function(e) {
						// this is Base64 encoded
						if(options.specialMode == 'detailview') {
							var ele = $(ops.imageFieldName);
							if(ele) ele.src = e.target.result;
							var eleH = $(ops.hiddenFileName);
							if(eleH) eleH.src = e.target.result;
							$sa(eleH,'a5isdirty','true');
							ops.dialogObj.refreshClientSideComputations();
							if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : e.target.result, fileSystemURL: fileEntry.nativeURL, options: options});
						} else {
							if(options.onCaptureJavascript) options.onCaptureJavascript.call(this, {data : e.target.result, fileSystemURL: fileEntry.nativeURL, options: options});  //pass in options so that the user defined callback js can reference options (which has the exif data in it)
						}
					};
					reader.onerror = function(e) {
						navigator.notification.alert('File reader error');
					};
					reader.readAsDataURL(file);
				},function(error) {
					navigator.notification.alert('Image file read error');
				});
			}
		}
		ops.fsError = function() {
			navigator.notification.alert('Local File system unavailable.');
		}
		// Calculate positioning for iPad popup menu if applicable
		var cordovaPopoverOptions = null;
			if (ops.cordova.iPadEleId.length > 0) {
			var ele = $(ops.cordova.iPadEleId);
			if (ele) {
				var rect = ele.getBoundingClientRect();
				var x = rect.left;
				var y = rect.top;
				var w = rect.right - rect.left;
				var h = rect.bottom - rect.top;
				cordovaPopoverOptions = new CameraPopoverOptions(x,y,w,h,15);
			}
		}
		// These options define all of the objects functionality
		var cordovaOptions = {
			quality: Number(ops.cordova.imageQuality),
			allowEdit: ops.cordova.allowEdit,
			sourceType: Number(ops.cordova.pictureSourceVal),
			correctOrientation: true,
			destinationType: 1,
			targetWidth: Number(ops.cordova.targetWidth),
			targetHeight: Number(ops.cordova.targetHeight),
			saveToPhotoAlbum: ops.cordova.saveToPhotoAlbum,
			popoverOptions: cordovaPopoverOptions,
			encodingType: Camera.EncodingType.JPEG
		}
		/*
		var options = {
				destinationType: Camera.DestinationType.FILE_URI,
				sourceType: Camera.PictureSourceType.PHOTOLIBRARY,
				mediaType: Camera.MediaType.VIDEO
				//getting error: destination file type unavailable
			};
		*/
		if (cordovaOptions.sourceType != 1) {
			cordovaOptions.saveToPhotoAlbum = false;
			navigator.camera.getPicture(ops.onCameraSuccess, ops.onImageSelectFail,cordovaOptions);
		} else {
			navigator.camera.getPicture(ops.onCameraSuccess, ops.onCameraCaptureFail,cordovaOptions);
		}
	}
DLG1_DlgObj.stripCustomSchemeForAlphaWkWebView = function(fileURL) {
	try{
		if(fileURL.toLowerCase().indexOf('alpha-local') == -1) return fileURL;
		return fileURL.split('url=')[1]
	}catch(e) { return fileURL}
}
//////////
DLG1_DlgObj.addCustomSchemeForAlphaWkWebView = function(fileURL) {
	if (typeof fileURL != 'string') return fileURL; //only process strings
	// catch null fileURL
	if (!fileURL) {
		return fileURL;
	}
	function getExt(path){
    	var ext = (path.match(/(?:.+..+[^\/]+$)/ig) != null) ? path.split('.').slice(-1): ['dir'];
    	return ext[0].toLowerCase();
	}
	// set default
	var modifiedFileURL = fileURL;
	const alphaJpgScheme   = 'alpha-local://jpg?url=';
	const alphaSvgScheme   = 'alpha-local://svg?url=';
	const alphaPngScheme   = 'alpha-local://png?url=';
	const alphaAudioScheme = 'alpha-local://audio?url=';
	const alphaVideoScheme = 'alpha-local://video?url=';
	const alphaHtmlScheme  = 'alpha-local://html?url=';
	const alphaViewScheme  = 'alpha-local://view?url=';
	const alphaViewDirScheme = 'alpha-local://viewdir?url=';
	// Is Alpha's WkWebView plugin installed?
	if (typeof WkWebView == 'object' && WkWebView != null) {
		if (typeof WkWebView.isAlphaWkWebView == 'function') {
			if (fileURL.startsWith('file://')) {
				var ext = getExt(fileURL);
				switch(ext) {
					case "jpg":
						modifiedFileURL = alphaJpgScheme + fileURL;
						break;
					case "png":
						modifiedFileURL = alphaPngScheme + fileURL;
						break;
					case "svg":
						modifiedFileURL = alphaSvgScheme + fileURL;
						break;
					case "m4a":
					case "mp3":
					case "wav":
						modifiedFileURL = alphaAudioScheme + fileURL;
						break;
					case "mp4":
					case "m4v":
					case "mov":
						modifiedFileURL = alphaVideoScheme + fileURL;
						break;
					case "html":
						modifiedFileURL = alphaHtmlScheme + fileURL;
						break;
					// for viewing files in iOS QuickLook viewer
					case "pdf":
					case "doc":
					case "xlsx":
					case "rtf":
					case "csv":
					case "ppt":
					case "txt":
					case "zip":
						modifiedFileURL = alphaViewScheme + fileURL;
						break;
					// for viewing a directory of files in iOS QuickLook viewer
					case "dir":
						modifiedFileURL = alphaViewDirScheme + fileURL;
						break;
				}
			}
		}
	}
	return modifiedFileURL;
}
//////////////
	DLG1_DlgObj._abortS3Upload = function(__guid,number,rowId) {
		var arrS3 = DLG1_DlgObj.__CORSUploads[__guid]['arrS3'];
		var options = DLG1_DlgObj.__CORSUploads[__guid]['options'];
		var _dlgObj = DLG1_DlgObj;
		var _xhr = arrS3[number].xhr;
		_xhr.abort();
		arrS3[number].aborted = true;
		if(typeof rowId != 'undefined') {
			var ele = $(rowId);
			if(ele) ele.style.display = 'none';
		}
		//uploadCompleteFunction
		var ops = DLG1_DlgObj.__CORSUploads[__guid]['ops'];
		//fire the onComplete events
		var flagAllCompleted = false;
		var c = 0;
		for(var i = 0; i < arrS3.length; i++) {
			if(arrS3[i].completed == true || arrS3[i].aborted == true) c = c+1;
		}
		if(c == arrS3.length) flagAllCompleted = true;
		var f = arrS3[number];
		var e = {
			name: f.name,
			type: f.type,
			size: f.size,
			aborted: f.aborted,
			number: number,
			fileArray: arrS3,
			targetName: arrS3[number].targetName
		}
		options.onCompleteFile(e);
		if(flagAllCompleted) {
			options.onCompleteAllFiles(e);
			if(options.displayProgress) {
				var eleP = $(_dlgObj.dialogId + '.V.R1.' + options.progressDisplayPlaceholder);
				if(eleP) eleP.style.display = 'none';
			}
			delete DLG1_DlgObj.__CORSUploads[__guid];
		}
		//end onComplete events
	}
	/////////////////////////////////////////////////////////////////////////
	DLG1_DlgObj.fileUploadAmazonS3 = function(options) {
		var eleB = '';
		var _dlgObj = this;
		var _part = options.part;
		delete ops;
		var ops = {};
		if(typeof options.onBeforeFileSelect == 'function') {
			var result = options.onBeforeFileSelect();
			if(typeof result != 'undefined') {
				if(!result) return false;
			}
		}
		ops.formatNum = function(num) {
			var suffix = 'Kb';
		 	if(num >= 1000000) {
		 		num = num/1000000;
		 		suffix = 'Mb';
			} else if(num >= 1000) {
			 	num = num / 1000;
			 	suffix = 'Kb';
			} else {
			   suffix = 'bytes'
			  }
			num = Math.round(num * 100) / 100;
			num = Number(num);
			return (num).toLocaleString() + suffix;
		}
		ops.setProgress = function(percent,message,objS3) {
			//fire system onProgress events
			if(options.displayProgress) {
				var i = objS3.number;
				//id_i = _dlgObj.dialogId + '.V.R1.' + options.progressDisplayPlaceholder + '.' + (i+1);
				id_i = options.resolvedProgressPlaceholder + '.' + (i+1);
				var ep = $(id_i);
				if(ep) {
					if(options.progressStyle == 'text') ep.innerHTML = percent + '%';
					else ep.style.width = percent + '%';
				}
			}
			var e = {
				percent: percent,
				message: message,
				name: objS3.name,
				targetName: objS3.targetName,
				number: objS3.number,
				size: objS3.size,
				type: objS3.type
			}
			if(typeof objS3.userProgressFunction == 'function') objS3.userProgressFunction(e);;
		}
		ops.createCORSRequest = function(method, url) {
  			var xhr = new XMLHttpRequest();
  			//alert(method)
  			//alert(url);
  			//DLG1_DlgObj.debugInfoToFile(url,'c:/bugs/url.txt')
			 // "withCredentials" only exists on XHR2 objects
  			if ("withCredentials" in xhr) {
  				try {
    				xhr.open(method, url, true);
    			} catch(err) {
    				alert('XHR error - could not open XHR object. This action is not supported in Working Preview if you are using Internet Explorer. Try using Chrome Working Preview.');
    				return false;
    			}
			} else if (typeof XDomainRequest != "undefined") {
			    // XDomainRequest only exists in IE
    			xhr = new XDomainRequest();
			    xhr.open(method, url);
  			} else {
			  	// CORS not supported by this browser
    			xhr = null;
			  }
		  return xhr;
		}
		ops.uploadToS3 = function(file, url, objS3) {
			var targetServer = objS3.targetServer;
			if(typeof targetServer == 'undefined') targetServer = 'S3';
			if(targetServer.toUpperCase() == 'S3') {
				var xhr = ops.createCORSRequest('PUT', url);
			} else {
				//alpha server
				var additionalInfo = '';
				if(typeof options.additionalInfo == 'function') {
					additionalInfo = options.additionalInfo.call();
				}
				additionalInfo = A5.ajax.buildURLParam('__additionalInfo',additionalInfo);
				var AAURI = encodeURI(DLG1_DlgObj.ajaxURL + '&' + additionalInfo + '&__Ajax=true&__FormAction=GenericAjaxCallback&_XbasicFunction=system:multifileupload&_xbasic=' + options.xbasicFunction);
				var xhr = new XMLHttpRequest();
				xhr.open('POST',AAURI,true);
			}
			if (!xhr) {
				//ops.setProgress(0, 'CORS not supported',objS3);
				if(typeof objS3.onError == 'function') objS3.onError({errorText: 'CORS not supported', errorCode: -1, fileObject: objS3});
			  	else alert('CORS not supported');
			} else {
			//capture the xhr object so you can call cancel
			objS3.arrS3[objS3.number].xhr = xhr;
			xhr.onreadystatechange = function() {
				//this.readyState == 4 & this.status == 200 -- success
				//this.readyState == 4 && this.status = 408 - timeout
				//anything else is an error
			}
			xhr.onload = function() {
			  if(xhr.status == 200) {
				ops.setProgress(100, 'Upload completed.',objS3);
				//file number is available in objS3.number
				objS3.uploadCompleteFunction.call(objS3);
				var txt = this.responseText;
				if(txt.indexOf('Eval:') == 0) {
					txt = txt.substring(5);
					eval(txt);
				}
			  } else {
				//ops.setProgress(0, 'Upload error: ' + xhr.status);
				var responseText = '';
				if(typeof xhr.responseText != 'undefined') responseText = xhr.responseText;
				if(typeof objS3.onError == 'function') objS3.onError({errorText: 'Upload error', errorCode: xhr.status, fileObject: objS3, errorText: responseText});
			  	else alert('XHR error. Reported error:' + responseText);
			  }
			};
			xhr.onerror = function() {
			  //ops.setProgress(0, 'XHR error.');
			  if(typeof objS3.onError == 'function') objS3.onError({errorText: 'XHR Error', errorCode: xhr.status, fileObject: objS3});
			  else alert('XHR error');
			};
			xhr.upload.onprogress = function(e) {
			  if (e.lengthComputable) {
				var percentLoaded = Math.round((e.loaded / e.total) * 100);
				ops.setProgress(percentLoaded, percentLoaded == 100 ? 'Finalizing.' : 'Uploading.',objS3);
			  }
			};
			if(!options.target) options.target = 'S3';
			if(options.target.toUpperCase() == 'S3') {
				xhr.setRequestHeader('Content-Type', file.type);
				if(!objS3.authenticatedRead) {
					xhr.setRequestHeader('x-amz-acl', 'public-read');
				} else {
					xhr.setRequestHeader('x-amz-acl', 'authenticated-read');
				}
			} else {
				//don't bother with headers. they will get set automatically becuase we will be .send()ing a FormData() object
			}
			if(targetServer.toUpperCase() == 'S3') {
				if (typeof window['cordova'] != 'undefined') {
					//var ft = new FileTransfer();
					//alert('phone gap is loaded. typeof ft: ' + typeof(ft));
					//var msg1 = JSON.stringify(options,'','\t');
					//var msg2 = JSON.stringify(ops,'','\t');
					//var msg3 = JSON.stringify(objS3,'','\t');
					//DLG1_DlgObj.debugInfoToFile(msg1,'c:/bugs/msg1.json');
					//DLG1_DlgObj.debugInfoToFile(msg2,'c:/bugs/msg2.json');
					//DLG1_DlgObj.debugInfoToFile(msg3,'c:/bugs/msg3.json');
				}
				//alert(typeof options);
				//alert(1);
				//
				//var options = new FileUploadOptions();
				xhr.send(file);
			} else {
				//uploading to alpha server - by using a FormData() object, the content-type headers get set correctly
				var formData = new FormData();
				formData.append('file',file)
				xhr.send(formData);
			}
			}
		}
		ops.handleFileSelect = function(evt) {
			delete arrS3;
			var arrS3 = [];
			ops.__guid = Number(new Date());
			var __guid = ops.__guid;
			DLG1_DlgObj.__CORSUploads = {};
			DLG1_DlgObj.__CORSUploads[__guid] = {};
			DLG1_DlgObj.__CORSUploads[__guid]['arrS3'] = arrS3;
			DLG1_DlgObj.__CORSUploads[__guid]['ops'] = ops;
			DLG1_DlgObj.__CORSUploads[__guid]['options'] = options;
			var files = evt.target.files;
			var f = '';
			var data = '';
			var targetName = '';
			var newTargetName = '';
			arrS3.length = 0;
			for(var i = 0; i < files.length; i++) {
				f = files[i];
				if(typeof f.name == 'undefined') {
					var localFileName = 'blobfile.jpg';
					if(typeof options.localFileName != 'undefined') localFileName = options.localFileName;
					f.name = localFileName;
				}
				delete obji;
				var obji = {
					number: i,
					name: f.name,
					size: f.size,
					type: f.type,
					file: f,
					completed: false,
					aborted: false
				}
				arrS3.push(obji)
			}
			var __guid = ops.__guid;
			//validate file selection -------------------------------------
			var totalSize = 0;
			if(typeof options.maxFileSize == 'undefined') options.maxFileSize = -1;
			var maxSize = options.maxFileSize;
			if(maxSize == -1) maxSize = 999999999999999;
			if(typeof options.maxFileSizeTotal == 'undefined') options.maxFileSizeTotal = -1;
			var maxSizeTotal = options.maxFileSizeTotal;
			if(maxSizeTotal == -1) maxSizeTotal = 999999999999999;
			if(typeof options.allowedFileTypes == 'undefined') options.allowedFileTypes = '';
			var fileMsg = options.customization.maxFileSize;
			var fileTotalMsg = options.customization.totalFileSize;
			var typeMsg = options.customization.fileType;
			var flagHasValidationFunction = false;
			if(typeof options.onValidationError == 'function') flagHasValidationFunction = true;
			for(var i = 0; i < arrS3.length; i++) {
				totalSize = totalSize + arrS3[i].size;
				//check size
				if(arrS3[i].size > maxSize) {
					if(flagHasValidationFunction) {
						options.onValidationError({violationType: 'size', name: arrS3[i].name, size: arrS3[i].size, type: arrS3[i].type});
					} else {
						if(typeof fileMsg != 'undefined' && fileMsg != '') {
							var msg = fileMsg;
							var e = arrS3[i];
							msg = msg.replace('[filename]',e.name);
							msg = msg.replace('[filesize]','' + e.size);
							msg = msg.replace('[maxfilesize]','' + maxSize);
							alert(msg);
						} else {
							alert('File exceeds maximum allowed size of ' + maxSize);
						}
					}
					return false;
				}
				//check type
				if(options.allowedFileTypes != '') {
					var arrT = options.allowedFileTypes.split(',');
					for(var i2 = 0; i2 < arrT.length; i2++ ) {
						arrT[i2] =   $u.s.aTrim(arrT[i2].toLowerCase());
						arrT[i2] = arrT[i2].replace('.','');
					}
					var ext = arrS3[i].name.split('.');
					ext = ext[ext.length -1];
					ext = ext.toLowerCase();
					var ia = $u.a.find(arrT,ext);
					if(ia == -1) {
						if(flagHasValidationFunction) {
							options.onValidationError({violationType: 'type', name: arrS3[i].name, size: arrS3[i].size, type: arrS3[i].type});
						} else {
							if(typeof typeMsg != 'undefined' && typeMsg != '') {
								var msg = typeMsg;
								var e = arrS3[i];
								msg = msg.replace('[filename]',e.name);
								msg = msg.replace('[filetype]',ext);
								alert(msg);
							} else {
								alert('Invalid file type ' + ext);
							}
						}
						return false;
					}
				}
			}
			//check total size
			if(totalSize > maxSizeTotal) {
				//Selected files ([filecount] files, total size [totalfilesize]) exceed the maximum allowed total file size of [maxtotalfilesize].
				if(flagHasValidationFunction) {
					options.onValidationError({violationType: 'totalSize', totalSize: totalSize, maxSizeTotal: maxSizeTotal});
				} else {
					if(typeof fileTotalMsg != 'undefined' && fileTotalMsg != '') {
						var msg = fileTotalMsg;
						var e = arrS3[i];
						msg = msg.replace('[filecount]',arrS3.length);
						msg = msg.replace('[totalfilesize]','' + totalSize);
						msg = msg.replace('[maxtotalfilesize]','' + maxSizeTotal);
						alert(msg);
					} else {
						alert('Files exceeds maximum allowed size of ' + maxSizeTotal);
					}
				}
				return false;
			}
			//end validate file selection
			if(typeof options.onAfterFilesSelect == 'function') {
				var result = options.onAfterFilesSelect(arrS3);
				if(typeof result != 'undefined') {
					if(!result) return false;
				}
			}
			ops.__handleFileSelectLow(files,__guid,arrS3)
		}
		ops._generatePlaceholderId = function() {
			var txt = options.progressDisplayPlaceholder;
			var flagDV = false;
			if(typeof options.__dv != 'undefined') flagDV = options.__dv;
			var num = txt.split('.')[1];
			if(!flagDV) {
				var eleId = _dlgObj.gridId + '.V.R'+options.rowNumber+'._UNBOUND_STATICTEXT_' + num;
			} else {
				var eleId = _dlgObj.gridId + '.D.V.R'+options.rowNumber+'._UNBOUND_STATICTEXT_' + num;
			}
			return eleId;
		}
		ops.__handleFileSelectLow = function(files,__guid,arrS3) {
			if(options.displayProgress) {
				if(options.progressDisplayPlaceholder.indexOf('ELEMENT:') == 0) {
					options.resolvedProgressPlaceholder = options.progressDisplayPlaceholder.split(':')[1];
				} else {
					options.resolvedProgressPlaceholder = _dlgObj.dialogId + '.V.R1.' + options.progressDisplayPlaceholder
				}
				var eleP = $(options.resolvedProgressPlaceholder);
				if(options.part == 'grid') {
					options.resolvedProgressPlaceholder = this._generatePlaceholderId()
					var eleP = $(options.resolvedProgressPlaceholder);
				}
				if(eleP) {
					eleP.style.display = '';
					var arrH = [];
					var id_i = '';
					var id_row_i = '';
					var html = '';
					var html_i = '';
					var spanTxt = '';
					var flagAllowCancel = options.allowCancel;
					if(typeof flagAllowCancel == 'undefined') flagAllowCancel = false;
					if(typeof options.progressStyle == 'undefined') options.progressStyle = 'bar';
					if(options.progressStyle == 'text') {
						for(var i = 0; i < arrS3.length; i++) {
							//id_i = _dlgObj.dialogId + '.V.R1.' + options.progressDisplayPlaceholder + '.' + (i+1);
							id_i = options.resolvedProgressPlaceholder + '.' + (i+1);
							id_row_i = id_i + '.ROW';
							html_i = '';
							html_i += '<tr id="'+id_row_i+'">';
							if(flagAllowCancel) {
								html_i += '<td><div style="cursor:pointer;padding: 5px;" title="Cancel upload" onclick="DLG1_DlgObj._abortS3Upload(\''+__guid+'\','+i+',\''+id_row_i+'\');">X</div></td>';
							}
							html_i +='<td><div>' + arrS3[i].name + ' (' + ops.formatNum(arrS3[i].size) + ') <span id='+id_i+'></span> </div></td>';
							html_i +='</tr>'
							arrH.push(html_i)
						}
						html = arrH.join('');
						html = '<table>' + html + '</table>'
					} else if (options.progressStyle == 'bar') {
						var flagShowFilename = options.showFileNameInProgressBar;
						if(typeof flagShowFilename == 'undefined') flagShowFilename = true;
						var flagMobile = false;
						if(typeof options._flagMobile != 'undefined') flagMobile = options._flagMobile;
						html_i = '';
						if(typeof options.progressBarColor == 'undefined') options.progressBarColor = '#9fa1e8';
						if(typeof options.progressBarWidth == 'undefined') options.progressBarWidth = '1.5in';
						var color = options.progressBarColor
						var width = options.progressBarWidth;
						for(var i = 0; i < arrS3.length; i++) {
							//id_i = _dlgObj.dialogId + '.V.R1.' + options.progressDisplayPlaceholder + '.' + (i+1);
							id_i = options.resolvedProgressPlaceholder + '.' + (i+1);
							id_row_i = id_i + '.ROW';
							html_i = '';
							html_i += '<tr id="'+id_row_i+'">';
							if(flagShowFilename) {
								html_i += '<td>' + arrS3[i].name + ' (' + ops.formatNum(arrS3[i].size) + ')</td>';
							} else {
								html_i += '<td>(' + ops.formatNum(arrS3[i].size) + ')</td>';
							}
							html_i += '<td><div style="border: solid 1px '+color+'; width: '+width+';">';
							html_i += '<div id="'+id_i+'"style="width: 0%; height: .05in;  background-color:'+color+';"></div></div></td>';
							if(flagAllowCancel) {
								html_i += '<td><div style="cursor:pointer;padding: 5px;" title="Cancel upload" onclick="DLG1_DlgObj._abortS3Upload(\''+__guid+'\','+i+',\''+id_row_i+'\');">X</div></td>';
							}
							html_i += '</tr>';
							arrH.push(html_i);
						}
						html = arrH.join('');
						//for some reason in ie, this function is getting called a second time and if we don't exit here when .length == 0, it will overwrite the progress bar with a null string
						if(arrH.length == 0) return true;
						html = '<table>' + html + '</table>'
						if(flagMobile) {
							//mobile upload limited to 1 file and don't wrap in table
							//id_i = options.resolvedProgressPlaceholder + '.' + (1);
							html = '';
						}
					}
					eleP.innerHTML = html;
				}
			}
			for(var i = 0; i < files.length; i++) {
				var f = files[i];
				var dataA = [];
				dataA.push('_mimeType=' + f.type);
				targetName = f.name;
				if(typeof options.targetName == 'function') {
					newTargetName = options.targetName( f  );
					if(typeof newTargetName != 'undefined') {
						if(newTargetName != '') targetName = newTargetName;
					}
				}
				arrS3[i].targetName = targetName;
				var targetServer = options.target;
				if(!options.target) targetServer = 'S3';
				arrS3[i].targetServer = targetServer;
				dataA.push('_name=' + urlencode(targetName));  //name of object in S3
				dataA.push('_number=' + i);
				if(options.specifyCredentials == 'Explicit') {
					dataA.push('_xbasicFunctionNameForPropertyValues=' + options.xbasicFunctionName);
					dataA.push('_method=explicit');
				} else {
					dataA.push('_namedStorageConnectionString=' + options.connectionString);
					dataA.push('_method=connectionString');
				}
				dataA.push('_authenticatedRead=' + options.authenticatedRead);
				dataA.push('_part=' + options.part);
				dataA.push('_s3timeout='+ options.s3timeout);
				data = dataA.join('&');
				//alert(data);
				if(typeof options.userProgressFunction == 'undefined') options.userProgressFunction = function(e) {};
				if(typeof options.onCompleteAllFiles == 'undefined') options.onCompleteAllFiles = function(e) {};
				if(typeof options.onCompleteFile == 'undefined') options.onCompleteFile = function(e) { };
				var obj = {
					//ajax callback to sign url onComplete
					onComplete: function() {
						var signedURL = decodeURIComponent(_dlgObj._fileCodedURL);
						//attempt to fix a problem uploading to s3 when object name has ( )
						//signedURL = signedURL.replace('(','%28')
						//signedURL = signedURL.replace(')','%29')
						//signedURL = signedURL.replace(' ','%20')
						var num = _dlgObj._fileCodedURLNum;
						var fi = arrS3[num].file;
						var targetServer = arrS3[num].targetServer;
						delete objS3;
						var objS3 = {
							uploadCompleteFunction: function() {
								this.arrS3[this.number].completed = true;
								var flagAllCompleted = false;
								var c = 0;
								for(var i = 0; i < this.arrS3.length; i++) {
									if(this.arrS3[i].completed == true || this.arrS3[i].aborted == true) c = c+1;
								}
								if(c == this.arrS3.length) flagAllCompleted = true;
								var e = {
									name: this.name,
									type: this.type,
									size: this.size,
									number: this.number,
									fileArray: this.arrS3,
									targetName: arrS3[this.number].targetName
								}
								options.onCompleteFile(e);
								if(flagAllCompleted) {
									options.onCompleteAllFiles(e);
									if(options.displayProgress) {
										//var eleP = $(_dlgObj.dialogId + '.V.R1.' + options.progressDisplayPlaceholder);
										var eleP = $(options.resolvedProgressPlaceholder);
										if(eleP) eleP.style.display = 'none';
									}
									delete DLG1_DlgObj.__CORSUploads[__guid];
								}
							},
							userProgressFunction: options.userProgressFunction,
							onError: options.onError,
							name: fi.name,
							size: fi.size,
							type: fi.type,
							number: num,
							arrS3: arrS3,
							targetName: arrS3[num].targetName,
							__guid: __guid,
							authenticatedRead: options.authenticatedRead
						}
						objS3.targetServer = targetServer;
						ops.uploadToS3(fi,signedURL,objS3);
					}
				}
				ops.obj = obj;
				var reader = new FileReader();
				reader.onload = function(e) {
					var eleId = '';
					var ele = '';
					if(typeof options.imageControl != 'undefined' && options.part == 'ux') {
						eleId = options.__alias + '.V.R1.' + options.imageControl.toUpperCase();
						ele = $(eleId);
						if(ele) ele.src = e.target.result;
					} else {
						var flagDV = false;
						if(typeof options.__dv != 'undefined') flagDV = options.__dv
						if(flagDV) {
							eleId = options.__alias + '.D.V.R'+options.rowNumber+'.' + options.imageControl.toUpperCase();
						} else {
							eleId = options.__alias + '.V.R'+options.rowNumber+'.' + options.imageControl.toUpperCase();
						}
						ele = $(eleId);
						if(ele) {
							var oldSrc = ele.src;
							_dlgObj.__oldImage = oldSrc;
							ele.src = e.target.result;
						}
					}
				}
				reader.onerror = function(e) {
					alert('error in reader 123');
				}
				if(typeof options.imageControl != 'undefined') reader.readAsDataURL(f);
				var flagTargetIsServer = false;
				if(typeof options.target != 'undefined') {
					if(options.target.toLowerCase() == 'server') flagTargetIsServer = true;
				}
				if(!flagTargetIsServer) {
					_dlgObj.ajaxCallback('','','a5DialogHelper_signAmazonS3FileUploadURL','',data,obj);
				} else {
					//no need to sign the url for target = 'alpha'
					_dlgObj._fileCodedURLNum = i;
					obj.onComplete();
				}
			}
		}
		//$e.add($(this.dialogId + '._GETFILEMULTI'),'change',ops.handleFileSelect,'','','__amazonS3fileupload');
		$e.removeGroup('__amazonS3fileupload')
		//bind the change event to the file selector
		if(options.allowMultipleFiles) {
			if(typeof this._getFileMultiListenerLoaded == 'undefined') {
				//this._getFileMultiListenerLoaded = true;
				//$(this.dialogId + '._GETFILEMULTI').addEventListener('change',ops.handleFileSelect,false);
				$e.add($(this.dialogId + '._GETFILEMULTI'),'change',ops.handleFileSelect,'','','__amazonS3fileupload');
			}
			eleB = $(this.dialogId + '._GETFILEMULTI');
		} else {
			if(typeof this._getFileListenerLoaded == 'undefined') {
				//this._getFileListenerLoaded = true;
				//$(this.dialogId + '._GETFILE').addEventListener('change',ops.handleFileSelect,false);
				$e.add($(this.dialogId + '._GETFILE'),'change',ops.handleFileSelect,'','','__amazonS3fileupload');
			}
			eleB = $(this.dialogId + '._GETFILE');
		}
		var flagFilePassedIn = false;
		if(typeof options.flagFilePassedIn != 'undefined') {
			flagFilePassedIn = options.flagFilePassedIn
		}
		if(!flagFilePassedIn) {
			eleB.value = '';
			eleB.click();
			eleB.value = '';
		} else {
			//options.filePassedIn
			var evt = {};
			evt.target = {};
			evt.target.files = [];
			if(options.filePassedIn.constructor == FileList) {
				evt.target.files = options.filePassedIn;
			} else {
				evt.target.files[0] = options.filePassedIn;
			}
			ops.handleFileSelect(evt);
		}
	}
	////==== upload PhoneGap /////////////////////////////////////////////////////
	DLG1_DlgObj.phoneGapFileUpload = function(arr,options) {
		//var msg5 = JSON.stringify(arr,'','\t');
		//var msg6 = JSON.stringify(options,'','\t');
		//DLG1_DlgObj.debugInfoToFile(msg5,'c:/bugs/msg5.json');
		//DLG1_DlgObj.debugInfoToFile(msg6,'c:/bugs/msg6.json');
		var _dlgObj = this;
		//arr is an array of files to upload. arr must have a .filename property in each item
		if(typeof LocalFileSystem == 'undefined') {
			if(typeof cordova == 'undefined') {
				alert('Method not supported when not running in PhoneGap');
			} else {
				alert('Required PhoneGap plugins (\'LocalFileSystem 2\')not loaded.');
			}
			return false;
		}
		//initialize variables
		for(var i = 0; i < arr.length; i++) {
			arr[i].name = arr[i].filename;
			arr[i].number = i;
			arr[i].completed = false;
			arr[i].aborted = false;
			arr[i].succeeded = false;
		}
		///define local function for phoneGapFileUpload: generateProgressBarsHTML -------------
		var generateProgressBarsHTML = function (ops,count) {
			var eleTarget = ops.progressElement;
			if(typeof eleTarget != 'undefined') eleTarget = eleTarget.toUpperCase();
			var html = '';
			var html_i = '';
			var name_i = '';
			var progress_i = '';
			var idName = '';
			var idProgress = '';
			if(ops.individualProgress) {
				for(var  i = 0; i < count; i++) {
					name_i = 'Name: ' + i;
					progress_i = 'Progress...' + i;
					idProgress = eleTarget + '.PROGRESS.' + i;
					idName = eleTarget + '.NAME.' + i;
					progress_i = '<div style="border: solid 1px '+ops.color+'; width: '+ops.width+';">';
					progress_i += '<div id="'+idProgress+'"style="width: 0%; height: .05in;  background-color:'+ops.color+';"></div></div></td>';
					html_i = '<td id="'+idName+'">name '+name_i+'</td><td>'+progress_i+'</td>';
					html_i = '<tr>' + html_i + '</tr>';
					html = html + html_i;
				}
			}
			if(ops.showTotalProgress) {
				idProgress = eleTarget + '.PROGRESS.TOTAL';
				idName = eleTarget + '.NAME.TOTAL';
				progress_i = '<div style="border: solid 1px '+ops.color+'; width: '+ops.width+';">';
				progress_i += '<div id="'+idProgress+'"style="width: 0%; height: .05in;  background-color:'+ops.color+';"></div></div></td>';
				html_i = '<td id="'+idName+'"></td><td>'+progress_i+'</td>';
				html_i = '<tr>' + html_i + '</tr>';
				html = html + html_i
			}
			var idProgress = eleTarget + '.PROGRESSDISPLAY';
			html = '<div id="'+idProgress+'"><table>' + html + '</table><div>';
			$(eleTarget).innerHTML = html;
		}
		///define local function for phoneGapFileUpload: phoneGapUploadDoWork -------------
		var phoneGapUploadDoWork = function(arr,options) {
			if(options.target.toLowerCase() == 's3') {
				//s3
				var xbasicFunction = 'a5dialogHelper_systemSignS3Policy';
				var o2 = {};
				$u.o.assign(o2,options);
				/////compute localTargetName before making the callback
				var filenameURI;
				var actionOptions = options;
				for(var i = 0; i < arr.length; i++) {
					filenameURI = arr[i].filename;
					var fileName = filenameURI.substr(filenameURI.lastIndexOf('/')+1);
					var targetName = fileName;
					if(typeof actionOptions.onComputeS3Filename == 'function') {
						var e = {name: targetName, object: arr[i]};
						var newTargetName = actionOptions.onComputeS3Filename(e);
						if(typeof newTargetName == 'undefined') newTargetName = targetName;
						if(newTargetName == '') newTargetName = targetName;
						targetName = newTargetName;
					}
					//on iphone video name is always 'capturedvideo.mov' (in a unique subfolder)
					if(targetName.toLowerCase() == 'capturedvideo.mov') {
						targetName = A5.UUID() + '_video.MOV';
					}
					arr[i].targetName = targetName;
				}
				///--------end compute s3 target name
				o2.arr = arr;
				var data = A5.ajax.buildURLParam('_jsonOptions',JSON.stringify(o2));
				var ajaxObj = {
					errorFunction: function() {
						if(typeof options.onAjaxFailed == 'function') options.onAjaxFailed();
					},
					onComplete: function() {
						var startUploadLocal = function() {
							var totalSize = 0;
							for(var i = 0; i < arr.length; i++) {
								totalSize = totalSize + Number(arr[i].size);
							}
							var _sysObj = {};
							_sysObj.totalBytesToUpload = totalSize;
							var flagMobile = false;
							if(typeof options._flagMobile != 'undefined') flagMobile = options._flagMobile;
							options._flagMobile = flagMobile;
							if(options.showProgress && !flagMobile) generateProgressBarsHTML(options.progress,arr.length);
							//alert('ready to start uploading files: total ' + totalSize);
							startUploadFilesToS3(_sysObj,options);
						}
						var _sTop = {};
						getFileSizesForAllItemsInArray(startUploadLocal,_sTop);
					},
					deviceOfflineFunction: function() {
						if(typeof options.onDeviceOffline == 'function') options.onDeviceOffline();
					}
				}
				//alert('ajax callback');
				DLG1_DlgObj.ajaxCallback('','',xbasicFunction,'',data,ajaxObj);
			} else {
				//alpha server
				var startUploadLocal = function() {
					var totalSize = 0;
					for(var i = 0; i < arr.length; i++) {
						totalSize = totalSize + Number(arr[i].size);
					}
					var _sysObj = {};
					_sysObj.totalBytesToUpload = totalSize;
					if(options.showProgress) generateProgressBarsHTML(options.progress,arr.length);
					startUploadFilesToS3(_sysObj,options);
				}
				var _sTop = {};
				getFileSizesForAllItemsInArray(startUploadLocal,_sTop);
			}
		}
		///define local function for phoneGapFileUpload: getFileSizesForAllItemsInList
		var getFileSizesForAllItemsInArray = function(allDone_GotAllFileSizes_Callback, _sTop)  {
			var _s = {count: 0};
			var getFileSizesForAllItemsInArrayLow = function (arr,r,count,callback,_s,_sTop) {
				var rowNumber = r;
				var url = arr[r].filename;
				var resolveLocalFileURL_SUCCESS = function(fileEntry) {
					var file_SUCCESS = function(f) {
						arr[r].size = f.size;
						_s.count = _s.count + 1;
						if(_s.count == count) {
							callback(_sTop);
						}
					}
					fileEntry.file(file_SUCCESS);
				}
				//on iphone, video capture does not return a file with the file:// prefix
				var urlToResolve = url;
				if(url.indexOf('file:') != 0) {
					urlToResolve = urlToResolve.replace('/private','file:\/\/');
				}
				window.resolveLocalFileSystemURL(urlToResolve, resolveLocalFileURL_SUCCESS, function() { } );
			}
			for(var i = 0; i < arr.length; i++) {
				getFileSizesForAllItemsInArrayLow(arr,i,arr.length,allDone_GotAllFileSizes_Callback,_s,_sTop)
			}
		}
		///define local function for phoneGapFileUpload: startUploadFilesToS3
		var startUploadFilesToS3 = function(_sysObj,options) {
			//_sysObj.totalBytesToUpload;
			for(var i = 0; i < arr.length; i++) {
				upLoadFilesToS3Work(arr[i].filename,arr,i,_sysObj,options)
			}
		}
		///define local function for phoneGapFileUpload: s3SignedPolicy
		var s3SignedPolicy = function() {
			var obj = {};
			obj.hasError = DLG1_DlgObj._pgS3.hasError;
			obj.policyBase64 = DLG1_DlgObj._pgS3.policyBase64;
			obj.signature = DLG1_DlgObj._pgS3.signature;
			obj.userKey = DLG1_DlgObj._pgS3.accessKey;
			obj.acl = DLG1_DlgObj._pgS3.acl;
			obj.bucket = DLG1_DlgObj._pgS3.bucket;
			return obj;
		}
		///define local function for phoneGapFileUpload: uploadFilesToS3Work
		var upLoadFilesToS3Work = function(filenameURI,arr,fileNumber,_sysObj, actionOptions) {
			//this code to compute the targetName now gets run before the ajax callback to sign the url is made because the v4 amz signing method
			//needs to include the s3 object name in the url that gets signed
			var fileName = filenameURI.substr(filenameURI.lastIndexOf('/')+1);
			var targetName = fileName;
			if(typeof actionOptions.onComputeS3Filename == 'function') {
				var e = {name: targetName, object: arr[fileNumber]};
				var newTargetName = actionOptions.onComputeS3Filename(e);
				if(typeof newTargetName == 'undefined') newTargetName = targetName;
				if(newTargetName == '') newTargetName = targetName;
				targetName = newTargetName;
			}
			//on iphone video name is always 'capturedvideo.mov' (in a unique subfolder)
			if(targetName.toLowerCase() == 'capturedvideo.mov') {
				targetName = A5.UUID() + '_video.MOV';
			}
			if(typeof actionOptions.target != 'undefined') {
				if(actionOptions.target == 'alphaanywhere') {
					arr[fileNumber].targetName = targetName
				}
			}
			//
			//do not do this here when target is S3. it has already been done before the ajax callback.
			//arr[fileNumber].targetName = targetName; //use name that event returned
			var ft = new FileTransfer();
			var options = new FileUploadOptions();
			options.fileKey = "file";
			options.fileName = targetName;
			options.mimeType = "image/jpeg";
			options.chunkedMode = false;
			if(actionOptions.target == 'alphaanywhere') {
				var s3URI = encodeURI( $u.s.aTrim(DLG1_DlgObj.ajaxURL));
				//s3URI = 'junk'; //force a file upload error
				//alert('remember to turn this off');
				var xbasicAfterUpload = actionOptions.xbasicAfterFileUploaded
				var specialMode = '';
				if(typeof actionOptions.specialMode != 'undefined') specialMode = actionOptions.specialMode;
				options.params = {
					"_XbasicFunction" : "system:phonegapfileupload",
					"__Ajax" : "true",
					"__FormAction" : "GenericAjaxCallback",
					"__FormID" : "",
					"__xbasicAfterUpload" : xbasicAfterUpload,
					"__arrayIndex" : fileNumber,
					"__actionOptions" : JSON.stringify(actionOptions),
					"__specialMode" : specialMode,
					"__targetName" : targetName,
					"__arrayItem" : JSON.stringify(arr[fileNumber]),
					"__ajaxURL" : $u.s.aTrim(DLG1_DlgObj.ajaxURL)
				}
			} else {
				//s3
				var obj = s3SignedPolicy();
				var s3URI = encodeURI('https://' + obj.bucket + '.s3.amazonaws.com/'),
					policyBase64 = obj.policyBase64,
					signature = obj.signature,
					awsKey = obj.userKey,
					acl = obj.acl;
				//this is computed on the server
				s3URI = DLG1_DlgObj._pgS3.signedURI;
				var arr2 = JSON.parse(DLG1_DlgObj._pgS3.signedURIArrayJSON);
				var _uri = arr2[fileNumber].uri;
				var _mime = arr2[fileNumber].mimeType;
				s3URI = _uri;
				//alert('s3URI: ' + s3URI);
				options.params = {
					"key": targetName,
					"AWSAccessKeyId": awsKey,
					"acl": acl,
					"policy": policyBase64,
					"signature": signature,
					"Content-Type": "image/jpeg"
				};
			}
			var setProgress = function(progressId,fileNumber,pctComplete) {
				var id = '';
				var countCompleted = 0;
				if(fileNumber == 'total') {
					id = progressId + '.PROGRESS.TOTAL';
					for(var i = 0; i < arr.length; i++) {
						if(arr[i].completed) countCompleted = countCompleted + 1;
					}
					var idN = progressId + '.NAME.TOTAL';
					var ele = $(idN);
					//if(ele) ele.innerHTML = 'Completed: ' + countCompleted +  ' of ' + arr.length;
				} else {
					id = progressId + '.PROGRESS.' + fileNumber;
				}
				var ele = $(id);
				if(ele) ele.style.width = pctComplete + '%';
				var idP = progressId + '.PROGRESSDISPLAY';
				ele = $(idP);
				if(ele) ele.style.display = '';
			}
			ft.onprogress = function(progressEvent) {
				var totalBytesToTransfer = _sysObj.totalBytesToUpload
				if(typeof _sysObj.workDone == 'undefined') {
					_sysObj.workDone = [];
					for(var i = 0; i < arr.length; i++) {
						_sysObj.workDone[i] = 0;
					}
				 };
				_sysObj.workDone[fileNumber] = progressEvent.loaded;
				var gTotal = 0;
				for(var i = 0; i < _sysObj.workDone.length; i++) {
					if(typeof _sysObj.workDone[i] != 'undefined') {
						gTotal = gTotal + _sysObj.workDone[i];
					}
				}
				var progressId = actionOptions.progress.progressElement;
				if (progressEvent.lengthComputable) {
					var pctComplete = (progressEvent.loaded / progressEvent.total)*100;
					if(pctComplete > 100) pctComplete = 100;
					pctComplete = $u.n.round(pctComplete,4);
					if(actionOptions.showProgress) setProgress(progressId,fileNumber,pctComplete);
					if(typeof actionOptions.onProgressEvent == 'function') {
						actionOptions.onProgressEvent(arr, fileNumber, pctComplete, progressEvent.loaded, progressEvent.total);
					}
					var pctCompleteTotal = (gTotal / totalBytesToTransfer) * 100;
					if(pctCompleteTotal > 100) pctCompleteTotal = 100;
					pctCompleteTotal = $u.n.round( pctCompleteTotal,4);
					if(actionOptions.showProgress) setProgress(progressId,'total',pctCompleteTotal);
					if(typeof actionOptions.onProgressEvent == 'function') {
						actionOptions.onProgressEvent(arr, 'total', pctCompleteTotal, gTotal, totalBytesToTransfer);
					}
					if(actionOptions._flagMobile) {
						if($('MOBILEUPLOADPROGRESS.1')) $('MOBILEUPLOADPROGRESS.1').style.width = pctCompleteTotal + '%';
					}
				} else {
					//progress messages not possible -- should never happen
				}
			};
			var _hasCompleted = function() {
				var flagAllDone = true;
				for(var i = 0; i < arr.length; i ++) {
					if(arr[i].completed == false) {
						flagAllDone = false;
						break;
					}
				}
				return flagAllDone;
			}
			var fileUploadSuccess = function(r) {
				arr[fileNumber].completed = true;
				arr[fileNumber].succeeded = true;
				arr[fileNumber].remoteName = arr[fileNumber].targetName;
				//for uploads to AlphaAnywhere, the Xbasic function that is called can send a response
				if(r.response != 'undefined') {
					if(r.response != '') eval(r.response);
				};
				//if the targer is the Alpha server and the Xbasic handler sent a response that set the 'targetFileName' property
				var target = actionOptions.target.toLowerCase();
				if(target == 's3') {
					if(typeof actionOptions.s3.template != 'undefined') {
						arr[fileNumber].remoteName = actionOptions.s3.template.replace('__name__',arr[fileNumber].targetName);
					}
				} else {
					if(typeof arr[fileNumber].targetFileName != 'undefined') {
						arr[fileNumber].remoteName = arr[fileNumber].targetFileName;
					}
				}
				if(typeof actionOptions.onCompleteIndividualFile == 'function') {
					actionOptions.onCompleteIndividualFile(arr,fileNumber);
				}
				var flagAllDone = _hasCompleted();
				if(flagAllDone) {
					var progressId = actionOptions.progress.progressElement;
					var idP = progressId + '.PROGRESSDISPLAY';
					var ele = $(idP);
					if(ele) ele.style.display = 'none';
					if(typeof actionOptions.onComplete == 'function') {
						actionOptions.onComplete(arr);
					};
				}
			}
			var _hideProgress = function() {
				var progressId = actionOptions.progress.progressElement;
				var idP = progressId + '.PROGRESSDISPLAY';
				var ele = $(idP);
				if(ele) ele.style.display = 'none';
			}
			var fileUploadFailed = function(error) {
				arr[fileNumber].failed = true;
				arr[fileNumber].completed = true;
				if(typeof actionOptions.onError == 'function') {
					actionOptions.onError(arr,fileNumber,error);
				}
				if(typeof actionOptions.onCompleteIndividualFile == 'function') {
					actionOptions.onCompleteIndividualFile(arr,fileNumber);
				}
				var flagAllDone = _hasCompleted();
				if(flagAllDone) {
					_hideProgress();
					if(typeof actionOptions.onComplete == 'function') {
						actionOptions.onComplete(arr);
					}
				};
			}
			var flagOK = true;
			if(typeof actionOptions.onValidate == 'function') {
				var result = actionOptions.onValidate(arr,fileNumber);
				if(typeof result != 'undefined') flagOK = result;
			}
			//do the upload
			if(flagOK) {
				var flagTrustAllHosts = false;
				if(typeof _dlgObj != 'undefined') {
					if(typeof _dlgObj._phoneGapTrustAllHosts != 'undefined') {
						flagTrustAllHosts = _dlgObj._phoneGapTrustAllHosts;
					}
				}
				if(actionOptions.target == 'alphaanywhere') {
					options.httpMethod = 'POST';
				} else {
					options.httpMethod = 'PUT';
					options.headers = {'Content-Type': 'image/jpeg','x-amz-acl': acl };
					options.multipartMode = false;
				}
				ft.upload(filenameURI, s3URI, fileUploadSuccess, fileUploadFailed, options,flagTrustAllHosts);
			} else {
				arr[fileNumber].aborted = true;
				arr[fileNumber].completed = true;
			}
		}
		phoneGapUploadDoWork(arr,options);
	}
	DLG1_DlgObj.phoneGapCreateDirectory = function(dirName, onComplete, onError) {
		if(typeof onError == 'undefined') onError = function(err) { };
		var onFSSuccess = function(fs) {
			//got the filesystem
			var onDirCreateSuccess = function(dirEntry) {
				if(typeof onComplete == 'function') {
					onComplete();
				}
			}
			fs.root.getDirectory(dirName, {create: true},onDirCreateSuccess, onError);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onError );
	}
	DLG1_DlgObj.phoneGapCreateDirectoryRecurse = function(dirName, onComplete, onError) {
		if(typeof onError == 'undefined') onError = function(err) { };
		var prepareWork = function(dir) {
			var arr = dir.split('/');
			var arr3 = [];
			for(var i = 0; i < arr.length; i++) {
				var arr2 = [];
				for(var k = 0; k < i + 1; k++) {
					arr2.push(arr[k]);
				}
				arr3.push(arr2.join('/'));
			}
			return arr3;
		}
		var arr = prepareWork(dirName);
		var count = 0;
		var onCompleteLocal = function() {
			if(count == arr.length) {
				onComplete();
			} else {
				DLG1_DlgObj.phoneGapCreateDirectory(arr[count],onCompleteLocal,onError);
				++count;
			}
		}
		DLG1_DlgObj.phoneGapCreateDirectory(arr[count],onCompleteLocal,onError);
	}
	DLG1_DlgObj.phoneGapGetDirectory = function(dirName, onComplete, onError) {
		//calls onComplete with an array of files in the directory
		if(typeof onError == 'undefined') onError = function(err) { };
		//got filesystem event handler
		var onFSSuccess = function(fs) {
			if(dirName.indexOf('/') == 0) dirName = dirName.substring(1);
			//got the fileSystem
			//alert('got fs - dirName:  ' + dirName);
			fs.root.getDirectory(dirName,{},function(e) {
			var dirReader = e.createReader();
			var listFiles = function(entries) {
				var fileCount = entries.length;
				var arr = [];
				var displayName = '';
				for(var i = 0; i < fileCount ; i++) {
					if(entries[i].isFile) displayName = entries[i].fullPath + ' [F]';
					else displayName = entries[i].fullPath + ' [D]';
					arr.push( {fullPath: entries[i].fullPath, isFile: entries[i].isFile, display: displayName } );
				}
				if(typeof onComplete == 'function') {
					onComplete(arr);
				}
			}
			dirReader.readEntries(listFiles,onError);
		},onError);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onError );
	}
	DLG1_DlgObj.phoneGapGetDirectoryRecurse = function(folder, onDirComplete, onDirError) {
		//onDirComplete gets called with files, an array of all files. each array entry has a 'fileName' property.
		var files = [];
		var pending = 0;
		var onComplete = function(array) {
			for(var i = 0; i < array.length; i++) {
				if(array[i].isFile) {
					files.push({fullPath: array[i].fullPath, isFile: true, display: array[i].fullPath + ' [F]'})
				} else {
					++pending;
					files.push({fullPath: array[i].fullPath, isFile: false, display: array[i].fullPath + ' [D]'})
					DLG1_DlgObj.phoneGapGetDirectory(array[i].fullPath,onComplete,onError)
				}
			}
			--pending;
			if(pending == 0) {
				onDirComplete(files);
			}
		}
		var onError = function(err) {
			if(typeof onDirError == 'function') {
				onDirError(err);
				onDirComplete = function() { } //prevent the all complete from firing
			}
			else alert('Error');
		}
		++pending;
		DLG1_DlgObj.phoneGapGetDirectory(folder,onComplete,onError);
	}
	DLG1_DlgObj.phoneGapRemoveDirectory = function(dirName,onSuccess,onError,flagRecursive) {
		if(typeof flagRecursive == 'undefined') flagRecursive = false;
		if(typeof onError == 'undefined') onError = function(err) { };
		var onFSSuccess = function(fs) {
			var gotDirectory = function(dirEntry) {
				if(flagRecursive) {
					dirEntry.removeRecursively(function() {
						if(typeof onSuccess == 'function') onSuccess();
					},onError);
				} else {
					dirEntry.remove(function() {
						if(typeof onSuccess == 'function') onSuccess();
					},onError);
				}
			}
			//if you cant find the dir then it is effectively removed, so call onSuccess
			fs.root.getDirectory(dirName, {}, gotDirectory, onSuccess);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onError );
	}
	DLG1_DlgObj.phoneGapRemoveDirectoryRecurse = function(dirName,onSuccess,onError) {
		DLG1_DlgObj.phoneGapRemoveDirectory(dirName,onSuccess,onError,true);
	}
	DLG1_DlgObj.phoneGapDeleteFile = function(fileName,onSuccess,onError) {
		var onFSSuccess = function(fs) {
			fs.root.getFile(fileName, {create: false}, function(f) {
				f.remove( function() {
					if(typeof onSuccess == 'function') {
						onSuccess();
					}
				}, onError );
			}, onError);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onError );
	}
	DLG1_DlgObj.phoneGapFileExists = function(fileName,onResult,onFailed) {
		var onFSSuccess = function(fs) {
			var gotFile = function(f) {
				if(typeof onResult == 'function') onResult(true);
			}
			var didNotGetFile = function() {
				if(typeof onResult == 'function') onResult(false);
			}
			fs.root.getFile(fileName, {create: false}, gotFile,didNotGetFile);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onFailed );
	}
	DLG1_DlgObj.phoneGapReadFile = function(fileName,onReadFile,onReadFileERROR,startAt,endAt) {
		if(typeof fileName == 'object') {
			var fnObj = fileName;
			var _success = onReadFile
			if(typeof onReadFileERROR == 'undefined') onReadFileERROR = function(err) { };
			var _error = onReadFileERROR;
			if(fnObj._strip) {
				var _filePath = this.phoneGapGetLocalDirURL(fnObj._fs) + fnObj._dir + '/' + fnObj.fileNameShort;
			} else {
				var _filePath = this.phoneGapGetLocalDirURL(fnObj._fs) + fnObj._dir + '/' + 'A5SessionFile/' + fnObj.fileNameShort;
			}
			if(typeof startAt == 'undefined') {
				this.phoneGapReadFileURL(_filePath, _success,_error);
			} else {
				this.phoneGapReadFileURL(_filePath, _success,_error,startAt,endAt);
			}
			return true;
		}
		var onFSSuccess = function(fs) {
			var readFile = function(f) {
				f.file( function(e) {
					reader = new FileReader();
					reader.onloadend = function(e) {
						if(typeof onReadFile == 'function') {
							onReadFile(e.target.result);
						}
					}
					if(typeof startAt == 'undefined' || typeof endAt == 'undefined') {
						reader.readAsText(e);
					} else {
						var blob = e.slice(startAt,endAt);
						reader.readAsText(blob);
					}
				});
			}
			fs.root.getFile(fileName, {create: false}, readFile, onReadFileERROR);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onReadFileERROR );
	}
	DLG1_DlgObj._phoneGapCreateFile_low = function(fileName,text,onCreatedFile,onCreateFileERROR) {
		var onFSSuccess = function(fs) {
			var writeFileData = function(f) {
				var doFileWrite = function(writerObject) {
					writerObject.onwrite = function() {
						if(typeof onCreatedFile == 'function') onCreatedFile();
					}
					writerObject.seek(writerObject.length);
					var blob = new Blob([text], {type: 'text/plain'});
					writerObject.write(blob);
				}
				f.createWriter(doFileWrite);
			}
			fs.root.getFile(fileName, {create:true}, writeFileData, onCreateFileERROR);
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onCreateFileERROR );
	}
	DLG1_DlgObj.phoneGapCreateFile = function(fileName,text,onCreatedFile,onCreateFileERROR,flagAppend) {
		if(fileName == '') {if(typeof onCreateFileERROR == 'function') onCreateFileERROR(); return false;}
		var onFSSuccess = function(fs) {
			if(!flagAppend) {
				var onDelete = function() {
					DLG1_DlgObj._phoneGapCreateFile_low(fileName,text,onCreatedFile,onCreateFileERROR);
				}
				DLG1_DlgObj.phoneGapDeleteFile(fileName,onDelete,onDelete)
			} else {
				DLG1_DlgObj._phoneGapCreateFile_low(fileName,text,onCreatedFile,onCreateFileERROR)
			}
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onCreateFileERROR );
	}
	DLG1_DlgObj.phoneGapFileDownload = function(arr,options) {
		var totalSizePassedIn = 0;
		for(var i = 0; i < arr.length; i++) {
			if(typeof arr[i].size != 'undefined') totalSizePassedIn = totalSizePassedIn + arr[i].size;
		}
		options.totalSizePassedIn = totalSizePassedIn
		if(totalSizePassedIn > 0) options.totalFileSize = totalSizePassedIn;
		if(typeof options.targetFolder == 'undefined') {
			var _baseURI = this.phoneGapGetLocalDirURL(options.filesystem);; //sr2
			var _dirName = options.directory;;
			if(_dirName == '') {
				var _dirPath = _baseURI;
			} else {
				var _dirPath = _baseURI + _dirName + '/';
			}
			options.fullyQualifiedPath = _dirPath;
		}
		var _countDone = 0;
		var flagCustomOnError = false;
		if(typeof DLG1_DlgObj.customWindowErrorEvents != 'undefined') flagCustomOnError = DLG1_DlgObj.customWindowErrorEvents;
		//if(!flagCustomOnError) window.onerror = function(err) { alert('Unhandled Javascript Error - phoneGapFileDownload:  ' + JSON.stringify(err));}
		var _dlgObj = this;
		if(typeof LocalFileSystem == 'undefined') {
			if(typeof cordova == 'undefined') {
				alert('Method not supported when not running in PhoneGap');
			} else {
				alert('Required PhoneGap plugins (\'LocalFileSystem\') not loaded.');
			}
			return false;
		}
		if(typeof onError == 'undefined') onError = function(err) { };
		//got filesystem event handler
		for(var i = 0; i < arr.length; i++) {
			arr[i].handled = false;
			arr[i].downloaded = false;
			arr[i].sourceType = 'server';
			if(arr[i].filename.toLowerCase().indexOf('http://') == 0) arr[i].sourceType = 'url';
			if(arr[i].filename.toLowerCase().indexOf('https://') == 0) arr[i].sourceType = 'url';
			if(arr[i].sourceType == 'url') {
				arr[i].sourceFilename = arr[i].filename.split('/').pop().split('?')[0];
			}
		}
		var onFSSuccess = function(fs) {
			var baseDirectory = fs.root.toURL();
			options._baseDirectory = baseDirectory; //sr 99
			var url = DLG1_DlgObj.ajaxURL;
			;
			url = url.split('?')[0];
			url = url.split('/');
			url.pop();
			url = url.join('/') + '/';
			options._serverURL = url;
			for(var i = 0; i < arr.length; i++) {
				//arr[i].localFileName = false;
			}
			if(options.showProgress) {
				var eleTarget = options.progress.progressElement;
				if(typeof eleTarget != 'undefined'){
					if(eleTarget != eleTarget.toUpperCase() ) {
						alert('error: PROGRESS WILL NOT BE SHOWN. target div name MUST be uppercase. you have specified :' + eleTarget);
					}
					eleTarget = eleTarget.toUpperCase();
				}
				var idProgress = eleTarget;
				var ele = $(idProgress);
				if(!ele) options.showProgress = false; //set to false or else you will hang iOS
			}
			if(options.showProgress) {
				var ops = options.progress;
				ops.totalFileSize = options.totalFileSize;
				var eleTarget = ops.progressElement;
				if(typeof eleTarget != 'undefined') eleTarget = eleTarget.toUpperCase();
				var html = '';
				var html_i = '';
				var name_i = '';
				var progress_i = '';
				var idName = '';
				var idProgress = '';
				idProgress = eleTarget + '.PROGRESS.TOTAL';
				idName = eleTarget + '.NAME.TOTAL';
				progress_i = '<div style="background-color: #f3f0ef; border: solid 1px gray; border-radius: 5px; width: '+ops.width+'; ">';
				progress_i += '<div id="'+idProgress+'"style="width: 0%; height: .05in;  background-color:'+ops.color+';border-radius: 5px; border: solid .5px '+ops.color+';"></div></div>';
				html_i = '<div id="'+idName+'" ></div>'+progress_i;
				html = html + html_i
				var idProgress = eleTarget + '.PROGRESSDISPLAY';
				html = '<div id="'+idProgress+'"  style="width: 100%" >' + html + '</div>';
				if ($(eleTarget)) $(eleTarget).innerHTML = html;
				var msg = 'eleTarget: ' + eleTarget + '\n' + html
				//var filename = 'c:\\bugs\\file1.txt';
				//DLG1_DlgObj.debugInfoToFile(msg,filename,true,false) ;
				var showProgress = function(pct,arr,fileNumber,loaded,totalBytes, onProgressEvent,completedFiles) {
					var eleTarget = options.progress.progressElement
					if(typeof eleTarget != 'undefined') eleTarget = eleTarget.toUpperCase();
					var idProgress = eleTarget + '.PROGRESS.TOTAL';
					var ele = $(idProgress);
					if(ele) {
						if(pct >=100) pct = 100;
						ele.style.width = pct + '%';
						ele.style.borderRadius = '5px';
					}
					if(typeof onProgressEvent == 'function') {
						//match the prototype of the function: array, arrayIndex, pctComplete, bytesCompleted, bytesTotal, completedFiles
						onProgressEvent(arr,fileNumber,pct,loaded,totalBytes,completedFiles)
					}
				}
			} else {
				var showProgress = function(pct) { };
				//this is wrong. if the user has turned showprogress off, then the showProgress() function must still be defined, passsing in the user defined onProgress event
			}
			var phoneGapFileDownload_low = function(arr,iIn,options) {
				var i = Number(iIn);
				if(typeof options.targetFolder != 'undefined') {
					var targetFolder = options.targetFolder;
					if(targetFolder != '') targetFolder = targetFolder + '/';
					if(typeof options._baseDirectory != 'undefined') {
						var fnLocal = options._baseDirectory + targetFolder + A5.parseFilename(arr[i].filename).name;
					} else {
						var fnLocal = targetFolder + A5.parseFilename(arr[i].filename).name; //sr99
					}
				} else {
					var flagStrip = false;
					if(typeof options.strip != 'undefined') flagStrip = options.strip;
					var flagHasA5SessionFilePrefix = false
					if(arr[i].filename.indexOf('A5SessionFile/') >=0) flagHasA5SessionFilePrefix = true;
					if(flagStrip) {
						var _fn = (A5.parseFilename(arr[i].filename).name).replace('A5SessionFile/','');
					} else {
						var _fn = A5.parseFilename(arr[i].filename).name;
						if(flagHasA5SessionFilePrefix) _fn = 'A5SessionFile/' + _fn;
					}
					var fnLocal = options.fullyQualifiedPath + _fn;
				}
				//alert(fnLocal); //could strip off /A5SessionFile
				/*
				not sure why this is being done, but wrong
				if(arr[i].sourceType == 'url') {
					if(typeof targetFolder == 'undefined') {
						targetFolder = options.directory + '/';
					} else {
						targetFolder = options.targetFolder + '/';
					}
					fnLocal = options._baseDirectory + targetFolder +arr[i].sourceFilename;
				}
				*/
				if(A5.log) A5.log('fnLocal: ' + fnLocal);
				//if the targetFolder is <SQLite>|localdbname.db user is doing a special download to the SQL database folder
				var flagSQLite = false;
				/*
				if(targetFolder.indexOf('<SQLite>') == 0) {
					var localDBName = targetFolder.split('|')[1];
					localDBName = localDBName.split('/')[0];
					flagSQLite = true;
					var thisPackageName = '';
					thisPackageName = _phoneGapSettings().appId ;
					var localDbFileUrl = 	{
							android: '/data/data/' + thisPackageName + '/databases/' + localDBName,
							ios: 'cdvfile://localhost/persistent/' + localDBName
							//cdvfile://localhost/persistent/sqlite/' + localDBName
						};
					if(typeof device == 'undefined') {
						alert('PhoneGap required plugin not loaded: device');
					}
					var thisDevice = device.platform;
					var fileUrl = thisDevice == "Android" ? localDbFileUrl.android : localDbFileUrl.ios;
					console.log('database location: ' + fileUrl);
					fnLocal = fileUrl;
				}
				*/
				if(typeof options.targetFolder != 'undefined') {
					if(targetFolder.indexOf('<SQLite>') == 0) {
						var localDBName = targetFolder.split('|')[1];
						localDBName = localDBName.split('/')[0];
						flagSQLite = true;
						var thisPackageName = '';
						thisPackageName = _phoneGapSettings().appId ;
						var localDbFileUrl = {
							// Android note: This entry was tested and works on Android 6.01, 5.5.1, 4.4.2
							android: '/data/data/' + thisPackageName + '/databases/' + localDBName,
							// iOS Note: dataDirectory will point to ..appid/Library/NoCloud
							// This is not exposed to iTunes or iCloud
							ios: cordova.file.dataDirectory + localDBName
						};
						if(typeof device == 'undefined') {
							alert('PhoneGap required plugin not loaded: device');
						}
						var thisDevice = device.platform;
						var fileUrl = thisDevice == "Android" ? localDbFileUrl.android : localDbFileUrl.ios;
						console.log('.phoneGapFileDownload reports fileUrl: ' + fileUrl);
						fnLocal = fileUrl;
					}
				}
				var fileFound = function() {
					var forceDownload = false;
					forceDownload = options.forceDownloadIfFileExists;
					if(typeof forceDownload == 'undefined') forceDownload = false;
					if(forceDownload) {
						fileNotFound();
						return true;
					}
					arr[i].handled = true;
					arr[i].found = true;
					arr[i].localFilename = fnLocal;
					arr[i].success = true;
					var allHandled = true;
					////
					var totalBytes = 0;
					var loaded = 0;
					var pctCompleteTotal = 0;
					var flagStartShowingProgress = true;
					var completedFiles = 0;
					var totalSize = 0;
					var _pctMethod = 'auto' //base on filesLoadedCount if array size > 10
					if(typeof options != 'undefined') {
						if(typeof options.pctMethod != 'undefined') _pctMethod = options.pctMethod
					}
					if(arr.length == 1) _pctMethod = 'auto';
					pctCompleteTotal = $u.n.round(pctCompleteTotal,1);
					for(var k = 0; k < arr.length; k++) {
						if(typeof arr[k].totalBytes != 'undefined') {
							totalBytes = totalBytes + arr[k].totalBytes;
							loaded = loaded + arr[k].bytesLoaded;
						}
						if(arr[k].handled) completedFiles++;
						pctCompleteTotal = (loaded/totalBytes) * 100;
						if(totalSize > 0) {
							pctCompleteTotal = (loaded/totalSize) * 100;
						}
						if(_pctMethod == 'auto') {
							if(arr.length >= 10) _pctMethod = 'fileCount';
						}
						if(_pctMethod == 'fileCount') {
							pctCompleteTotal = (completedFiles/ arr.length) * 100;
						}
						pctCompleteTotal = $u.n.round(pctCompleteTotal,1);
					}
					if(flagStartShowingProgress || true ) showProgress(pctCompleteTotal,arr,i,loaded,totalBytes, options.onProgressEvent,completedFiles);
					for(var k = 0; k < arr.length; k++) {
						if(!arr[k].handled) {
							allHandled = false;
							break;
						}
					}
					if(allHandled) {
						if(typeof options.onComplete == 'function') options.onComplete(arr);
						var eleTarget = options.progress.progressElement;
						if(typeof eleTarget != 'undefined') eleTarget = eleTarget.toUpperCase();
						var idProgress = eleTarget + '.PROGRESSDISPLAY';
						var ele = $(idProgress);
						if(ele) ele.style.display = 'none';
					}
				}
				var fileNotFound = function() {
					//file was not in the local filesystem so must download it.
					arr[i].found = false;
					arr[i].localFilename = fnLocal;
					var url2 = options._serverURL + arr[i].filename;
					if(arr[i].sourceType == 'url') {
						url2 = arr[i].filename;
					}
					var ft = new FileTransfer();
					ft.onprogress = function(progressEvent) {
						if (progressEvent.lengthComputable) {
							arr[i].totalBytes = progressEvent.total;
							arr[i].bytesLoaded = progressEvent.loaded;
							var totalSize = -1;
							_pctMethod = 'auto' //base on filesLoadedCount if array size > 10
							if(typeof options != 'undefined') {
								totalSize = options.totalFileSize;
								if(typeof options.pctMethod != 'undefined') _pctMethod = options.pctMethod
							}
							if(arr.length == 1) _pctMethod = 'auto';
							//alert(_pctMethod);
							if(typeof totalSize == 'undefined') totalSize = -1;
							if(totalSize == -1) {
								var pctComplete = (progressEvent.loaded / progressEvent.total)*100;
							} else {
								var pctComplete = (progressEvent.loaded / totalSize)*100;
							}
							if(pctComplete > 100) pctComplete = 100;
							pctComplete = $u.n.round(pctComplete,4);
							arr[i].pctComplete = pctComplete;
							var totalBytes = 0;
							var loaded = 0;
							var pctCompleteTotal = 0;
							var flagStartShowingProgress = true;
							var completedFiles = 0;
							for(var k = 0; k < arr.length; k++) {
								if(typeof arr[k].totalBytes != 'undefined') {
									totalBytes = totalBytes + arr[k].totalBytes;
									loaded = loaded + arr[k].bytesLoaded;
									if(arr[k].handled) completedFiles++;
									pctCompleteTotal = (loaded/totalBytes) * 100;
									if(typeof options.totalSizePassedIn > 0) {
										totalSize = options.totalSizePassedIn;
									}
									if(totalSize > 0) {
										pctCompleteTotal = (loaded/totalSize) * 100;
									}
									if(_pctMethod == 'auto') {
										if(arr.length >= 10) _pctMethod = 'fileCount';
									}
									if(_pctMethod == 'fileCount') {
										pctCompleteTotal = (completedFiles/ arr.length) * 100;
									}
									pctCompleteTotal = $u.n.round(pctCompleteTotal,1);
								}
							}
							if(flagStartShowingProgress || true ) showProgress(pctCompleteTotal,arr,i,loaded,totalBytes, options.onProgressEvent,completedFiles); //sr55
						} else {
							//alert('length NOT computable: ' + arr[i].filename);
							console.log('PhoneGap fileTransfer event. onProgress. length NOT computable: ' + arr[i].filename)
							//alert('progressevent: ' + JSON.stringify(progressEvent));
						}
					}
					var flagTrustAllHosts = false;
					if(typeof _dlgObj._phoneGapTrustAllHosts != 'undefined') {
						flagTrustAllHosts = _dlgObj._phoneGapTrustAllHosts;
					}
					//had a url like this: http://aapdf.s3.amazonaws.com/651 - 2015007 - HL072 - Summary P&L.PDF
					//need to urlencode the url and the fnLocal to get this
					//http://aapdf.s3.amazonaws.com/651%20-%202015007%20-%20HL072%20-%20Summary%20P%26L.PDF
					//first decode, then encode again to make sure we don't double encode
					//the fix the encoded '&' - %2526 to change to %26
					var testString1 = url2.toLowerCase();
					var testString2 = decodeURI(url2).toLowerCase();
					var search = 'X-Amz-'.toLowerCase();
					var flagDoEncode = true;
					if(testString1.indexOf(search) > -1 || testString2.indexOf(search) > -1) flagDoEncode = false;
					//if the url to download from S3 is signed then the urlencode() will break the download
					if(flagDoEncode) {
						url2 = encodeURI(decodeURI(url2));
						url2 = url2.replace(/%2526/g,'%26');
					}
					fnLocal = encodeURI(decodeURI(fnLocal));
					fnLocal = fnLocal.replace(/%2526/g,'%26');
					if(A5.log) A5.log('Inside PhoneGap file transfer url2: ' + url2);
					if(A5.log) A5.log('Inside PhoneGap file transfer fnLocal: ' + fnLocal);
					ft.download(url2, fnLocal,
							function(entry) {
								arr[i].success = true;
								arr[i].handled = true;
								arr[i].downloaded = true;
								//fileAllDone();
								var allHandled = true;
								for(var k = 0; k < arr.length; k++) {
									if(!arr[k].handled) {
										allHandled = false;
										break;
									}
								}
								_countDone++;
								if(allHandled) {
									showProgress(100,arr,1,-1,-1, options.onProgressEvent,arr.length); //sr55
									if(typeof options.onComplete == 'function') options.onComplete(arr);
									if(options.showProgress) {
										var eleTarget = options.progress.progressElement;
										if(typeof eleTarget != 'undefined') eleTarget = eleTarget.toUpperCase()
										var idProgress = eleTarget + '.PROGRESSDISPLAY';
										if($(idProgress)) $(idProgress).style.display = 'none';
									}
								}
							},
							function(err) {
								arr[i].success = false;
								arr[i].errorText = JSON.stringify(err);
								arr[i].handled = true;
								if(A5.log) A5.log('Error in .download() function: ' + arr[i].errorText);
								var allHandled = true;
								for(var k = 0; k < arr.length; k++) {
									if(!arr[k].handled) {
										allHandled = false;
										break;
									}
								}
								if(allHandled) {
									if(typeof options.onComplete == 'function') options.onComplete(arr);
									if(options.showProgress) {
										var eleTarget = options.progress.progressElement;
										if(typeof eleTarget != 'undefined') eleTarget = eleTarget.toUpperCase()
										var idProgress = eleTarget + '.PROGRESSDISPLAY';
										if($(idProgress)) $(idProgress).style.display = 'none';
									}
								}
							},
							flagTrustAllHosts
					);
					//end fetch file  ---------------------------------------
					//true/false -- trustAllHosts parameter
				}
				window.resolveLocalFileSystemURL(fnLocal, fileFound, fileNotFound);
			}
			if(A5.log) A5.log('Call phoneGapFileDownload_low');
			if(A5.log) A5.log(JSON.stringify(arr,'','\t'));
			for(var i = 0; i < arr.length; i++) {
				phoneGapFileDownload_low(arr,i,options)
			}
		}
		if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
		window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onError );
	}
	A5.ts = function() {
		var d = new Date()
		return d.getTime().toString(36);
}
DLG1_DlgObj.phoneGapGetFileSystemURIForLegacyPersistentStorage = function(ok,fail) {
	var _ok = ok;
	var onFSSuccess = function(fs) {
		var uri = fs.root.filesystem.root.nativeURL;
		_ok(uri);
	}
	if(!DLG1_DlgObj._isPGFileLoaded(true)) return false;
	window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, fail );
}
DLG1_DlgObj._isPGFileLoaded = function(flagShowAlert) {
	var flag = true;
	if(typeof window.requestFileSystem == 'undefined') flag =  false;
	if(typeof window.resolveLocalFileSystemURL == 'undefined') flag =  false;
	if(typeof LocalFileSystem == 'undefined') flag =  false;
	if(typeof flagShowAlert != 'undefined' && flagShowAlert && !flag) {
		alert('PhoneGap File plugin is not loaded');
	}
	return flag;
}
DLG1_DlgObj.base64DataToBlob = function(dataURI) {
	//data:image/jpeg;base64,/
	// convert base64/URLEncoded data component to raw binary data held in a string
    var byteString;
    if (dataURI.split(',')[0].indexOf('base64') >= 0)
        byteString = atob(dataURI.split(',')[1]);
    else
        byteString = unescape(dataURI.split(',')[1]);
    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
    // write the bytes of the string to a typed array
    var ia = new Uint8Array(byteString.length);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ia], {type:mimeString});
}
DLG1_DlgObj.SQLiteDownloadDatabase = function(SQLiteDBURL,localDBName,onComplete,onError,optionsIn) {
	if(SQLiteDBURL.indexOf('http://') == 0 || SQLiteDBURL.indexOf('https://') == 0) {
		//don't need to add the baseURL
	} else {
		var url = DLG1_DlgObj.ajaxURL;
		url = url.split('?')[0];
		url = url.split('/');
		url.pop();
		url = url.join('/') + '/';
		SQLiteDBURL =  url + SQLiteDBURL;
	}
	if(typeof onError != 'function') {
		onError = function(error) {
			alert('Database Download Failed. File transfer error: '+error);
		}
	}
	if(typeof _phoneGapSettings == 'undefined') {
		alert('PhoneGap not loaded');
		return false;
	}
	var flagSQL = _phoneGapSettings().plugins['cordova-sqlite-ext'];   //com.brodysoft.sqliteplugin
	flagSQL = true;
	if(typeof flagSQL == 'undefined') flagSQL = false;
	if(!flagSQL) {
		alert('SQLitePluginExt not loaded');
		return false;
	}
	////////////////////
	if(typeof optionsIn == 'undefined') {
		var ops = {
			showProgress : false,
			forceDownloadIfFileExists : true
			}
	} else {
		var ops = optionsIn
	}
	var arr = [];
	arr.push({filename: SQLiteDBURL});
	var options = {};
	options.targetFolder = '<SQLite>|' + localDBName;
	options.onComplete = function() {
		onComplete.call();
	}
	options.onError = function() { onError.call() };
	options.showProgress = ops.showProgress;
	options.forceDownloadIfFileExists = ops.forceDownloadIfFileExists;
	if(options.showProgress) {
		options.progress = ops.progress;
	}
	DLG1_DlgObj.phoneGapFileDownload(arr,options);
	///////////////////////////////////
	/*
	var thisPackageName = '';
	thisPackageName = _phoneGapSettings().appId ;
	//alert(thisPackageName)
	var localDbFileUrl = 	{
								android: '/data/data/' + thisPackageName + '/databases/' + localDBName,
								ios: 'cdvfile://localhost/persistent/' + localDBName
							};
	if(typeof device == 'undefined') {
		alert('PhoneGap required plugin not loaded: device');
	}
	var thisDevice = device.platform;
	var fileUrl = thisDevice == "Android" ? localDbFileUrl.android : localDbFileUrl.ios;
	var fileTransfer = new FileTransfer();
	var uri = encodeURI(SQLiteDBURL);
	var options = {};
	fileTransfer.download(uri,fileUrl,onComplete,onError,false,options);
	*/
}
DLG1_DlgObj.SQLiteExecuteSQLPromise = function(dbName,sql,argumentsIn) {
	var f = function(resolve,reject) {
		var obj = {};
		var _ok = function(tx,result,resultArray) {
			obj.result = result;
			obj.resultArray = resultArray;
			obj.tx = tx
			//resolve(obj);
		}
		var _fail = function(e) { };
		var _txOk = function() {
			resolve(obj)
		}
		var _txFail = function(e) {
			reject(e);
		}
		setTimeout(function() {
			DLG1_DlgObj.SQLiteExecuteSQL(dbName,sql,argumentsIn,_ok,_fail,_txOk,_txFail);
		},50);
	}
	return new Promise(f)
}
DLG1_DlgObj.SQLiteExecuteSQL = function(dbName,sql,argumentsIn,onSuccess,onError, onTransactionSuccess, onTransactionError, flagCloseDB,transObj) {
	if(typeof transObj == 'undefined') {
		transObj = {};
	}
	var flagSQLisArray = false;
	if(sql.constructor == Array) flagSQLisArray = true;
	if(typeof flagCloseDB == 'undefined') flagCloseDB = true;
	var flagCustomOnError = false;
	if(typeof DLG1_DlgObj.customWindowErrorEvents != 'undefined') flagCustomOnError = DLG1_DlgObj.customWindowErrorEvents;
	var flagSQL = _phoneGapSettings().plugins['cordova-sqlite-ext'];   //com.brodysoft.sqliteplugin
		flagSQL = true;
		if(typeof flagSQL == 'undefined') flagSQL = false;
		if(!flagSQL) {
			alert('SQLitePluginExt not loaded');
			return false;
	}
	if(typeof onSuccess == 'undefined') onSuccess = false;
	if(typeof onError == 'undefined') onError = false;
	if(typeof argumentsIn == 'undefined' || argumentsIn.constructor != Array) argumentsIn = [];
	if(onSuccess.constructor != Array)  {
		if(typeof onSuccess != 'function') {
			onSuccess = function(tx,result) {
			}
		}
	}
	if(onError.constructor != Array)  {
		if(typeof onError != 'function') {
				onError = function(e) {
				}
		}
	}
	if(typeof device == 'undefined') {
			alert('PhoneGap required plugin not loaded: device');
	}
	var flagArrayOfObjects = false;
	if(sql.constructor == Array) {
		if(sql[0].constructor == Object) {
			flagArrayOfObjects = true;
		}
	}
	if(flagArrayOfObjects) {
		var a = sql;
		delete sql;
		delete sqlObject;
		sql = [];
		sqlObject = [];
		argumentsIn = [];
		onSuccess = [];
		onError = [];
		for(var i = 0; i < a.length; i++) {
			sql[i] = a[i].sql;
			sqlObject[i] = a[i];
			if(typeof a[i].arguments != 'undefined') {
				argumentsIn[i] = a[i].arguments;
			} else {
				argumentsIn[i] = [];
			}
			if(typeof a[i].onSuccess != 'undefined') {
				onSuccess[i] = a[i].onSuccess;
			} else {
				onSuccess[i] = function() { };
			}
			if(typeof a[i].onError != 'undefined') {
				onError[i] = a[i].onError;
			} else {
				onError[i] = function() { };
			}
		}
	}
	/*
	var thisDevice = device.platform;
	//var dbFilename = thisDevice == 'Android' ? dbName:'files/' + dbName;
	var thisPackageName = '';
	thisPackageName = _phoneGapSettings().appId ;
	var localDbFileUrl = 	{
		android: '/data/data/' + thisPackageName + '/databases/' + dbName,
		ios: 'cdvfile://localhost/persistent/' + dbName
		//cdvfile://localhost/persistent/sqlite/' + localDBName
	};
	var dbFilename = thisDevice == "Android" ? localDbFileUrl.android : localDbFileUrl.ios;
	console.log('database location: ' + dbFilename);
	delete db;
	if(typeof window.sqlitePlugin == 'undefined') {
		alert('Error: PhoneGap SQLite plugin not loaded.');
	}
	var db = window.sqlitePlugin.openDatabase({name:dbFilename,location:2});
	*/
	///////////////// new code starts here/////////////
	//start here........
	var thisDevice = device.platform;
	var dbFilename = thisDevice == 'Android' ? dbName:'NoCloud/' + dbName;   //NoCloud -- no exposed to iTunes and not backed up to iCloud
	console.log('.SQLiteExecuteSQL: database location = ' + dbFilename);
	if(typeof window.sqlitePlugin == 'undefined') {
		alert('Error: PhoneGap SQLite plugin not loaded.');
	}
	var location = 'download';
	if( dbName.indexOf('root:') == 0) {
		location = 'root';
		dbName = dbName.split('root:')[1];
	}
	//this is for a db that is downloaded from the server
	if(location == 'download') {
		var db = window.sqlitePlugin.openDatabase({name:dbFilename,location:1});
	} else {
		//if the db is in the webroot (pre-populated), then use this code
		var db = window.sqlitePlugin.openDatabase({name: dbName , location: 2, createFromLocation: 1});
	}
	///// end here.....
	///////////////////new code ends here ////////////////
	db.transaction(
		function(tx) {
			if(flagSQLisArray) {
			}
			var flagArrayOfArrays = false;
			try{if(argumentsIn[0].constructor == Array) flagArrayOfArrays = true;} catch(e) {}
			if(sql.constructor == Array || flagArrayOfArrays) {
				if(sql.constructor == Array) {
					var sql_length = sql.length;
				} else {
					var sql_length = argumentsIn.length;
				}
				var i = 0;
				function _lowSQL(transObj) {
					if(sql.constructor == Array) {
						var sql_i = sql[i];
						var sqlObject_i = sqlObject[i];
					} else {
						var sql_i = sql;
					}
					var args_i = argumentsIn[i];
					if(typeof args_i != 'undefined') {
						for(var j = 0; j < args_i.length; j++) {
							if(typeof args_i[j] == 'function') {
								var result = args_i[j].call(this,transObj);
								args_i[j] = result;
							}
						}
					}
					var success_i = function(tx2,result) {
						var resultArray = DLG1_DlgObj.SQLiteResultSetToArray(result);
						if(onSuccess.constructor == Array) {
							onSuccess[i].call(this,tx2,result,resultArray,transObj);
						} else {
							onSuccess.call(this,tx2,result,resultArray,transObj);
						}
						i++;
						if(i < sql_length) {
							transObj.i = i;
							_lowSQL(transObj);
						}
					}
					var error_i = function(e) {
						if(onError.constructor == Array) {
							onError[i].call(this,e);
						} else {
							onError.call(this,e);
						}
					}
					tx.sql = sql_i;
					tx.arguments = args_i;
					tx.sqlObject = sqlObject_i;
					tx.executeSql(sql_i,args_i,success_i,error_i);
				}
				_lowSQL(transObj);
			} else {
				//single sql statement
				tx.executeSql(sql,argumentsIn,function(tx,result) {
					var resultArray = DLG1_DlgObj.SQLiteResultSetToArray(result);
					onSuccess.call(this,tx,result,resultArray);
				}, function(e) {onError.call(this,e); });
			}
		},
		function(e) { /*transaction failure*/ if(typeof onTransactionError == 'function') { onTransactionError.call(this);}; if(flagCloseDB) db.close(); },
		function() { /*transaction success*/ if(typeof onTransactionSuccess == 'function') { onTransactionSuccess.call(this);} if(flagCloseDB) db.close();  }
		//function(e) {alert('close the db1'); db.close(); /*transaction failure*/ if(typeof onTransactionError == 'function') { onTransactionError.call(this);}  },
		//function() { alert('close the db2'); db.close(function() { alert('done closing')} ); /*transaction success*/ if(typeof onTransactionSuccess == 'function') { onTransactionSuccess.call(this);}   }
		//function(e) { db.close(); /*transaction failure*/ if(typeof onTransactionError == 'function') { onTransactionError.call(this);}  },
		//function() { db.close(function() { if(typeof onTransactionSuccess == 'function') { onTransactionSuccess.call(this);}; alert('done closing')} ); /*transaction success*/   }
	);
}
////////////////////////sqlite incremental refresh
DLG1_DlgObj._sqliteApplyIncrementalUpdates = function(cbId,_onErrorFunction) {
	var obj = DLG1_DlgObj._sqliteIncrementalRefreshData;
	var sqlObj = DLG1_DlgObj.__sqliteIncrementalUpdate_computeSQL(obj);
	DLG1_DlgObj._sqliteIncrementalRefreshRowsToUpdate = sqlObj.length;
	//var msg = JSON.stringify(sqlObj,'','\t')
	//DLG1_DlgObj.debugInfoToFile(msg,'c:/bugs/sqltoexecute.txt')
	//$('pre1').innerHTML = 'sql to execute' + msg;
	if(sqlObj.length > 0) {
		var _dbName = DLG1_DlgObj._sqliteIncrementalRefreshDBName;
		var _sql = sqlObj;
		var _args = false;
		var _success = false;
		var _error = false;
		var _onTxSuccess = function() {
			if(transObj.insert.length == 0) {
				DLG1_DlgObj._sqliteIncrementalRefreshUpdateMetadata(cbId,true)
			} else {
				//run the inserts
				var sql2 = [];
				var sqlObj = transObj.insert;
				for(var i = 0; i < sqlObj.length; i++) {
					sql2.push({sql: sqlObj[i].sql2, arguments: sqlObj[i].arguments2});
				}
				DLG1_DlgObj._sqliteIncrementalRefreshRowsToInsert = sql2.length
				//get the sql to update the __metaData table, but don't run it.
				var metaDataSQL = DLG1_DlgObj._sqliteIncrementalRefreshUpdateMetadata(cbId,false);
				//add the metadata sql to the sql2 object
				for(var i = 0; i < metaDataSQL.length; i++) {
					sql2.push(metaDataSQL[i])
				}
				//var msg6 = JSON.stringify(sql2,'','\t')
				//$('pre1').innerHTML = 'combined insert and meta data sql: ' + msg6;
				//make a closure that captures the cbId
				var _generate_txOK = function(cbId) {
					var _txOK = function() {
						var cbid = cbId;
						DLG1_DlgObj._executeAjaxCallbackCompleteCode(cbid);
					}
					return _txOK
				}
				var _txOK = _generate_txOK(cbId)
				//alert('sql2 length: ' + sql2.length);
				//var msg = JSON.stringify(sql2,'','\t')
				//DLG1_DlgObj.debugInfoToFile(msg,'c:/bugs/sql2.txt')
				DLG1_DlgObj._sqliteIncrementalRefresh_ExecuteSQLCommands(_dbName,sql2,_txOK)
			}
		};
		var _onTxError = function() {
			alert('Failed to update SQLite database')
		};
		var transObj = {};
		transObj.insert = [];
		DLG1_DlgObj.SQLiteExecuteSQL(_dbName,_sql,_args,_success,_error,_onTxSuccess,_onTxError,false,transObj);
	} else {
		//there was no work to do
		DLG1_DlgObj._sqliteIncrementalRefreshRowsToUpdate = 0;
		DLG1_DlgObj._executeAjaxCallbackCompleteCode(cbId);
	}
}
DLG1_DlgObj.__sqliteIncrementalUpdate_computeSQL = function(d) {
	var obj2 = [];
	for (var i = 0; i < d.length; i++) {
		var rows = d[i].data.length;
		if(rows > 0) {
			var rows = d[i].data.length;
			if(rows > 0) {
			    for(var j = 0; j < rows; j++) {
			        var fields = [];
			        var fieldsInsert = [];
			        var fieldsInsertNotNull = [];
			        var argsInsert = [];
			        var args = [];
			        var argsInsert = [];
			        var argsInsertNotNull = [];
			        var argsNotNull = [];
			        var _d = d[i].data[j];
			        for(var n in _d) {
			            fields.push(n  + ' = ?');
			            fieldsInsert.push(n );
			            argsInsert.push('?');
			            args.push(_d[n]);
			            if(_d[n] != null) {
			            	fieldsInsertNotNull.push(n);
			            	argsNotNull.push(_d[n]);
			            	argsInsertNotNull.push('?');
			            }
			        }
			        var fieldList = fields.join(',')
			        var pk = d[i].primaryKey.split(',');
			        for(var k = 0; k < pk.length; k++) {
			            args.push(_d[pk[k]]);
			            pk[k] = pk[k] + ' = ?';
			        }
			        var pkwhere = pk.join(' and ')
			        var sql = 'UPDATE ' +  d[i].SQLiteTableName + ' SET ' + fieldList + ' WHERE ' + pkwhere;
			        var sqlInsert = 'INSERT INTO '  + d[i].SQLiteTableName + ' (' + fieldsInsert.join(',') + ' ) VALUES (' + argsInsert.join(',') + ')';
			        var sqlInsertNotNull = 'INSERT INTO '  + d[i].SQLiteTableName + ' (' + fieldsInsertNotNull.join(',') + ' ) VALUES (' + argsInsertNotNull.join(',') + ')';
//alert('sqlInsertNotNull:' + sqlInsertNotNull);
			        obj2.push(
			            {
			                sql: sql,
			                sqlInsert: sqlInsert,
			                sqlInsertNotNull: sqlInsertNotNull,
			                arguments: args,
			                argumentsNotNull: argsNotNull,
			                onSuccess: function(tx,result,resultArray, transObj) {
			                    if(result.rowsAffected == 0) {
			                    	//alert('push on tx');
			                    	//transObj.insert.push({sql2:  tx.sqlObject['sqlInsert'], arguments2: tx.arguments})
			                    	//transObj.insert.push({sql2:  tx.sqlObject['sqlInsertNotNull'], arguments2: tx.argsNotNull})
			                    	transObj.insert.push({sql2:  tx.sqlObject['sqlInsertNotNull'], arguments2: tx.sqlObject['argumentsNotNull']})
			                    	//alert('push done');
			                    }
			                },
			                onError: function(e) {
			                    alert('error: ' );
			                }
			            }
			        )
			    }
			}
		}
	}
	return obj2;
}
DLG1_DlgObj._sqliteIncrementalRefreshUpdateMetadata = function(cbid, flagExecute) {
	var md = DLG1_DlgObj._sqliteIncrementalRefreshMetaData;
	var mdstring = JSON.stringify(md);
	var _dbName = DLG1_DlgObj._sqliteIncrementalRefreshDBName;
	var _obj = [];
	_obj.push( { sql: 'DELETE FROM __metaData'}  );
	_obj.push( { sql: 'insert into __metaData (metadata) VALUES (?)', arguments: [mdstring]}  );
	var _sql = _obj;
	var _args = false;
	var _success = false;
	var _error = false;
	var _onTxSuccess = function() {
		DLG1_DlgObj._executeAjaxCallbackCompleteCode(cbid);
	};
	var _onTxError = function() {alert('Failed to update __metaDataTable')};
	if(flagExecute) {
		DLG1_DlgObj.SQLiteExecuteSQL(_dbName,_sql,_args,_success,_error,_onTxSuccess,_onTxError);
	} else {
		return _sql;
	}
}
DLG1_DlgObj._sqliteIncrementalRefresh_ExecuteSQLCommands = function(dbName,sql,_txOK, _txFailed, obj) {
	//alert('execute sql commands');
	if(typeof _txOK == 'function') { _onTxSuccess = _txOK;} else { 	_onTxSuccess = function() { alert('txok'); }};
	if(typeof _txFailed == 'function') {  _onTxError = _txFailed;} else { _onTxError = function() {
		alert('txfailed');
		//alert('sql to execute: ' + JSON.stringify(sql));
	}};
	DLG1_DlgObj.SQLiteExecuteSQL(dbName,sql,false,false,false,_onTxSuccess,_onTxError);
}
//////////////////////end sqlite incrmental refresh
DLG1_DlgObj.SQLiteResultSetToArray = function(result) {
	var array = [];
	if (result !=null && result.rows != null){
		for (var i = 0; i < result.rows.length; i++) {
			array.push(result.rows.item(i));
		}
	}
	return array;
}
DLG1_DlgObj.SQLiteDeleteDatabase = function(dbName,successCB,errorCB,location) {
	var flagSQL = _phoneGapSettings().plugins['cordova-sqlite-ext'];   //com.brodysoft.sqliteplugin
		flagSQL = true;
		if(typeof flagSQL == 'undefined') flagSQL = false;
		if(!flagSQL) {
			alert('SQLitePluginExt not loaded');
			return false;
	}
	/*
	if(typeof location == 'undefined') location = 2;
	*/
	///// new code /////
	if(typeof location == 'undefined') location = 1;
	///// end new code /////
	window.sqlitePlugin.deleteDatabase({name: dbName, location: location}, successCB, errorCB);
}
////////////////////////////////////////
DLG1_DlgObj.submitListDataAndMediaFiles = function(listName,xbCallbackFunction,ajaxObject,mediaFileUploadObject) {
	//first, upload media files, then upload dirty records in a list and then call xbCallbackFunction on the server side. Uploaded data will be in e._listData in the Xbasic function
	/*
	Example syntax:
	var ajaxObject = {
		errorFunction: function() { alert('failed ajax'); },
		onComplete: function() { alert('ajax done');},
		deviceOfflineFunction: function() { alert('offline ');  }
	}
	var objUpload = {
		target: 'alphaanywhere',
		showProgress: true,
		onComplete: function(array) {},
		onMediaUploadErrors: function(array) { alert('there were media upload errors');},
		xbasicAfterFileUploaded: 'xbAfterUpload',
		progress: {
			color: '#9fa1e8',
			width: '300px',
			individualProgress: false,
			showTotalProgress: true,
			allowCancel: false,
			progressElement: 'DLG1.V.R1.PLACEHOLDER_2'
		}
	}
	//to upload to s3
	target: 's3',
		s3: {
			connectionString: 'alphamediacapture',
			protectedRead: false,
			template: 'https://alphamediacapture.s3.amazonaws.com/__name__'
	},
	///////
	DLG1_DlgObj.submitListDataAndMediaFiles('list1',xbName,ajaxObject,objUpload);
	*/
	var lObj = DLG1_DlgObj.getControl(listName);
	if(!lObj) return false;
	var objAjax = {};
	if(typeof arguments[2] == 'object') objAjax = arguments[2];
	var objUpload = {};
	if(typeof arguments[3] == 'object') objUpload = arguments[3]; //this is the object that defines the upload target (s3/alphaanywhere), showProgress, etc
	var _userOnComplete = objUpload.onComplete;
	objUpload.onComplete = function(array) {
		_userOnComplete.call(this,array)
		pushRemoteMediaNamesToArray(array,_data);
	}
	var xbasicFunction = xbCallbackFunction;
	//define local functions
	var _ajaxUpload = function(data,xbasicFunction,objAjax) {
		var listData = JSON.stringify(data,'','\t');
		listData = A5.ajax.buildURLParam('_listData',listData);
		DLG1_DlgObj.ajaxCallback('','',xbasicFunction,'',listData, objAjax);
	}
	var pushRemoteMediaNamesToArray = function(mediaFiles,_data) {
		var _data2 = [];
		$u.o.assign(_data2,_data);
		//media files have been uploaded and the mediaFiles[] array has these properties of interest
		//listFieldName -- name of the field in the data array that had the media field
		//route -- an array that looks like [{table: '_top_', row: 1}]
		//remoteName -- the name of the alpha server or s3
		//succeeded
		var r = '';
		var table = '';
		var _di = '';
		var _diTop = '';
		for(var i = 0; i < mediaFiles.length; i++) {
			mediaFiles[i].routeObj = JSON.parse(mediaFiles[i].route);
			r = mediaFiles[i].routeObj[0].row
			for(var j = 0; j < mediaFiles[i].routeObj.length; j ++) {
				table = mediaFiles[i].routeObj[j].table;
				r = mediaFiles[i].routeObj[j].row
				if(table == '_top_') {
					_di = _data2[r];
					_diTop = _di;
				} else {
					_di = _di[table][r];
				}
			}
			if(typeof _di != 'undefined') {
				//need to add a check to see if the success flag is true
				if(mediaFiles[i].succeeded) {
					 _di[mediaFiles[i].listFieldName] = mediaFiles[i].remoteName;
				} else {
					_diTop.__flagHasMediaFileUploadError = true;
				}
			}
		}
		//harvest rows that are dirty and also do not have media upload errors - these rows will be pushed to the server
		var _data3 = [];
		var _mErr = [];
		var flagPush = false;
		var flagHasMediaUploadError = false;
		for(var i = 0; i < _data2.length; i++) {
			flagPush = true;
			if(typeof _data2[i].__flagHasMediaFileUploadError != 'undefined' && _data2[i].__flagHasMediaFileUploadError) {
				flagPush = false;
				flagHasMediaUploadError = true;
				_mErr.push(_data2[i]);
			}
			if(flagPush) {
				if(typeof _data2[i]._isDirty == 'undefined') {
					flagPush = false;
				} else if(_data2[i]._isDirty == false) {
					flagPush = false;
				}
			}
			if(flagPush) {
				_data3.push(_data2[i]);
			}
		}
		if(flagHasMediaUploadError) {
			if(typeof objUpload.onMediaUploadErrors == 'function') {
				objUpload.onMediaUploadErrors.call(this,_mErr);
			}
		}
		_ajaxUpload(_data3,xbasicFunction,objAjax) //do the ajax callback to upload the fixed data array
	}
	//end local functions
	var _data = lObj.harvestList();
	if(_data.length == 0) {
		return false;
	}
	var arr = lObj._harvestMediaFields();
	if(arr.length == 0) {
		//no media fields -- just make the ajax callback
		_ajaxUpload(_data,xbasicFunction,objAjax);
		return true;
	} else {
		//upload the media files -- the onComplete event will make the ajax callback
		//objUpload._dataToUpload = _data;
		_data = lObj._data;
		DLG1_DlgObj.phoneGapFileUpload(arr,objUpload);
	}
}
// File manipulation
//
// DLG1_DlgObj.phoneGapFilesAvailable()
//
// Returns true if there is a local file system and PhoneGap is running.
//
DLG1_DlgObj.phoneGapFilesAvailable = function() {
   if(typeof LocalFileSystem == 'undefined') {
      if(typeof cordova == 'undefined') {
         return false;
      }
      return false;
   }
   return true;
}
//
// DLG1_DlgObj.phoneGapGetLocalDirURL(type)
//
// type: "temp", "private", "saved", "public"
// On iOS, saved and public may be backed up to iCloud
//
// Returns URL of base for the requested part of the file system.
//
DLG1_DlgObj.phoneGapGetLocalDirURL = function(type) {
   var dir = "";
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) return dir;
   if (type.toLowerCase().indexOf('explicit:') == 0) {
   		var dir = type.substring('explicit:'.length)
   		return dir;
   }
   if (device.platform == 'iOS') {
      switch (type) {
         case "temp":
            dir = cordova.file.tempDirectory;
            break;
         case "private":
            dir = cordova.file.dataDirectory;
            break;
         case "saved":
            dir = cordova.file.syncedDataDirectory;
            break;
         case "public":
            dir = cordova.file.documentsDirectory;
            break;
         case "persistent": //original file system actions
          	dir = cordova.file.dataDirectory.replace('NoCloud','files');
          	break;
      }
   }
   else {
      switch (type) {
         case "temp":
            dir = cordova.file.externalCacheDirectory || cordova.file.cacheDirectory;
            break;
         case "private":
            dir = cordova.file.externalDataDirectory || cordova.file.dataDirectory;
            break;
         case "saved":
            dir = cordova.file.externalDataDirectory || cordova.file.dataDirectory;
            break;
         case "public":
            dir = cordova.file.externalDataDirectory || cordova.file.dataDirectory;
            break;
         case "persistent":
          	dir = 'file:///data/user/0/'+_phoneGapSettings().appId+'/files/files/';
          	break;
      }
   }
   return dir;
}
//
// DLG1_DlgObj.phoneGapReadFileURL(filepath, onReadSuccess, onError, startAt, endAt)
//
// filepath is the local file URL of the desired file.
// If startAt and endAt are present, returns just those positions in the file.
//
// onReadSuccess(result) returns the contents read.
//
DLG1_DlgObj.phoneGapReadFileURL = function(filepath, onReadSuccess, onError, startAt, endAt) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var pos = filepath.lastIndexOf("/");
   var dirpath = filepath.substring(0,pos);
   var filename = filepath.slice(pos+1);
   var onResolvedURL =
      function(fsEntry) {
         var onGotFile =
            function(fileEntry) {
               var doReadFunction =
                  function(file) {
                     var reader = new FileReader();
                     reader.onloadend =
                        function(e) {
                           onReadSuccess(this.result);
                        };
                     if (typeof startAt=='undefined' || typeof endAt=='undefined') {
                        reader.readAsText(file);
                     }
                     else {
                        var blob = file.slice(startAt, endAt);
                        reader.readAsText(blob);
                     }
                  };
               fileEntry.file(doReadFunction);
            };
         fsEntry.getFile(filename, {}, onGotFile, onError);
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapWriteFileURL(filepath, text, onWriteSuccess, onError, append)
//
// filepath is the local file URL of the desired file. The directory must
// exist, but the file need not.
// If append is true, appends to current contents.
// Truncates (if file existed) to end of what is written.
//
DLG1_DlgObj.phoneGapWriteFileURL = function(filepath, text, onWriteSuccess, onError, append) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var pos = filepath.lastIndexOf("/");
   var dirpath = filepath.substring(0,pos);
   var filename = filepath.slice(pos+1);
   var onResolvedURL =
      function(fsEntry) {
         var onGotFile =
            function(fileEntry) {
               var writerFunction =
                  function(fileWriter) {
                     fileWriter.onwriteend =
                        function(e) {
                           onWriteSuccess();
                        };
                     fileWriter.onerror = onError;
                     if (append) {
                        fileWriter.seek(fileWriter.length);
                     }
                     var blob = new Blob([text], {type:'text/plain'});
                     fileWriter.write(blob);
                  };
               fileEntry.createWriter(writerFunction, onError);
            };
         fsEntry.getFile(filename, {create: true}, onGotFile, onError);
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapFileExistsURLfilepath, onResult, onError)
//
// filepath is the local file URL of the desired file.
// onResult(properties) will be called with false if file does not exist.
// If file does exist, properties will be:
//
//    {
//       name:file's name,
//       lastModifiedDate:lastModifiedDate object,
//       size:size in bytes,
//       type:MIME type if known(not on iOS now, but yes on Android)
//    }
//
DLG1_DlgObj.phoneGapFileExistsURL = function(filepath, onResult, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var pos = filepath.lastIndexOf("/");
   var dirpath = filepath.substring(0,pos);
   var filename = filepath.slice(pos+1);
   var onResolvedURL =
      function(fsEntry) {
         var onGotFile =
            function(fileEntry) {
               fileEntry.file(function(fileObj) {
                  onResult({name:fileObj.name, lastModifiedDate:fileObj.lastModifiedDate,
                     size:fileObj.size, type:fileObj.type});
                  },
                  onError);
            };
         var onDidNotGetFile =
            function() {
               onResult(false);
            };
         fsEntry.getFile(filename, {create: false}, onGotFile, onDidNotGetFile);
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapDeleteFileURL(filepath, onDeleteSuccess, onError)
//
// filepath is the local file URL of the file to be deleted.
//
DLG1_DlgObj.phoneGapDeleteFileURL = function(filepath, onDeleteSuccess, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var pos = filepath.lastIndexOf("/");
   var dirpath = filepath.substring(0,pos);
   var filename = filepath.slice(pos+1);
   var onResolvedURL =
      function(fsEntry) {
         var onGotFile =
            function(fileEntry) {
               fileEntry.remove(onDeleteSuccess, onError);
            };
         fsEntry.getFile(filename, {create: false}, onGotFile, onError);
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapCopyFileURL(srcpath, destdirpath, destname, onCopySuccess, onError)
//
// srcpath is the local file URL of the file to be copied.
// destdirpath is the URL of the directory into which to copy the file.
// destname is the name to be given to the copied file. If null, the source filename will be used.
//
DLG1_DlgObj.phoneGapCopyFileURL = function(srcpath, destdirpath, destname, onCopySuccess, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var pos = srcpath.lastIndexOf("/");
   var dirpath = srcpath.substring(0,pos);
   var filename = srcpath.slice(pos+1);
   var onResolvedURL =
      function(fsEntry) {
         var onGotFile =
            function(fileEntry) {
               window.resolveLocalFileSystemURL(destdirpath,
                  function(destDirEntry) {
                     fileEntry.copyTo(destDirEntry, destname, onCopySuccess, onError);
                  },
                  onError);
            };
         fsEntry.getFile(filename, {}, onGotFile, onError);
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapMoveFileURL(srcpath, destdirpath, destname, onMoveSuccess, onError)
//
// srcpath is the local file URL of the file to be moved.
// destdirpath is the URL of the directory into which to move the file, replacing any existing file with the name.
// destname is the name to be given to the copied file. If null, the source filename will be used.
// If moved into the same directory, the file will be renamed.
// A move of a directory on top of an existing empty directory replaces that directory.
//
DLG1_DlgObj.phoneGapMoveFileURL = function(srcpath, destdirpath, destname, onMoveSuccess, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var pos = srcpath.lastIndexOf("/");
   var dirpath = srcpath.substring(0,pos);
   var filename = srcpath.slice(pos+1);
   var onResolvedURL =
      function(fsEntry) {
         var onGotFile =
            function(fileEntry) {
               window.resolveLocalFileSystemURL(destdirpath,
                  function(destDirEntry) {
                     fileEntry.moveTo(destDirEntry, destname, onMoveSuccess, onError);
                  },
                  onError);
            };
         fsEntry.getFile(filename, {}, onGotFile, onError); //does not work on moving directories
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(dirpath, onRemoveSuccess, onError)
//
// dirpath is the file URL of the directory to be deleted.
// Deletes the specified directory and all of its contents, including other directories and
// their contents.
//
DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL = function(dirpath, onRemoveSuccess, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var onResolvedURL =
      function(dirEntry) {
         dirEntry.removeRecursively(onRemoveSuccess, onError);
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapEnsureDirPathURL(rootpath, subdirpath, onCompletion, onError)
//
// rootpath is the file URL of the existing directory that will contain the directories that are needed.
// subdirpath is a path of directories to ensure exist below rootpath. They will be created
// if they don't exist.
//
// For example, if rootpath is "file://root/public/", subdirpath may be "toplevel/subdir1".
//
DLG1_DlgObj.phoneGapEnsureDirPathURL = function(rootpath, subdirpath, onCompletion, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var dirs = subdirpath.split('/') || [];
   var onResolvedURL =
      function(fsEntry) {
         var ensureDirFunction =
            function(dirEntry) { // function to recurse
               if (dirs.length>0) {
                  if (dirs[0]=='.' || dirs[0]=='') {
                     dirs = dirs.slice(1); // remove null dir
                  }
               }
               if (dirs.length==0) {
                  onCompletion();
                  return;
               }
               dirEntry.getDirectory(dirs[0], {create: true},
                  function(subdirEntry) {
                     dirs = dirs.slice(1); // do next
                     ensureDirFunction(subdirEntry);
                  },
                  onError);
               };
         ensureDirFunction(fsEntry); // do first
      };
   window.resolveLocalFileSystemURL(rootpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapListFilesRecurseURL(rootpath, onCompletion, onError)
//
// rootpath is the file URL of the directory whose contents will be listed.
// onCompletion(filelist) will contain an array of strings representing each file
// and directory down the hierarchy. Directories end in "/".
//
DLG1_DlgObj.phoneGapListFilesRecurseURL = function(rootpath, onCompletion, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var filelist = [];
   var pathprefix = "";
   var pending = 0;
   var onResolvedURL =
      function(fsEntry) {
         var processDirFunction =
            function(subdirpath, listingObj) {
               var files = listingObj.files;
               var i;
               var fpath;
               var prefix = subdirpath.slice(pathprefix.length);
               for (i=0; i<files.length; i++) {
                  fpath = prefix+files[i];
                  filelist.push(fpath);
               }
               var dirs = listingObj.dirs;
               if (dirs.length==0) {
                  if (pending==0) {
                     onCompletion(filelist);
                  }
                  return;
               }
               for (i=0; i<dirs.length; i++) {
                  fpath = dirs[i].fullPath.slice(pathprefix.length);
                  filelist.push(fpath);
                  pending++;
                  dirs[i].filesystem.root.getDirectory(dirs[i].fullPath, {create: false},
                     function(dirEntry) {
                        listDirFunction(dirEntry);
                     },
                     function(e){pending--;onError(e);});
               }
            };
         var listDirFunction =
            function(dirEntry) { // function to recurse on subdirs
               var dirReader = dirEntry.createReader();
               var listingObj = {files:[], dirs:[]};
               var readDirEntries = function() {
                  dirReader.readEntries( // start an async reading of entries
                     function(entries) { // more entries read, or done
                        if (!entries || entries.length==0) {
                           pending--;
                           processDirFunction(dirEntry.fullPath, listingObj);
                           return;
                        }
                        var entry;
                        for (var i=0; i<entries.length; i++) {
                           entry = entries[i];
                           if (entry.isFile) {
                              listingObj.files.push(entry.name);
                           }
                           else {
                              listingObj.dirs.push(entry);
                           }
                        }
                        readDirEntries(); // recurse to call dirReader.readEntries again
                     },
                     onError);
                  };
               readDirEntries(); // do first reading of entries
            };
         pending++;
         pathprefix = fsEntry.fullPath; // get prefix
         listDirFunction(fsEntry); // do first list getting
      };
   window.resolveLocalFileSystemURL(rootpath, onResolvedURL, onError);
}
//
// DLG1_DlgObj.phoneGapListFilesURL(dirpath, matchRegex, onCompletion, onError)
//
// dirpath is the file URL of the directory whose contents will be listed (only files).
// matchRegex, if non-null, will need to match file names found for them to be listed.
// onCompletion(filelist) will contain an array of strings representing each file.
//
DLG1_DlgObj.phoneGapListFilesURL = function(dirpath, matchRegex, onCompletion, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var onResolvedURL =
      function(fsEntry) {
         var filelist = [];
         var dirReader = fsEntry.createReader();
         var readEntriesFunction =
            function() { // function to recurse to call repeatedly after each completion until no result
               dirReader.readEntries( // start an async reading of entries
                  function(entries) { // more entries read, or done
                     if (!entries || entries.length==0) {
                        onCompletion(filelist);
                        return;
                     }
                     var name;
                     for (var i=0; i<entries.length; i++) {
                        name = entries[i].name;
                        if (!matchRegex || name.match(matchRegex)) {
                           filelist.push(name);
                        }
                     }
                     readEntriesFunction(); // recurse to call dirReader.readEntries again
                  },
                  onError);
               };
         readEntriesFunction(); // do first reading
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
DLG1_DlgObj.getSQLiteFolder = function(mode) {
	if(typeof mode == 'undefined') mode = 0;
	var thisPackageName = '';
	thisPackageName = _phoneGapSettings().appId ;
	var localDbFileUrl = {
		android: '/data/data/' + thisPackageName + '/databases/',
		android1: 'file:///data/data/' + thisPackageName + '/databases/',
		android2: 'file:///data/data/' + thisPackageName,
		ios: cordova.file.dataDirectory
	};
	try{
		var thisDevice = device.platform.toLowerCase();
		if(mode == 1 && thisDevice == 'android') thisDevice = 'android1';
		if(mode == 2 && thisDevice == 'android') thisDevice = 'android2';
		var _targetDir = localDbFileUrl[thisDevice];
		return _targetDir;
	}catch(e) {
		alert('PhoneGap \'device\' Plugin not loaded');
	}
}
DLG1_DlgObj.phoneGapUnzipSQLite =  function(explicitFileName,filesystemSource,folderSource,zipFileName,dirStructureTarget,ok,fail) {
	if(typeof explicitFileName == 'undefined' || explicitFileName == '') {
		var baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL(filesystemSource)
		var fnSource = baseURI + folderSource + '/' + zipFileName;
	} else {
		var fnSource = explicitFileName;
		var fn = fnSource
		fn = fn.split('/');
		zipFileName = fn[fn.length-1];
	}
	var baseURITarget = DLG1_DlgObj.getSQLiteFolder(1);
	var dirTarget = baseURITarget + dirStructureTarget;
	var cb = function(e) {
		if(e == 0) {
			ok.call(this);
		}
		else fail.call(this);
	}
	zip.unzip(fnSource, dirTarget, cb );
}
DLG1_DlgObj.copySQLiteDB = function(explicitFilename,sourceFileSystem,sourceFolder,sourceDBName,targetDBName,targetFolder, onSuccess, onError) {
		if(typeof onSuccess == 'undefined') onSuccess = function() { };
		if(typeof onError == 'undefined') onError = function() { }
		var _copyLow = function() {
			var localDBName = targetDBName;
			if (targetFolder != '') {
				localDBName = targetFolder + '___' + targetDBName;
			}
			if(typeof explicitFilename == 'undefined' || explicitFilename == '') {
				var fnSource = DLG1_DlgObj.phoneGapGetLocalDirURL(sourceFileSystem) + sourceFolder + '/' + sourceDBName;
			} else {
				var fnSource = explicitFilename;
			}
			var fnTarget = DLG1_DlgObj.getSQLiteFolder(1) +  localDBName;
			//alert('fnsource: ' + fnSource +'\nfntarget: ' + fnTarget);
			// '/data/data/' + thisPackageName + '/databases/',
			var _onCopySuccess = function() {
				//alert('sqlite copy success: ' + 5)
				onSuccess.call(this);
				if(sourceFolder == 'tempFolder/zipfiles') {
					//delete this folder. this is where the sqlitedb zip file was unzipped
					var _onRemoveSuccess = function() { /* alert('tempFolder/zipfiles was deleted'); */};
					var _error = function(e) { /*alert('could not delete the tempFolder/zipfiles folder');*/	};
					var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
					var _dirName = 'tempFolder/zipfiles/';;
					var _dirPath = _baseURI + _dirName;
					DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(_dirPath, _onRemoveSuccess, _error);
				}
			};
			var _onCopyError = function(e) {
				alert('sqlite copy error:' + JSON.stringify(e));
				onError.call(this);
			};
			var _onDeleteSuccess = function() {
				var folderTarget = DLG1_DlgObj.getSQLiteFolder(1) ;
				//alert(fnSource);
				//alert(folderTarget);
				//alert('about to copy: ' + localDBName);
				DLG1_DlgObj.phoneGapCopyFileURL(fnSource,folderTarget, localDBName, _onCopySuccess, _onCopyError);
			};
			var _onDeleteError = _onDeleteSuccess;
			//alert('delete what: ' + fnTarget)
			DLG1_DlgObj.phoneGapDeleteFileURL(fnTarget, _onDeleteSuccess,_onDeleteError);
		}
		if(targetFolder != '') {
			var onFolderCreated = function() {   _copyLow();}
			var onFolderCreatedFailed = function(e) { alert('SQLite folder not created');  onError.call()}
			var _base = DLG1_DlgObj.getSQLiteFolder(2); //add file:// and omit trailing 'databases' folder
			var targetx;
			var thisPackageName = '';
			thisPackageName = _phoneGapSettings().appId ;
			if(thisPackageName.toLowerCase() == 'android') {
				targetx = 'databases/' + targetFolder;
				targetx = 'databases/'
			} else {
				targetx = targetFolder;
				targetx = '/';
			}
			DLG1_DlgObj.phoneGapEnsureDirPathURL(_base,targetx, onFolderCreated, onFolderCreatedFailed);
		} else {
			_copyLow()
		}
}
DLG1_DlgObj.phoneGapUnzipFiles =  function(explicitFileName,filesystemSource,folderSource,zipFileName,fileSystemTarget, dirStructureTarget,ok,fail,flagListUnzippedFiles) {
	if(typeof ok == 'undefined') ok = function() { };
	if(typeof fail == 'undefined') fail = function() { };
	var _listFileThatWereUnzipped = function() {
		 var _onSuccess = function(filelist) {
			ok.call(this,filelist);
			//remove the tempUnzipFolder, but do not trigger the follow on function to unzip to the tempUnzipFolder
			_removeTempUnzipFolder('',2);
		};
		var _error = function(e) { alert('error');};
		var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
		var _dirName = 'tempUnzipFolder/';;
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapListFilesRecurseURL(_dirPath, _onSuccess, _error);
	}
	var _removeTempUnzipFolder = function(fnSource,mode) {
		if(typeof mode == 'undefined') mode = 1;
		var _onRemoveSuccess = function() { if(mode == 1) _listUnzippedFiles(fnSource);};
		var _error = function(e) { if(mode == 1) _listUnzippedFiles(fnSource);};
		var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
		var _dirName = 'tempUnzipFolder/';;
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(_dirPath, _onRemoveSuccess, _error);
	}
	var _listUnzippedFiles = function(fnSource) {
		var baseURITarget =  DLG1_DlgObj.phoneGapGetLocalDirURL('temp')
		var cb = function(e) {
			if(e == 0) {
				_listFileThatWereUnzipped();
			} else {
				//could not unzip to the tempUnzipFolder -- should be unlikely
				ok.call(this,[]);
			}
		}
		zip.unzip(fnSource,baseURITarget + 'tempUnzipFolder',cb)
	}
	if(typeof explicitFileName == 'undefined' || explicitFileName == '') {
		var baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL(filesystemSource)
		var fnSource = baseURI + folderSource + '/' + zipFileName;
	} else {
		var fnSource = explicitFileName;
	}
	var baseURITarget = DLG1_DlgObj.phoneGapGetLocalDirURL(fileSystemTarget)
	var dirTarget = baseURITarget + dirStructureTarget
	var cb = function(e) {
		if(e == 0) {
			if(flagListUnzippedFiles) {
				//this function will call the follow on functions to unzip to the tempUnzipFolder
				_removeTempUnzipFolder(fnSource)
			} else {
				ok.call(this);
			}
		}
		else {
			//alert('in unzip: ' + e); sr55
			fail.call(this);
		}
	}
	if(typeof zip == 'undefined') {
		alert('FATAL ERROR - Cordova Zip plugin not loaded');
	}
	zip.unzip(fnSource, dirTarget, cb );
}
/*
DLG1_DlgObj.phoneGapUnzipSQLiteDB = function(explicitFileName,filesystemSource,folderSource,zipName,account,onCopyOK,onCopyError) {
	//unzips a .zip file that contains one (only 1) sqlite.db file and copies file to the sqlite folder
	var _copyLow = function(sqliteDBSource,account,onCopyOK,onCopyError) {
		var sourceFileSystem = 'temp';
		sourceFolder = 'tempFolder/zipfiles';
		sourceDBName = sqliteDBSource;
		targetDBName = sqliteDBSource;
		targetFolder = account;
		DLG1_DlgObj.copySQLiteDB(sourceFileSystem,sourceFolder,sourceDBName,targetDBName,targetFolder, onCopyOK, onCopyError)
	}
	var flagListUnzippedFiles = true;
	var okUnzip = function(fileArray) {
		alert(JSON.stringify(fileArray,'','\t'));
		if(fileArray.length > 1) {
			alert('zip file caon only contain one SQLite database which must not be in a sub-folder.');
		} else {
			var sqliteDBSource = fileArray[0];
			alert('dirPath: ' + dirPath);
			_copyLow(sqliteDBSource,account,onCopyOK,onCopyError)
		}
	 };
	var failUnzip = function() { alert('fail');}
	var dirPath = 'tempFolder/zipfiles'
	DLG1_DlgObj.phoneGapUnzipFiles(explicitFileName,filesystemSource,folderSource,zipName,'temp', dirPath,okUnzip,failUnzip,flagListUnzippedFiles)
}
*/
DLG1_DlgObj.phoneGapDownloadManifestFiles = function(manifest,folder,cbAllDone,optionsIn,fileSystemPart,flagMoveSQLiteFiles,manifestName) {
	////////////////////////////////////////////////////////
	function storeManifest(string,name) {
		//'transFormOnDeviceManifest'
		if(manifestName == '') {
			localStorage.setItem('transFormOnDeviceManifest',string);
			return;
		} else {
			var manifestObj = DLG1_DlgObj.__getManifestObj();
			manifestObj[name] = string;
			localStorage.manifests = JSON.stringify(manifestObj);
		}
	}
	function getManifest(name) {
		//'transFormOnDeviceManifest'
		if(manifestName == '') return localStorage.getItem('transFormOnDeviceManifest');
		else {
			var manifestObj = DLG1_DlgObj.__getManifestObj();
			var m = manifestObj[name];
			return m;
			//return JSON.stringify(manifestObj[name]);
		}
	}
	function getManifestStorageLocation(manifestName) {
		//'transFormFileSystemPart'
		if(manifestName == ''|| true) return localStorage.getItem('transFormFileSystemPart')
	}
	function setManifestStorageLocation(string,manifestName) {
		//'transFormFileSystemPart'
		if(manifestName == '' || true) localStorage.setItem('transFormFileSystemPart',string);
	}
	//var storedWhere = localStorage.getItem('transFormFileSystemPart');
	//var storedWhere = getManifestStorageLocation(manifestName);
	//localStorage.setItem('transFormFileSystemPart',_string);
	//setManifestStorageLocation(_string,manifestName);
	//localStorage.setItem('transFormOnDeviceManifest',json);
	//storeManifest(json,manifestName)
	//localStorage.transFormOnDeviceManifest = m;
	//storeManifest(m,manifestName);
	//var oldManifest = localStorage.getItem('transFormOnDeviceManifest');
	//var oldManifest = getManifest(manifestName);
	//var m = localStorage.transFormOnDeviceManifest;
	//var m = getManifest(manifestName);
	/////////////////////////////////////////////////////////
	if(typeof manifestName == 'undefined') manifestName = '';
	var obj = DLG1_DlgObj.__getManifestObj('manifestInfo');
	var manifestName2 = manifestName
	if(manifestName2 == '') manifestName2 = '___default___';
	if(typeof obj[manifestName2] =='undefined') obj[manifestName2] = {};
	obj[manifestName2].folder = folder =  folder ;
	obj[manifestName2].fileSystemPart = fileSystemPart
	var json = JSON.stringify(obj)
	localStorage.setItem('manifestInfo',json)
if(typeof flagMoveSQLiteFiles == 'undefined') flagMoveSQLiteFiles = true;
	/*
	usage:
	if 'informationOnly' is set to true, the cb function is called with arr.mode = 'informationOnly' and arr.array set to the manifest of files that need to be downloaded
	var opsIn = {
		informationOnly: false,
		showProgress: true,
		progress: {
			xcolor: '#9fa1e8',
			color: 'green',
			width: '600px',
			progressElement: 'DLG1.V.R1.PLACEHOLDER_1'
		}
	}
	var cb = function(arr) {
		if(typeof arr.mode != 'undefined') {
				if(arr.mode == 'informationOnly') {
					alert('Number of files to download: ' + arr.array.length);
					return;
				}
		}
		alert('post process is now COMPLETE: items - ' + arr.array.length);
	};
	//url can also be an http::// or https:// address or an array of objects
		var url = '';
		url = [
					{
						url: 'http://alphamediacapture.s3.amazonaws.com/transform/SQLiteNorthwind.zip',
						type: 'sqlite',
						version: 1,
						size: 70900
					},
					{
						url: 'http://alphamediacapture.s3.amazonaws.com/transform/sqlite3.db',
						type: 'sqlite',
						version: 1,
						size: 7000
					},
					{
						url: 'http://alphamediacapture.s3.amazonaws.com/transform/allimages.zip',
						type: 'folder',
						zipped: true,
						targetFolder: 'transFormShortFileList',
						version: 1,
						size: 56900
					}
		]
	var url = 'http://alphamediacapture.s3.amazonaws.com/transform/transformManifest.json';
	DLG1_DlgObj.phoneGapDownloadManifestFiles(url,'account1',cb,opsIn)
	*/
	var computeNewManifest = function(oldManifestJSON,manifest, accountId) {
		try{
			var om = JSON.parse(oldManifestJSON);
			om = om[accountId];
			if(typeof om == 'undefined' || om == null) {
				return manifest;
			}
			var arr = manifest;
			var totalSize = 0;
			for(var i = 0; i < arr.length; i++) {
				arr[i].mustFetch = true;
				var url = arr[i].url;
				var type = arr[i].type;
				for(var j = 0; j < om.length; j++) {
					if(om[j].url == url && om[j].type == type) {
						var oldVersion = om[j].version;
						if(typeof oldVersion == 'undefined') oldVersion = -1;
						if(typeof oldVersion == 'number') {
							var newVersion = arr[i].version;
							if(typeof newVersion == 'undefined') newVersion = -1;
							if(typeof newVersion == 'number') {
								if(newVersion <= oldVersion) {
									arr[i].mustFetch = false;
								} else {
									//alert('must fetch: ' + i);
									if(typeof arr[i].size != 'undefined') totalSize = totalSize + arr[i].size;
								}
							}
						}
					}
				}
			}
			var count = 0;
			var arr2 = [];
			for(var i = 0; i < arr.length; i++) {
				if(arr[i].mustFetch) {
					count++;
					arr2.push(arr[i])
				}
			}
			//if optionsIn says information only then we can do the callback function here, passing in the arr2 array
			//alert('count must fetch: ' + count +  ' total size: ' + totalSize);
			return arr2;
		}catch(err) {
			return manifest;
		}
	}
	var flagExplicit = false;
	if(typeof fileSystemPart == 'undefined') fileSystemPart = 'saved';
	if(fileSystemPart.toLowerCase().indexOf('explicit:') == 0) {
		fileSystemPart = fileSystemPart.substr('explicit:'.length);
		flagExplicit = true;
	}
	//var storedWhere = localStorage.getItem('transFormFileSystemPart');
	var storedWhere = getManifestStorageLocation(manifestName);
	var obj = {}
	if(storedWhere == null) {
		obj[folder] = fileSystemPart;
	} else {
		try{
			obj = JSON.parse(storedWhere)
			obj[folder] = fileSystemPart;
		}catch(e) {
			obj[folder] = fileSystemPart;
		}
	}
	var _string = JSON.stringify(obj);
	//localStorage.setItem('transFormFileSystemPart',_string);
	setManifestStorageLocation(_string,manifestName);
	var accountId = folder;
	var fetchManifest = function(url) {
	var onOK = function(data) {
		try{
			var arr = JSON.parse(data);
			DLG1_DlgObj.phoneGapDownloadManifestFiles(arr,accountId,cbAllDone,optionsIn,fileSystemPart,flagMoveSQLiteFiles,manifestName);
		}catch(e) {
			//alert('Error - could not read the TransForm manifest file.' + JSON.stringify(e));
			var cbObj = {error: true, errorText: 'Could not read the manifest file.'};
			cbAllDone.call(this,cbObj);
			}
		}
		var onFail = function() {
			//alert('Error - Could not download the TransForm manifest file.');
			var cbObj = {error: true, errorText: 'Could not download the manifest file.'};
			cbAllDone.call(this,cbObj);
		}
		DLG1_DlgObj.httpFetch(url,onOK,onFail,[{name:"cache-control",value:"no-cache"}]);
	}
	if(typeof manifest == 'function') {
		manifest = manifest.call()
	}
	if(typeof manifest == 'string') {
		fetchManifest(manifest);
		return;
	}
	//var oldManifest = localStorage.getItem('transFormOnDeviceManifest');
	//debugger;
	var oldManifest = getManifest(manifestName);
	var obj = {};
	var newManifest = manifest;
	if(oldManifest != null) {
		var newManifest = computeNewManifest(oldManifest,manifest,folder);
	} else {
		if(manifest.constructor != Array) {
			obj = JSON.parse(manifest);
		}
	}
	obj[folder] = manifest;
	var json = JSON.stringify(obj);
	var flagInformationOnly = false;
	if(typeof optionsIn.informationOnly != 'undefined') {
		if(optionsIn.informationOnly) {
			flagInformationOnly = true;
		}
	}
	if (!flagInformationOnly) {
		//localStorage.setItem('transFormOnDeviceManifest',json);
		storeManifest(json,manifestName)
	}
	manifest = newManifest;
	if(flagInformationOnly) {
		var objCB = {error: false, array: manifest, accountId: accountId, mode: 'informationOnly'}
		cbAllDone.call(this,objCB);
		return;
	}
	if(manifest.length == 0) {
		var objCB = {error: false, array: manifest, accountId: accountId, arrayFilesRelative: [], arrayFiles: [], fileCount: 0}
		cbAllDone.call(this,objCB);
		return;
	}
	if(typeof flagMoveSQLiteFiles == 'undefined') flagMoveSQLiteFiles = true;
		if(flagMoveSQLiteFiles) {
			//android can use sqlite files in a sub-dir so they are moved to the root and given a filename account___sqlitedbname.db
			if(typeof cbAllDone == 'undefined') {
				var origCB = function() { }
			} else {
				origCB = cbAllDone;
			}
			cbAllDone = function(obj) {
				var makeCBDone = function(array,cbNoError) {
					var cbDone = function() {
						var arrayIn = array;
						/////////////////
						var folder = accountId;
						var cb = function(array) {
							var arrFQ = [];
							var arrR = [];
							var uriPrefix = DLG1_DlgObj.phoneGapTFGetFSPart(accountId);
							for(var i = 0; i < array.length; i++) {
								arrR.push(array[i].name);
								arrFQ.push(uriPrefix + array[i].name);
							}
						    var obj = {error: false, array: arrayIn, arrayFilesRelative: arrR, arrayFiles: arrFQ, fileCount: array.length}
							cbNoError.call(this,obj);
						};
						DLG1_DlgObj.phoneGapTFListAccountFiles(folder,cb);
						////////////////
					}
					return cbDone;
				}
				var cbDone = makeCBDone(obj.array,origCB);
				var cbError = function() {};
				DLG1_DlgObj.moveSQLiteFilesFromSubfolder(obj.accountId,cbDone,cbError)
			}
	}
	var arr = manifest
	var tempFolderName = 'transFormTemp';
	for(var i = 0; i < arr.length; i++) {
		arr[i].filename = arr[i].url;
		arr[i].zipped = false;
		var flagZip = false;
		var fn = arr[i].filename;
		var ext = fn.split('.');
		ext = ext[ext.length-1];
		if(typeof ext != 'undefined') {
			if(ext.toLowerCase() == 'zip') {
				flagZip = true;
				arr[i].zipped = true;
				if(arr[i].type == 'file') {
					arr[i].type = 'folder';
					if(typeof arr[i].targetFolder == 'undefined') arr[i].targetFolder = '';
				}
			}
		}
		arr[i].shortName = A5.parseFilename(fn).name;
		if(typeof arr[i].targetFolder == 'undefined') arr[i].targetFolder = '';
	}
	var options = {
		directory: tempFolderName,
		strip: true,
		filesystem: 'temp',
		forceDownloadIfFileExists: true,
		onComplete: function(array) {
			_processDownloadedFiles(arr,accountId)
		},
		onError: function(array,arrayIndex) {
			var cbObj = {error:true, errorText: 'Error downloading files to device.'};
			cbAllDone.call(this,cbObj);
		},
		onDeviceOffline: function() {
			var cbObj = {error:true, errorText: 'No connection.'};
			cbAllDone.call(this,cbObj);
		}
	}
	if(typeof optionsIn == 'object') $u.o.assign(options,optionsIn);
	var _deleteTempFolder = function() {
		var _onRemoveSuccess = function() {  };
		var _error = function(e) {  };
		var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
		var _dirName = tempFolderName + '/';
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(_dirPath, _onRemoveSuccess, _error);
	}
	var postProcessComplete = function(arr) {
		var flagDone = true;
		for(var i = 0; i < arr.length; i++) {
			if(arr[i].postProcessDone == false) {
				flagDone = false;
				break;
			}
		}
		var ph = '';
		if(typeof options.progress != 'undefined') {
			if(typeof options.progress.progressElement != 'undefined') {
				ph = options.progress.progressElement;
			}
		}
		if(ph == '') flagShowProgress = false;
		var ele = $(ph + '.PROGRESS.TOTAL');
		var ele2 = $(ph + '.PROGRESSDISPLAY');
		if(ele2) {
			ele2.style.display = '';
			ele2.innerHTML = 'Processing files...';
		}
		//alert('flag done: ' + flagDone);
		var flagShowProgress = false;
		if(typeof options.showProgress != 'undefined') {
			flagShowProgress = options.showProgress;
		}
		if(flagShowProgress) {
			//we don't show progress anymore for post processing. just put up a message saying 'Processing files...'
		}
		//alert(3);
		//alert('44: ' + flagDone);
		//var msg = JSON.stringify(arr,'','\t')
		//DLG1_DlgObj.debugInfoToFile(msg,'c:\\bugs\\arr.txt')
		//if(ele) ele.style.display = '';
		//if(ele2) ele2.style.display = '';
		if(flagDone) {
			//if(ele) ele.style.width = '100%';
			//if(ele2) ele2.style.width = '100%';
			if(ele2) ele2.innerHTML = '';
			if(ele2) ele2.style.display = 'none';
			if(ele) ele.style.display = 'none';
			var that = this;
			setTimeout(function() {
				if(ele2) ele2.style.display = 'none';
				setTimeout(function() {
					var objCB = {error: false, array: arr, accountId: accountId};
					cbAllDone.call(that,objCB);
					_deleteTempFolder();
				},100);
			},101);
		} else {
			var countDone = 0;
			for(var i = 0; i < arr.length; i++) {
				if(arr[i].postProcessDone) countDone = countDone + 1;
			}
			if(ele2) ele2.style.display = '';
			var pct = (countDone/arr.length) * 100;
			if(ele) {
				//ele.style.width = pct + '%';
			}
		}
	}
	//////////////////// post process function start ////////////////////
	var _processDownloadedFiles = function(arr, accountId) {
		for(var i = 0; i < arr.length; i++) {
			arr[i].postProcessDone = false;
			arr[i].postProcessError = false;
		}
		var flagMustUpdateOnDeviceManifest = false;
		for(var i = 0; i < arr.length; i++) {
			if(!arr[i].downloaded) {
				if(!flagInformationOnly) flagMustUpdateOnDeviceManifest = true;
				arr[i].postProcessDone = true;
			}
		}
		//sr00
		if(flagMustUpdateOnDeviceManifest) {
			//var m = localStorage.transFormOnDeviceManifest;
			var m = getManifest(manifestName);
			var mObj = JSON.parse(m);
			var url_i = '';
			var mObj2 = mObj[folder];
			//window.onerror = function(err) { alert('Unhandled Javascript Error - postprocess:  ' + JSON.stringify(err));}
			for(var i = 0; i < arr.length; i++) {
				if(!arr[i].downloaded) {
					url_i = arr[i].url;
					for(var j = 0; j < mObj2.length; j++) {
						if(mObj2[j].url == url_i) {
							mObj2[j].version = -1; //set version to -1 so that if the error is later corrected, file will download
						}
					}
				}
			}
			m = JSON.stringify(mObj)
			//localStorage.transFormOnDeviceManifest = m;
			storeManifest(m,manifestName);
		}
		postProcessComplete(arr) //if all downloads fail, need to trigger the onDone event
		for(var i = 0; i < arr.length; i++) {
			if(arr[i].type == 'sqlite' && arr[i].downloaded) {
				var flagZip = arr[i].zipped
				if(flagZip) {
					var _getcbok = function(index,arrIn) {
						var i = index;
						var arr = arrIn;
						var ok = function() {
							//alert('sqlite unzipped in target - '  + i + arr[i].localFilename );
							arr[i].postProcessDone = true;
							arr[i].postProcessError = false;
							postProcessComplete(arr)
						}
						return ok
					}
					var _getcbfail = function(index,arrIn) {
						var i = index;
						var arr = arrIn;
						var fail = function() {
							//alert('failed');
							arr[i].postProcessDone = true;
							arr[i].postProcessError = true;
							postProcessComplete(arr)
						};
						return fail;
					}
					var ok = _getcbok(i,arr);
					var fail = _getcbfail(i,arr);
					DLG1_DlgObj.phoneGapUnzipSQLite(arr[i].localFilename,'','','',accountId,ok,fail)
				} else {
					//SQLite db is NOT zipped
					var _getcbok = function(index,arrIn) {
						var i = index;
						var arr = arrIn;
						var onSuccess = function() {
							//alert('sqlite db copied: ' + i + ' must now delete ' + arr[i].localFilename);
							arr[i].postProcessDone = true;
							arr[i].postProcessError = false;
							//alert(JSON.stringify(arr,'','\t'));
							postProcessComplete(arr)
						}
						return onSuccess;
					}
					var _getcbfail = function(index,arrIn) {
						var i = index;
						var arr = arrIn;
						var ok = function() {
							//alert('sqlite db NOT copied: ' + i);
							arr[i].postProcessDone = true;
							arr[i].postProcessError = true;
							postProcessComplete(arr)
						}
						return ok;
					}
					var onSuccess = _getcbok(i,arr);
					var onError = _getcbfail(i,arr);
					var fn = arr[i].localFilename
					fn = fn.split('/');
					var localDBName = fn[fn.length-1];
					DLG1_DlgObj.copySQLiteDB(arr[i].localFilename,'','','',localDBName,accountId, onSuccess, onError)
				}
			}
			if(arr[i].type == 'file' && arr[i].downloaded) {
				var fnSource = arr[i].localFilename;
				if(arr[i].targetFolder == '') {
					var _targetFolder = accountId + '/';
				} else {
					var _targetFolder = accountId + '/' + arr[i].targetFolder;
				}
				var makeOnMoveOK = function(arr,i) {
					var _ok = function() {
						arr[i].postProcessDone = true;
						arr[i].postProcessError = false;
						postProcessComplete(arr);
					}
					return _ok;
				}
				var makeOnMoveError = function(arr,i) {
					var _err = function() {
						arr[i].postProcessDone = true;
						arr[i].postProcessError = true;
						postProcessComplete(arr);
					}
					return _err;
				}
				var _onMoveSuccess = makeOnMoveOK(arr,i);
				var _error = makeOnMoveError(arr,i);
				var _srcPath = fnSource;
				var _destinationDirPath = DLG1_DlgObj.phoneGapGetLocalDirURL(fileSystemPart) + _targetFolder;;
				var _destinationName = arr[i].shortName;
				var _onFolderCreateSuccess = function() {
					DLG1_DlgObj.phoneGapMoveFileURL(_srcPath, _destinationDirPath, _destinationName, _onMoveSuccess, _error);
				};
				var _onFolderCreateError = makeOnMoveError(arr,i);
				var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL(fileSystemPart);;
				var _dirStructure = _targetFolder;;
				DLG1_DlgObj.phoneGapEnsureDirPathURL(_baseURI, _dirStructure, _onFolderCreateSuccess, _onFolderCreateError);
			}
			if(arr[i].type == 'folder' && arr[i].downloaded) {
				var _getcbfail = function(index,arrIn) {
						var i = index;
						var arr = arrIn;
						var ok = function(err) {
							//alert('failed');
							alert('UNZIP folder failed: ' + i);
							arr[i].postProcessDone = true;
							arr[i].postProcessError = true;
							postProcessComplete(arr)
						}
						return ok;
					}
				var _getcbok = function(index,arrIn) {
						var i = index;
						var arr = arrIn;
						var onSuccess = function() {
							//alert('folder UNZIP OK: ' + i + ' delete temp file: ' + arr[i].localFilename) ;
							arr[i].postProcessDone = true;
							arr[i].postProcessError = false;
							postProcessComplete(arr)
						}
						return onSuccess;
					}
				var ok = _getcbok(i,arr)
				var fail = _getcbfail(i,arr)
				if(arr[i].targetFolder == '') {
					var _target = accountId;
				} else {
					var _target = accountId + '/' + arr[i].targetFolder;
				}
				DLG1_DlgObj.phoneGapUnzipFiles(arr[i].localFilename,'','','',fileSystemPart, _target,ok,fail,false)
			}
		}
	}
	//////////////////// post process function end ////////////////////
	DLG1_DlgObj.phoneGapFileDownload(arr,options);
}
//////////////////////////===========new
//each named manifest MUST have its own folder
DLG1_DlgObj.__getManifestObj = function(keyName) {
	if(typeof keyName == 'undefined') keyName = 'manifests';
		var manifestObj = localStorage.getItem(keyName);
		if(manifestObj == null || !manifestObj) manifestObj = '';
		if(manifestObj == '') {
			manifestObj = {};
		} else {
			manifestObj = JSON.parse(manifestObj);
		}
		return manifestObj;
}
DLG1_DlgObj.getFolderForNamedManifest = function(manifestName) {
	window.onerror = function(err) { alert('Error - getFolderForNamedManifest():  ' + JSON.stringify(err));}
	//returns an object with 'folder' and 'fileSystemPart'
	if(typeof manifestName == 'undefined' || manifestName == '') manifestName = '___default___';
	var obj = DLG1_DlgObj.__getManifestObj('manifestInfo');
	var obj2 = obj[manifestName];
	return obj2;
}
DLG1_DlgObj.phoneGapListFilesInManifest = function(manifestName,cb) {
	window.onerror = function(err) { alert('Error - phoneGapListFilesInManifest():  ' + JSON.stringify(err));}
	if(typeof manifestName == 'undefined') manifestName = '';
	var obj = DLG1_DlgObj.getFolderForNamedManifest(manifestName);
	if(obj) {
		var folder = DLG1_DlgObj.getFolderForNamedManifest(manifestName).folder;
		DLG1_DlgObj.phoneGapTFListAccountFiles(folder,cb);
	} else {
		var arr = [];
		cb.call(this,arr);
	}
}
DLG1_DlgObj.phoneGapDeleteFilesInManifest = function(manifestName,onOK,onError) {
	window.onerror = function(err) { alert('Error - phoneGapDeleteFilesInManifest():  ' + JSON.stringify(err));}
	if(typeof manifestName == 'undefined') manifestName = '';
	var obj = DLG1_DlgObj.getFolderForNamedManifest(manifestName);
	if(!obj) return;
	if(obj) var folder = obj.folder;
	DLG1_DlgObj.phoneGapTFRemoveFilesForAccount(folder,onOK,onError,manifestName)
	var obj = DLG1_DlgObj.__getManifestObj('manifestInfo');
	delete obj[manifestName];
	var json = JSON.stringify(obj);
	localStorage.setItem('manifestInfo',json) ;
	var obj = DLG1_DlgObj.__getManifestObj();
	delete obj[manifestName];
	var json = JSON.stringify(obj);
	localStorage.setItem('manifests',json)
}
DLG1_DlgObj.listManifests = function(cb) {
	window.onerror = function(err) { alert('Error - listManifests():  ' + JSON.stringify(err));}
	var m = [];
	var obj = DLG1_DlgObj.__getManifestObj('manifestInfo');
	if(obj) {
		for(var n in obj) {
			if(n.indexOf('___default___') > -1) {
				var obj2 = localStorage.getItem('transFormOnDeviceManifest');
				if(obj2 == null || obj2 == 'null') {
				} else {
					m.push('Default Manifest');
				}
			} else {
				m.push(n)
			}
		}
	}
	if(cb) cb.call(this,m);
	return m;
}
DLG1_DlgObj.getManifests = function(onOK) {
	window.onerror = function(err) { alert('FATAL: getManifests()  ' + JSON.stringify(err));}
	var m = DLG1_DlgObj.listManifests();
	var r = [];
	var robj = {};
	var obj =  DLG1_DlgObj.__getManifestObj('manifestInfo');
	var obj2 = DLG1_DlgObj.__getManifestObj();
	for(var i = 0; i < m.length; i++) {
		var n = m[i];
		if(n == 'Default Manifest') {
			var obj4 = obj['___default___'];
			if(obj4) {
				if(obj4.folder && obj4.folder != null) {
					delete robj;
					var robj = {};
					robj.name = 'Default Manifest';;
					robj.folder = obj4.folder
					robj.fileSystemPart = obj4.fileSystemPart;
					var ls = localStorage.getItem('transFormOnDeviceManifest');
					var ls = JSON.parse(ls);
					if(ls) {
						var manifest = ls[obj4.folder];
						robj.manifest = manifest;
						r.push(robj)
					}
				}
			}
		} else {
			delete robj;
			var robj = {};
			robj.name = n;
			var obj4 = obj[n]
			if(obj4 && obj4.folder) {
				robj.folder = obj4.folder;
				robj.fileSystemPart = obj4.fileSystemPart;
				robj.manifest = JSON.parse(obj2[n])[obj4.folder];
				r.push(robj);
			}
		}
	}
	if(typeof onOK == 'function') onOK.call(this,r);
	return r;
}
/*
DLG1_DlgObj.getManifest = function(manifestName,onOK) {
	var val = DLG1_DlgObj.phoneGapGetManifestBaseFolder(manifestName,onOK,'getManifest')
}
*/
DLG1_DlgObj.phoneGapGetManifestBaseFolder = function(manifestName,onOK,mode) {
	var name = manifestName;
	if(name == '') name = 'Default Manifest';
	if(manifestName == 'Default Manifest') manifestName = ''
	var obj = DLG1_DlgObj.getManifests();
	if(!obj) {
		if(typeof onOK == 'function') onOK.call(this,{});
		return '';
	};
	var obj2 = {};
	var found = false;
	for(var i = 0; i < obj.length; i++) {
		if(obj[i].name == name) {
			obj2 = obj[i];
			found = true;
		}
	}
	if(mode == 'getManifest') {
		if(typeof onOK == 'function') onOK.call(this,obj2)
		return obj2;
	}
	if(!found) {
		if(typeof onOK == 'function') onOK.call(this,{});
		return '';
	}
	var folder = obj2.folder;
	var fspart = obj2.fileSystemPart;
	obj2.baseFolder = DLG1_DlgObj.phoneGapGetLocalDirURL(obj2.fileSystemPart)
	if(typeof onOK == 'function') onOK.call(this,obj2)
	return '' + DLG1_DlgObj.phoneGapGetLocalDirURL(obj2.fileSystemPart)
}
//////////////
DLG1_DlgObj.phoneGapTFReadFile = function(filename,ok,fail) {
	var fileSystemPart = DLG1_DlgObj.phoneGapTFGetFSPart(account,true);
	if(typeof ok == 'undefined') ok = function() { };
	if(typeof fail == 'undefined') fail = function(e) { };
	var _success = function(result) {
		ok.call(this,result)
	};
	var _error = function(e) {
		fail.call(this,e)
	};
	if(fileSystemPart == null || fileSystemPart == '') {
		fail.call(this);
		return;
	}
	var _filePath = DLG1_DlgObj.phoneGapGetLocalDirURL(fileSystemPart) + filename;
	DLG1_DlgObj.phoneGapReadFileURL(_filePath, _success,_error)
}
DLG1_DlgObj.phoneGapTFExecuteSQL = function(dbName,sql,args,ok,fail) {
/*
useage:
var _success = function() {
	resultArray = arguments[0];
	DLG1_DlgObj.setListColumnsAndPopulate('list1',resultArray)
};
var _error = function(e) { };
DLG1_DlgObj.phoneGapTFExecuteSQL('account1/SQLiteNorthwind.db','select * from Customers where Country = ?',['UK'],ok,fail)
*/
	if(typeof ok != 'function') ok = function() { };
	if(typeof fail != 'function') fail = function(e) { }
	//dbName is typically like this: account1/dbname.db
	if(args.constructor == Array) {
		var _args = args;
	} else {
		var _args = [];
	}
	var _success = function(tx,result,resultArray) {
		ok.call(this,resultArray,result,tx)
	};
	var _error = function(e) {
		fail.call(this,e)
	};
	_onTxSuccess = function() {/*transaction success */  };
	_onTxError = function() {/*transaction error */  };
	DLG1_DlgObj.SQLiteExecuteSQL(dbName,sql,_args,_success,_error,_onTxSuccess,_onTxError);
}
DLG1_DlgObj.phoneGapDeleteSQLiteDBFiles = function(account,cb,onerror) {
	if(typeof cb == 'undefined') cb = function() { };
	if(typeof onerror == 'undefined') onerror = function() { };
 	var ext = '.db';
 	var _onCompletion = function() { cb.call(this);};
	var _error = function(e) { onerror.call(this) };
	var _baseURI = DLG1_DlgObj.getSQLiteFolder(1);
	var _dirName = '/';;
	var _matchRegex = new RegExp(account.escapeRegExp() + '___[A-z0-9_]*' + ext.escapeRegExp());
	var _keepList = [];
	var _dirPath = _baseURI + _dirName;
	DLG1_DlgObj.phoneGapDeleteFilesNotInListURL(_dirPath,_matchRegex,_keepList, _onCompletion, _error);
}
DLG1_DlgObj.phoneGapTFRemoveFilesForAccount = function(accountId,cb,onError) {
	if(typeof onError == 'undefined') onError = function() { };
	if(typeof cb == 'undefined') cb = function() { };
	//get the fspart where manifest was loaded
	var fsPart = DLG1_DlgObj.phoneGapTFGetFSPart(accountId);
	var __removeSQLite = function(accountId,cb,onError) {
		DLG1_DlgObj.phoneGapDeleteSQLiteDBFiles(accountId,cb,onError);
	}
	var _errorRemoveFolder = function() { __removeSQLite(accountId,cb,onError); };
	var _onRemoveFolderSuccess = function() { __removeSQLite(accountId,cb,onError);};
	var _dirPath = fsPart + accountId + '/';
	DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(_dirPath, _onRemoveFolderSuccess, _errorRemoveFolder);
	var manifestName = arguments[3];
	if(typeof manifestName == 'undefined') localStorage.transFormOnDeviceManifest = null;
}
DLG1_DlgObj.phoneGapTFListAccountFiles = function(account,cb) {
//if fileSystemPart is 'private' on iOS will get odd results because private and getSQLiteFolder() are same folder
	var fileSystemPart = DLG1_DlgObj.phoneGapTFGetFSPart(account,true);
	if(typeof cb == 'undefined') cb = function() { };
	if(fileSystemPart == null || fileSystemPart == '') {
		cb.call(this,[]);
		return;
	}
	var arr = [];
	var _files = function(account) {
		var _onSuccess = function(filelist) {
			var str;
			for(var i = 0; i < filelist.length; i++) {
				str = filelist[i];
				if(str.substr(str.length-1) != '/') {
					arr.push({name: account + '/' + filelist[i], type: 'file'});
				}
			};
			_sqlite(account)
		};
		var _error = function(e) {  _sqlite(account) };
		var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL(fileSystemPart);;
		var _dirName = account + '/';;
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapListFilesRecurseURL(_dirPath, _onSuccess, _error);
	}
	var _sqlite = function(account) {
		var _onSuccessSQ = function(filelist) {
			var _ext = function(fn) {
				fn = fn.split('.')
				if(fn.length == 1) return '';
				var ext = fn[fn.length-1];
				if(typeof ext == 'undefined') ext = '';
				return ext;
			}
			var flagFixType = false;
			for(var i = 0; i < filelist.length; i++) {
				flagFixType = false;
				/*
				try{
					if(fileSystemPart == 'private' && device.platform.toLowerCase() == 'ios') {
						flagFixType = true;
					}
				}catch(e) { }
				*/
				if(flagFixType == false) {
					if(filelist[i].indexOf(account) == 0) {
						if( filelist[i].substr(filelist[i].length-1) != '/' && _ext(filelist[i]) == 'db') {
							arr.push({name: filelist[i], type: 'SQLiteDB'});
						}
					}
				}
			};
			if(flagFixType) {
				for(var i = 0; i < arr.length; i++) {
					var _n = arr[i].name.split('.');
					var _e = _n[_n.length-1];
					if(_e.toLowerCase() == 'db') {
						arr[i].type = 'SQLiteDB';
					}
				}
			}
			cb.call(this,arr);
		};
		var _error = function(e) { cb.call(this,arr);};
		var _baseURI = DLG1_DlgObj.getSQLiteFolder(1);
		//var _dirName = account + '/';;
		_dirName = '/';
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapListFilesRecurseURL(_dirPath, _onSuccessSQ, _error);
	}
	_files(account)
}
DLG1_DlgObj.phoneGapGetSQLiteDatabases = function(account,cb,error) {
	if(typeof error == 'undefined') error = function(e) { };
	var _sqlite = function(account) {
		var _onSuccessSQ = function(filelist) {
			if(account != '') {
				var _f = [];
				var x;
				for(var i = 0; i < filelist.length; i++) {
					x = filelist[i].split('.');
					x = x[x.length-1];
					if(filelist[i].indexOf(account+'___') == 0 && x != 'undefined' && x == 'db' ) {
						_f.push(filelist[i]);
					}
				}
			} else {
				var _f = [];
				var x;
				for(var i = 0; i < filelist.length; i++) {
					x = filelist[i].split('.');
					x = x[x.length-1];
					if(x != 'undefined' && x == 'db' ) {
						_f.push(filelist[i]);
					}
				}
			}
			cb.call(this,_f);
		};
		var _error = function(e) { error.call(this,e);};
		var _baseURI = DLG1_DlgObj.getSQLiteFolder(1);
		_dirName = '/';
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapListFilesRecurseURL(_dirPath, _onSuccessSQ, _error);
	}
	_sqlite(account)
}
DLG1_DlgObj.phoneGapTFGetFSPart = function(accountId,flagShortPartName) {
	if(typeof flagShortPartName == 'undefined') flagShortPartName = false;
	var baseFolder = ''
	var storedWhere = localStorage.getItem('transFormFileSystemPart');
	var obj = {}
	if(storedWhere == null) {
	} else {
		try{
			obj = JSON.parse(storedWhere);
			baseFolder = obj[accountId];
		}catch(e) {
		}
	}
	if(flagShortPartName) {
		return baseFolder;
	}
	baseFolder = DLG1_DlgObj.phoneGapGetLocalDirURL( baseFolder);
	return baseFolder;
}
DLG1_DlgObj.phoneGapTFGetFullPath = function(relativeFilename,accountId) {
	if(relativeFilename.indexOf(accountId) == -1) {
		var baseFolder = DLG1_DlgObj.phoneGapTFGetFSPart(accountId) + accountId + '/' + relativeFilename;
	} else {
		var baseFolder = DLG1_DlgObj.phoneGapTFGetFSPart(accountId) +  relativeFilename;
	}
	return baseFolder;
}
////=========== 'sr87
DLG1_DlgObj.moveSQLiteFilesFromSubfolder = function(accountIn, cbDone, cbError) {
	//called after a manifest has been downloaded to move the SQLite databases to the root of the SQLite folder with 'accountName___' as the db prefix
	//this is done because while iOS can open a db named folder/sqlite.db, android can't. so we make folder___sqlite.db
	//get a list of SQLite dbs in the subfolder, then iterate over list calling _moveLow()
	function _moveLow(account,dbName,array, cbDone) {
		//var _onMoveSuccess = function() { alert('ok'); + alert(JSON.stringify(array)); };
		var _onMoveSuccess = cbDone;
		var _error = function(e) { alert('move failed');};
		var _srcPath = DLG1_DlgObj.getSQLiteFolder(1) + account + '/' + dbName;
		var _destinationDirPath = DLG1_DlgObj.getSQLiteFolder(1);;
		var _destinationName = account + '___' + dbName;
		DLG1_DlgObj.phoneGapMoveFileURL(_srcPath, _destinationDirPath, _destinationName, _onMoveSuccess, _error);
	}
	//make a closure that captures the accountIn name
	var _makeOK = function(accountIn,cbDone,cbError) {
		var account = accountIn;
		var _ok = function(filelist) {
			var _arr = []
			for(var i = 0; i < filelist.length; i++) {
				if(filelist[i].indexOf(account + '/') == 0) {
					var n = filelist[i];
					n = n.split('/')
					var acc = n[0];
					var dbName = n[1];
					_arr.push({account: acc, dbName: dbName, completed: 0});
				}
			}
			//alert(' now do _moveLow for ' + _arr.length + ' files');
			if (_arr.length == 0) {
				cbDone.call();
			}
			var count = 0;
			for(var i = 0; i < _arr.length; i++) {
				var _okmc = function(ii) {
					var arr = _arr;
					var _ok = function() {
						_arr[ii].completed = 1;
						var _done = 0;
						for(var j = 0; j < arr.length; j++) {
							_done = _done + arr[j].completed;
							if(_done == arr.length) {
								//alert('done: ' + _done + ' account: ' + accountIn + ' typeof cbDone: ' + typeof cbDone);
								//alert(cbDone.toString())
								cbDone.call();
							}
						}
					};
					return _ok;
				}
				var _okm = _okmc(i);
				_moveLow(_arr[i].account,_arr[i].dbName,_arr,_okm)
			}
		};
		return _ok;
	}
	var cbx = function() { };
	//alert(1);
	//alert(cbDone.toString());
	var _ok = _makeOK(accountIn,cbDone);
	var _err = function(e) { };
	var _err = _ok; //sr 6-12-2020 on android, if there are no sqlite databases, then the _err function will get called and as a result, the onComplete event was  not firing
	//therefore make the _err() function same as the _ok() function
	//need to specify a blank account because the sqlite unzip creates subfolders at the root level of the sqlite folder and these are the files we want to move
	var account = '';
	DLG1_DlgObj.phoneGapGetSQLiteDatabases(account,_ok,_err);
}
////=======
//
// DLG1_DlgObj.phoneGapDeleteFilesNotInListURL(dirpath, matchRegex, keepList, onCompletion, onError)
//
// dirpath is the file URL of the directory whose contents will be examined (only files).
// matchRegex, if non-null, will need to match file names found for them to be considered for deletion.
// Any file name which is in the array keepList will not be considered even if it matches.
// All remaining files found (those matched and not in keepList) will be deleted.
//
DLG1_DlgObj.phoneGapDeleteFilesNotInListURL = function(dirpath, matchRegex, keepList, onCompletion, onError) {
   if (!DLG1_DlgObj.phoneGapFilesAvailable()) {
      onError();
      return;
   }
   var keepnames = {}; // fill object with all the names as attributes
   for (var j=0; j<keepList.length; j++) {
      keepnames[keepList[j]] = true;
   }
   var filelist = []; // list of files to delete
   var totalDeleted = 0;
   var deleteFromFileList = function() { // called repeatedly by itself on successes until all deleted
      if (filelist.length==0) { // no more to delete
         onCompletion(totalDeleted);
         return;
      }
      var todelete = filelist.pop(); // pop one from list and delete it, leaving list shorter
      totalDeleted += 1;
      todelete.remove(deleteFromFileList, onError);
   };
   var onResolvedURL =
      function(fsEntry) {
         var dirReader = fsEntry.createReader();
         var readEntriesFunction =
            function() { // function to recurse to call repeatedly after each completion until no result
               dirReader.readEntries( // start an async reading of entries
                  function(entries) { // more entries read, or done
                     if (!entries || entries.length==0) {
                        deleteFromFileList(); // got all - now start deleting them
                        return;
                     }
                     var name;
                     for (var i=0; i<entries.length; i++) {
                        name = entries[i].name;
                        if (!matchRegex || name.match(matchRegex)) { // must match regex
                           if (!keepnames[name]) { // and not be on keep list
                              filelist.push(entries[i]); // add one to delete to list
                           }
                        }
                     }
                     readEntriesFunction(); // recurse to call dirReader.readEntries again
                  },
                  onError);
               };
         readEntriesFunction(); // do first reading
      };
   window.resolveLocalFileSystemURL(dirpath, onResolvedURL, onError);
}
DLG1_DlgObj.phoneGapGetVideoFromLibrary = function(ops) {
	if(typeof ops.onBeforeCaptureJavascript != 'undefined') {
		if(ops.onBeforeCaptureJavascript.constructor == Function) {
			var result = ops.onBeforeCaptureJavascript.call();
			if(typeof result !='undefined' && !result) return false;
		}
	}
	var _options = ops
	var getVideoWithPromises = function() {
		return new Promise(function (returnResolve, returnReject) {
		// here are all the callbacks as promises
		new Promise(function (resolve, reject) {
			// call camera | photo library | videos only
			var options = {
				destinationType: Camera.DestinationType.FILE_URI,
				sourceType: Camera.PictureSourceType.PHOTOLIBRARY,
				mediaType: Camera.MediaType.VIDEO
			};
			navigator.camera.getPicture(resolve, reject, options);
		}).then(function(filePath) {
			console.log('First promise returned filepath: '+filePath);
			//Android does not return prefix so append
			var prefix = 'file://'
			filePath=filePath.includes(prefix)?filePath:prefix+filePath;
			return new Promise(function(resolve, reject) {
					window.resolveLocalFileSystemURL(filePath, resolve, reject);
			});
		}).then(function (videoFileEntry) {
			console.log('Second promise returned videoFileEntry: '+videoFileEntry);
			returnResolve(videoFileEntry)
		});
	});
}
	var getVideo = function() {
		getVideoWithPromises().then(function (videoFileName) {
			console.log('Final promise completed.');
			var vUrl = videoFileName.toURL();
			DLG1_DlgObj._thisVideo = [vUrl];
			DLG1_DlgObj.setValue('vp',vUrl);
			console.log('Local Video File: '+vUrl);
			var e2 = {};
			e2.fileSystemURL = vUrl;
			_options.onCaptureJavascript.call(this,e2);
		}, function(err) {
			console.log('Error: ' + err);
			alert('Error: ' + err);
		});
	};
	getVideo();
}
DLG1_DlgObj.phoneGapOpenFileWithNativeViewer = function(objIn,_onSuccess,_onError) {
	var _ts = function(txt) { //add trailing slash
 		if(txt[txt.length-1] == '/') return txt;
		return txt + '/';
	}
	if(typeof objIn.targetFolder == 'undefined') objIn.targetFolder = '';
	objIn.targetFolder = _ts(objIn.targetFolder);
	objIn.sourceFolder = _ts(objIn.sourceFolder);
	objIn.flagMustDownload = typeof objIn.flagMustDownload != 'undefined' ? objIn.flagMustDownload: false;
	//set up obj variables from the passed in object (objIn);
	var obj = {};
	obj.__tempFolderDirName = '__AATEMPFILES/';
	if(objIn.flagMustDownload == false) { //local file
		obj.__fileName = objIn.sourceFileName;
	} else {//remote file
		var __url = objIn.sourceFileName;
		obj.__url = __url;
		var __forceDownloadIfFileExists = true;
		var __showProgress = objIn.options.showProgress;
		var __downloadOptions = objIn.options;
		//alert('__url: ' + __url);
		obj.__fileName = A5.parseFilename(objIn.sourceFileName).name; ''  //get the short filename from the URL
	}
	obj.__sourceFileSystemPart = objIn.sourceFileSystem;
	obj.__sourceFolder = objIn.sourceFolder;
	obj.flagMustDownload = objIn.flagMustDownload
	obj.options = objIn;
	//end set up obj variables
	DLG1_DlgObj._phoneGapOpenNativeLow(obj,_onSuccess,_onError)
}
DLG1_DlgObj._phoneGapOpenNativeLow = function(obj,_onSuccess,_onError) {
	try {
	//cordova.plugins.fileOpener2
		var _open = cordova.plugins.disusered.open;
	} catch(e) {
		alert("'cordova-open' plugin not loaded.");
		return false;
	}
	if(obj.__fileName.indexOf('http:') == -1 && obj.__fileName.indexOf('http2:') == -1) {
		var o = A5.parseFilename(obj.__fileName);
		obj.__fileNameFull = obj.__fileName;
		obj.__fileName = o.name;
		if(o.path != '') {
			obj.__sourceFolder = obj.__sourceFolder + o.path + '/';
		}
	}
	var __targetFileName = obj.options.targetFileName;
	var __tempFolderDirName = obj.__tempFolderDirName; //temp dir where files are copied so that they can be opened
	var __fileName = obj.__fileName;
	var __srcFileName = __fileName;
	var __srcFileNameFull = obj.__fileNameFull
	if(typeof __targetFileName != 'undefined') {
		__fileName = __targetFileName;
	} else {
		__targetFileName = '';
	}
	var __sourceFileSystemPart = obj.__sourceFileSystemPart; //dir part where local file exists were where remote file will be downloaded
	var __sourceFolder = obj.__sourceFolder; //dir folder where local file exists or where remote file will be downloaded
	var __url = obj.__url;  //if file is remote, the remote url for the file
	//obj.flagMustDownload - true/false indicates if file is local or remote
	//clear out the temp folder by deleting it/////////////////////////////////////
	var _deleteTemp = function(cb) {
		var _onRemoveSuccess = function() {
			if(A5.log) A5.log('Temp dir was removed.');
			cb.next();
		};
		var _error = function(e) {
			if(A5.log) A5.log('Temp dir was not removed. Not critical, so continue.');
			cb.next();
		};
		var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
		var _dirName = __tempFolderDirName;;
		var _dirPath = _baseURI + _dirName;
		DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(_dirPath, _onRemoveSuccess, _error);
	}
	//recreate the temp folder////////////////////////////////////////////////////
	var _createTemp = function(cb) {
		var _onSuccess = function() {
			if(A5.log) A5.log('Temp dir was created');
			cb.next();
		};
		var _error = function(e) {
			if(A5.log) A5.log('Temp dir was not created. Critical error, so stop.');
			_onError(e);
			cb.stop();
		};
		var _baseURI = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
		var _dirStructure = __tempFolderDirName;;
		DLG1_DlgObj.phoneGapEnsureDirPathURL(_baseURI, _dirStructure, _onSuccess, _error);
	}
	//copy the source file to the temp folder ////////////////////////////////////////////
	var _copyToTemp = function(cb) {
		var _onCopySuccess = function() {
			if(A5.log) A5.log('File was copied');
			cb.next()
		};
		var _error = function(e) {
			if(A5.log) A5.log('File was not copied. Critical error, so stop.');
			_onError(e);
			cb.stop();
		};
		if(__sourceFileSystemPart.indexOf('manifest:') == -1 ) {
			var _srcPath = DLG1_DlgObj.phoneGapGetLocalDirURL(__sourceFileSystemPart) + __sourceFolder +  __srcFileName;
		} else {
			var manifestFolder = __sourceFileSystemPart.split(':')[1];
			var _srcPath = DLG1_DlgObj.phoneGapTFGetFSPart(manifestFolder)
			_srcPath = _srcPath + manifestFolder + '/' + __srcFileNameFull;
		}
		var _destinationDirPath = DLG1_DlgObj.phoneGapGetLocalDirURL('temp');;
		var _destinationName = __tempFolderDirName + __fileName;
		if(A5.log) A5.log('Copy file - source: ' + _srcPath)
		if(A5.log) A5.log('Copy file - target: ' + _destinationDirPath + _destinationName);
		if(_srcPath == _destinationDirPath + _destinationName) {
		 	cb.next();
		 } else {
			DLG1_DlgObj.phoneGapCopyFileURL(_srcPath, _destinationDirPath, _destinationName, _onCopySuccess, _error);
		}
	}
	//open the file with the native viewer ////////////////////////////////////////
	var _openFile = function(cb) {
		var _open = cordova.plugins.disusered.open;
		var _filename = DLG1_DlgObj.phoneGapGetLocalDirURL('temp') + __tempFolderDirName + __fileName;
		if(A5.log) A5.log('File to show: ' +_filename);
		_open(_filename,_onSuccess,_onError);
	}
	var _actions = [];
	if(obj.__sourceFileSystemPart != 'temp') {
		_actions.push(_deleteTemp);
		_actions.push(_createTemp);
	}
	_actions.push(_copyToTemp);
	_actions.push(_openFile);
	var forEach = function(actions,andThen,ifError) {
	    var index = 0;
	    var stop = function(err) {
	    	if(ifError) {
	    		ifError(err);
	    	}
	    }
	    var  next = function() {
	        if( index < actions.length ) {
	            var action = actions[index];
	            ++index;
	            action({next:next,stop:stop});
	        } else if(andThen) {
	        	andThen();
	        }
	    };
	    next();
	};
	var _allDone = function() { }
	var _fatal = function() { }
	if(obj.flagMustDownload) { //file download
		var fileToGet = __url;
		var arr = [{filename: fileToGet}];
		var opsIn = obj.options;
		var options = {
			directory: '',
			targetFolder: opsIn.sourceFolder,
			forceDownloadIfFileExists: opsIn.options.forceDownloadIfFileExists,
			showProgress: opsIn.options.showProgress,
			onComplete: function(array) {
				if(A5.log) A5.log('File download complete');
				var msg = JSON.stringify(array,'','\t');
				if(A5.log) A5.log(msg);
				/*
				var _a2 = []
				var _a = [];
				for(var i = 0; i < array.length; i++) {
					_a.push({filename: array[i].localFilename, found: array[i].found, downloaded: array[i].downloaded});
					_a2.push(array[i].localFilename);
				}
				var l = DLG1_DlgObj.getControl('list2');
				l.populate(_a);
				$('div4').innerHTML = 'actual download filename: ' + _a2.join('<br>');
				*/
			if(__targetFileName == '' && (__sourceFileSystemPart == 'temp' || __sourceFileSystemPart == 'public')) {
				if(A5.log) A5.log('Open file in place. No need to copy to a temporary folder');
				var _open = cordova.plugins.disusered.open;
				var _filename = DLG1_DlgObj.phoneGapGetLocalDirURL(__sourceFileSystemPart) + __sourceFolder + __fileName;
				_open(_filename,_onSuccess,_onError);
				return false;
			}
				forEach(_actions,_allDone,_fatal)
			},
			onError: function(array,arrayIndex) { alert('Download error'); _onError();},
			onDeviceOffline: obj.options.options.onDeviceOffline,
			progress: opsIn.options.progress,
			strip: true
		}
		delete options.targetFolder;
		options.filesystem =  opsIn.sourceFileSystem;
		options.directory = opsIn.sourceFolder;
		if(A5.log) A5.log('About to do file download')
		if(A5.log) A5.log(JSON.stringify(arr,'','\t'));
		if(A5.log) A5.log(JSON.stringify(options,'','\t'));
		DLG1_DlgObj.phoneGapFileDownload(arr,options);
		//end file download
	} else {
		//local file
		if(__targetFileName == '' && (__sourceFileSystemPart == 'temp' || __sourceFileSystemPart == 'public')) {
			if(A5.log) A5.log('Open file in place. No need to copy to temporary folder.');
			var _open = cordova.plugins.disusered.open;
			var _filename = DLG1_DlgObj.phoneGapGetLocalDirURL(__sourceFileSystemPart) + __sourceFolder + __fileName;
			_open(_filename,_onSuccess,_onError);
			return false;
		}
		forEach(_actions,_allDone,_fatal);
	}
}
//PROMISE VERSIONS
DLG1_DlgObj.phoneGapEnsureDirPathURLPromise = function(_baseURI,_dirStructure) {
	var promiseF = function(resolve,reject) {
		var _ok = function() {resolve()};
		var _err = function(e) { 	reject(e)	};
		DLG1_DlgObj.phoneGapEnsureDirPathURL(_baseURI, _dirStructure, _ok, _err);
	}
   return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapWriteFileURLPromise = function(filepath, text, append) {
	var promiseF = function(resolve,reject) {
		var _ok = function() { resolve() };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapWriteFileURL(filepath,text,_ok,_err,append)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapReadFileURLPromise = function(filepath, startAt, endAt) {
	var promiseF = function(resolve,reject) {
		var _ok = function(data) { resolve(data) };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapReadFileURL(filepath,_ok,_err,startAt, endAt)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapListFilesRecurseURLPromise = function(rootpath) {
	var promiseF = function(resolve,reject) {
		var _ok = function(data) { resolve(data) };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapListFilesRecurseURL(rootpath, _ok, _err)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURLPromise = function(dirpath) {
	var promiseF = function(resolve,reject) {
		var _ok = function() { resolve() };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapRemoveDirectoryRecurseURL(dirpath, _ok, _err)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapFileExistsURLPromise = function(filepath) {
	var promiseF = function(resolve,reject) {
		var _ok = function(flag) { resolve(flag) };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapFileExistsURL(filepath,_ok,_err)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapDeleteFileURLPromise = function(filepath) {
	var promiseF = function(resolve,reject) {
		var _ok = function() { resolve() };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapDeleteFileURL(filepath,_ok,_err)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapDeleteFilesNotInListURLPromise = function(dirpath, matchRegex, keepList) {
	var promiseF = function(resolve,reject) {
		var _ok = function() {resolve() };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapDeleteFilesNotInListURL(dirpath, matchRegex, keepList, _ok, _err);
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapCopyFileURLPromise = function(srcpath, destdirpath, destname) {
	var promiseF = function(resolve,reject) {
		var _ok = function() { resolve() };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapCopyFileURL(srcpath,destdirpath,destname,_ok,_err)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapMoveFileURLPromise = function(srcpath, destdirpath, destname) {
	var promiseF = function(resolve,reject) {
		var _ok = function() { resolve() };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapMoveFileURL(srcpath,destdirpath,destname,_ok,_err)
	}
	return new Promise(promiseF);
}
DLG1_DlgObj.phoneGapListFilesURLPromise = function(dirpath, matchRegex) {
	var promiseF = function(resolve,reject) {
		var _ok = function(filelist) { resolve(filelist) };
		var _err = function(e) { reject(e) };
		DLG1_DlgObj.phoneGapListFilesURL(dirpath,matchRegex,_ok,_err)
	}
	return new Promise(promiseF);
}
;
// version: 2018-06-24-143455
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    RGraph          = window.RGraph || {isRGraph: true,isRGraphSVG: true};
    RGraph.SVG      = RGraph.SVG || {};
    RGraph.SVG.AJAX = RGraph.SVG.AJAX || {};
// Module pattern
(function (win, doc, undefined)
{
    var RG  = RGraph,
        ua  = navigator.userAgent,
        ma  = Math;
    /**
    * Makes an AJAX call. It calls the given callback (a function) when ready
    * 
    * @param string   url      The URL to retrieve
    * @param function callback A function that is called when the response is ready, there's an example below
    *                          called "myCallback".
    */
    RG.SVG.AJAX = function (url, callback)
    {
        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();
        // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }
        httpRequest.onreadystatechange = function ()
        {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;
                this.__user_callback__(this.responseText);
            }
        }
        httpRequest.open('GET', url, true);
        httpRequest.send();
    };
    /**
    * Makes an AJAX POST request. It calls the given callback (a function) when ready
    * 
    * @param string   url      The URL to retrieve
    * @param object   data     The POST data
    * @param function callback A function that is called when the response is ready, there's an example below
    *                          called "myCallback".
    */
    RG.SVG.AJAX.POST = function (url, data, callback)
    {
        // Used when building the POST string
        var crumbs = [];
        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();
        // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }
        httpRequest.onreadystatechange = function ()
        {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;
                this.__user_callback__(this.responseText);
            }
        }
        httpRequest.open('POST', url, true);
        httpRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        for (i in data) {
            if (typeof i == 'string') {
                crumbs.push(i + '=' + encodeURIComponent(data[i]));
            }
        }
        httpRequest.send(crumbs.join('&'));
    };
    /**
    * Uses the above function but calls the call back passing a number as its argument
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the number as an argument)
    */
    RG.SVG.AJAX.getNumber = function (url, callback)
    {
        RG.SVG.AJAX(url, function ()
        {
            var num = parseFloat(this.responseText);
            callback(num);
        });
    };
    /**
    * Uses the above function but calls the call back passing a string as its argument
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the string as an argument)
    */
    RG.SVG.AJAX.getString = function (url, callback)
    {
        RG.SVG.AJAX(url, function ()
        {
            var str = String(this.responseText);
            callback(str);
        });
    };
    /**
    * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the JSON object as an argument)
    */
    RG.SVG.AJAX.getJSON = function (url, callback)
    {
        RG.SVG.AJAX(url, function ()
        {
            var json = eval('(' + this.responseText + ')');
            callback(json);
        });
    };
    /**
    * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.
    * Useful if you're retrieving CSV data
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the CSV/array as an argument)
    */
    RG.SVG.AJAX.getCSV = function (url, callback)
    {
        var seperator = (typeof arguments[2] === 'string'  ? arguments[2] : ','),
            lineSep   = (typeof arguments[3] === 'string' ? arguments[3] : "\r?\n");
        RG.SVG.AJAX(url, function ()
        {
            var text   = this.responseText,
                regexp = new RegExp(seperator),
                lines  = this.responseText.split(lineSep),
                rows   = [];
            for (var i=0; i<lines.length; ++i) {
                var row = lines[i].split(seperator);
                for (var j=0,len=row.length;j<len;++j) {
                    if (row[j].match(/^[0-9.]+$/)) {
                        row[j] = parseFloat(row[j]);
                    }
                }
                rows.push(row);
            }
            callback(rows);
        });
    };
// End module pattern
})(window, document);;
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    RGraph        = window.RGraph || {isRGraph: true,isRGraphSVG: true};
    RGraph.SVG    = RGraph.SVG    || {};
    RGraph.SVG.FX = RGraph.SVG.FX || {};
// Module pattern
(function (win, doc, undefined)
{
    var RG  = RGraph,
        ua  = navigator.userAgent,
        ma  = Math;
    RG.SVG.REG = {
        store: []
    };
    // ObjectRegistry
    RG.SVG.OR = {objects: []};
    // Used to categorise trigonometery functions
    RG.SVG.TRIG        = {};
    RG.SVG.TRIG.HALFPI = ma.PI * .4999;
    RG.SVG.TRIG.PI     = RG.SVG.TRIG.HALFPI * 2;
    RG.SVG.TRIG.TWOPI  = RG.SVG.TRIG.PI * 2;
    RG.SVG.ISIE = ua.indexOf('rident') > 0;
    RG.SVG.ISFF = ua.indexOf('irefox') > 0;
    RG.SVG.events = [];
    // This allows you to set globalconfiguration values that are copied to
    // all objects automatically.
    RG.SVG.GLOBALS = {};
    RG.SVG.ISFF     = ua.indexOf('Firefox') != -1;
    RG.SVG.ISOPERA  = ua.indexOf('Opera') != -1;
    RG.SVG.ISCHROME = ua.indexOf('Chrome') != -1;
    RG.SVG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;
    RG.SVG.ISWEBKIT = ua.indexOf('WebKit') != -1;
    RG.SVG.ISIE     = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;
    RG.SVG.ISIE6    = ua.indexOf('MSIE 6') > 0;
    RG.SVG.ISIE7    = ua.indexOf('MSIE 7') > 0;
    RG.SVG.ISIE8    = ua.indexOf('MSIE 8') > 0;
    RG.SVG.ISIE9    = ua.indexOf('MSIE 9') > 0;
    RG.SVG.ISIE10   = ua.indexOf('MSIE 10') > 0;
    RG.SVG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;
    RG.SVG.ISIE10UP = RG.SVG.ISIE10 || RG.SVG.ISIE11UP;
    RG.SVG.ISIE9UP  = RG.SVG.ISIE9 || RG.SVG.ISIE10UP;
    //
    // Create an SVG tag
    //
    RG.SVG.createSVG = function (opt)
    {
        var container = opt.container,
            obj       = opt.object;
        if (container.__svg__) {
            return container.__svg__;
        }
        var svg = doc.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute('style', 'top: 0; left: 0; position: absolute');
            svg.setAttribute('width', container.offsetWidth);
            svg.setAttribute('height', container.offsetHeight);
            svg.setAttribute('version', '1.1');
            svg.setAttributeNS("http://www.w3.org/2000/xmlns/", 'xmlns', 'http://www.w3.org/2000/svg');
            svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        container.appendChild(svg);
        container.__svg__ = svg;
        var style = getComputedStyle(container);
        if (style.position !== 'absolute' && style.position !== 'fixed' && style.position !== 'sticky') {
            container.style.position = 'relative';
        }
        // Add the groups that facilitate "background layers"
        var numLayers = 10;
        for (var i=1; i<=numLayers; ++i) {
            var group = RG.SVG.create({
                svg: svg,
                type: 'g',
                attr: {
                    className: 'background' + i
                }
            });
            // Store a reference to the group
            obj.layers['background' + i] = group;
            svg['background' + i]        = group;
        }
        // Add the group tag to the SVG that contains all of the elements
        var group = RG.SVG.create({
            svg: svg,
            type: 'g',
            attr: {
                className: 'all-elements'
            }
        });
        container.__svg__.all = group;
        return svg;
    };
    //
    // Create a defs tag inside the SVG
    //
    RG.SVG.createDefs = function (obj)
    {
        if (!obj.svg.defs) {
            var defs = RG.SVG.create({
                svg: obj.svg,
                type: 'defs'
            });
            obj.svg.defs = defs;
        }
        return defs;
    };
    //
    // Creates a tag depending on the args that you give
    //
    //@param opt object The options for the function
    //
    RG.SVG.create = function (opt)
    {
        var ns  = "http://www.w3.org/2000/svg",
            tag = doc.createElementNS(ns, opt.type);
        // Add the attributes
        for (var o in opt.attr) {
            if (typeof o === 'string') {
                var name = o;
                if (o === 'className') {
                    name = 'class';
                }
                if ( (opt.type === 'a' || opt.type === 'image') && o === 'xlink:href') {
                    tag.setAttributeNS('http://www.w3.org/1999/xlink', o, String(opt.attr[o]));
                } else {
                    tag.setAttribute(name, String(opt.attr[o]));
                }
            }
        }
        // Add the style
        for (var o in opt.style) {
            if (typeof o === 'string') {
                tag.style[o] = String(opt.style[o]);
            }
        }
        if (opt.parent) {
            opt.parent.appendChild(tag);
        } else {
            opt.svg.appendChild(tag);
        }
        return tag;
    };
    //
    // Function that adds up all of the offsetLeft and offsetTops to get
    // X/Y coords for the mouse
    //
    //@param object e The event object
    //@return array   The X/Y coordinate pair representing the mouse
    //                location in relation to the SVG tag.
    //
    RG.SVG.getMouseXY = function(e)
    {
        // This is necessary for IE9
        if (!e.target) {
            return;
        }
        var el = e.target, offsetX = 0, offsetY = 0, x, y;
        if (typeof el.offsetParent !== 'undefined') { 
            do {
                offsetX += el.offsetLeft;
                offsetY += el.offsetTop;
            } while ((el = el.offsetParent));
        }
        x = e.pageX;
        y = e.pageY;
        x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));
        y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));
        // We return a javascript array with x and y defined
        return [x, y];
    };
    //
    // Draws an X axis
    //
    //@param The chart object
    //
    RG.SVG.drawXAxis = function (obj)
    {
        var prop = obj.properties;
        // Draw the axis
        if (prop.xaxis) {
            var y = obj.type === 'hbar' ? obj.height - prop.gutterBottom : obj.getYCoord(obj.scale.min < 0 && obj.scale.max < 0 ? obj.scale.max : (obj.scale.min > 0 && obj.scale.max > 0 ? obj.scale.min : 0));
            var axis = RG.SVG.create({
                svg: obj.svg,
                parent: obj.svg.all,
                type: 'path',
                attr: {
                    d: 'M{1} {2} L{3} {4}'.format(
                        prop.gutterLeft,
                        y,
                        obj.width - prop.gutterRight,
                        y
                    ),
                    fill: prop.xaxisColor,
                    stroke: prop.xaxisColor,
                    'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1,
                    'shape-rendering': 'crispEdges',
                    'stroke-linecap': 'square'
                }
            });
            // HBar X axis
            if (obj.type === 'hbar') {
                var width  = obj.graphWidth / obj.data.length,
                    x      = prop.gutterLeft,
                    startY = (obj.height - prop.gutterBottom),
                    endY   = (obj.height - prop.gutterBottom) + prop.xaxisTickmarksLength;
            // Line/Bar/Waterfall/Scatter X axis
            } else {
                var width  = obj.graphWidth / obj.data.length,
                    x      = prop.gutterLeft,
                    startY = obj.getYCoord(0) - (prop.yaxisMin < 0 ? prop.xaxisTickmarksLength : 0),
                    endY   = obj.getYCoord(0) + prop.xaxisTickmarksLength;
                if (obj.scale.min < 0 && obj.scale.max <= 0) {
                    startY = prop.gutterTop;
                    endY   = prop.gutterTop - prop.xaxisTickmarksLength;
                }
                if (obj.scale.min > 0 && obj.scale.max > 0) {
                    startY = obj.getYCoord(obj.scale.min);
                    endY   = obj.getYCoord(obj.scale.min) + prop.xaxisTickmarksLength;
                }
            }
            // Draw the tickmarks
            if (prop.xaxisTickmarks) {
                // The HBar uses a scale
                if (prop.xaxisScale) {
                    for (var i=0; i<(typeof prop.xaxisLabelsPositionEdgeTickmarksCount === 'number' ? prop.xaxisLabelsPositionEdgeTickmarksCount : (obj.scale.numlabels + (prop.yaxis && prop.xaxisMin === 0 ? 0 : 1))); ++i) {
                        if (obj.type === 'hbar') {
                            var dataPoints = obj.data.length;
                        }
                        x = prop.gutterLeft + ((i+(prop.yaxis && prop.xaxisMin === 0 ? 1 : 0)) * (obj.graphWidth / obj.scale.numlabels));
                        // Allow Manual specification of number of tickmarks
                        if (typeof prop.xaxisLabelsPositionEdgeTickmarksCount === 'number') {
                            dataPoints = prop.xaxisLabelsPositionEdgeTickmarksCount;
                            var gap    = (obj.graphWidth / prop.xaxisLabelsPositionEdgeTickmarksCount);
                            x          = (gap * i) + prop.gutterLeft + gap;
                        }
                        RG.SVG.create({
                            svg: obj.svg,
                            parent: obj.svg.all,
                            type: 'path',
                            attr: {
                                d: 'M{1} {2} L{3} {4}'.format(
                                    x,
                                    startY,
                                    x,
                                    endY
                                ),
                                stroke: prop.xaxisColor,
                                'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1,
                                'shape-rendering': "crispEdges"
                            }
                        });
                    }
                } else {
                    // This style is used by Bar and Scatter charts
                    if (prop.xaxisLabelsPosition === 'section') {
                        if (obj.type === 'bar' || obj.type === 'waterfall') {
                            var dataPoints = obj.data.length;
                        } else if (obj.type === 'line'){
                            var dataPoints = obj.data[0].length;
                        } else if (obj.type === 'scatter') {
                            var dataPoints = prop.xaxisLabels ? prop.xaxisLabels.length : 10;
                        }
                        // Allow Manual specification of number of tickmarks
                        if (typeof prop.xaxisLabelsPositionSectionTickmarksCount === 'number') {
                            dataPoints = prop.xaxisLabelsPositionSectionTickmarksCount;
                        }
                        for (var i=0; i<dataPoints; ++i) {
                            x = prop.gutterLeft + ((i+1) * (obj.graphWidth / dataPoints));
                            RG.SVG.create({
                                svg: obj.svg,
                                parent: obj.svg.all,
                                type: 'path',
                                attr: {
                                    d: 'M{1} {2} L{3} {4}'.format(
                                        x + 0.001,
                                        startY,
                                        x,
                                        endY
                                    ),
                                    stroke: prop.xaxisColor,
                                    'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1,
                                    'shape-rendering': "crispEdges"
                                }
                            });
                        }
                    // This style is used by line charts
                    } else if (prop.xaxisLabelsPosition === 'edge') {
                        if (typeof prop.xaxisLabelsPositionEdgeTickmarksCount === 'number') {
                            var len = prop.xaxisLabelsPositionEdgeTickmarksCount;
                        } else {
                            var len = obj.data && obj.data[0] && obj.data[0].length ? obj.data[0].length : 0;
                        }
                        for (var i=0; i<len; ++i) {
                            var gap = ( (obj.graphWidth) / (len - 1)),
                                x   = prop.gutterLeft + ((i+1) * gap);
                            RG.SVG.create({
                                svg: obj.svg,
                                parent: obj.svg.all,
                                type: 'path',
                                attr: {
                                    d: 'M{1} {2} L{3} {4}'.format(
                                        x + 0.001,
                                        startY,
                                        x,
                                        endY
                                    ),
                                    stroke: prop.xaxisColor,
                                    'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1,
                                    'shape-rendering': "crispEdges"
                                }
                            });
                        }
                    }
                }
                // Draw an extra tick if the Y axis is not being shown
                if (prop.yaxis === false) {
                    RG.SVG.create({
                        svg: obj.svg,
                        parent: obj.svg.all,
                        type: 'path',
                        attr: {
                            d: 'M{1} {2} L{3} {4}'.format(
                                prop.gutterLeft + 0.001,
                                startY,
                                prop.gutterLeft,
                                endY
                            ),
                            stroke: obj.properties.xaxisColor,
                            'stroke-width': typeof prop.xaxisLinewidth === 'number' ? prop.xaxisLinewidth : 1,
                            'shape-rendering': "crispEdges",
                            parent: obj.svg.all,
                        }
                    });
                }
            }
        }
        //
        // Draw an X axis scale
        //
        if (prop.xaxisScale) {
            if (obj.type === 'scatter') {
                obj.xscale = RG.SVG.getScale({
                    object:    obj,
                    numlabels: prop.xaxisLabelsCount,
                    unitsPre:  prop.xaxisUnitsPre,
                    unitsPost: prop.xaxisUnitsPost,
                    max:       prop.xaxisMax,
                    min:       prop.xaxisMin,
                    point:     prop.xaxisPoint,
                    round:     prop.xaxisRound,
                    thousand:  prop.xaxisThousand,
                    decimals:  prop.xaxisDecimals,
                    strict:    typeof prop.xaxisMax === 'number',
                    formatter: prop.xaxisFormatter
                });
                var segment = obj.graphWidth / prop.xaxisLabelsCount
                for (var i=0; i<obj.xscale.labels.length; ++i) {
                    var x = prop.gutterLeft + (segment * i) + segment + prop.xaxisLabelsOffsetx;
                    var y = (obj.height - prop.gutterBottom) + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;
                    RG.SVG.text({
                        object: obj,
                        parent: obj.svg.all,
                        text:   obj.xscale.labels[i],
                        x:      x,
                        y:      y,
                        halign: 'center',
                        valign: 'top',
                        tag:    'labels.xaxis',
                        font:   prop.xaxisTextFont   || prop.textFont,
                        size:   prop.xaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                        bold:   prop.xaxisTextBold   || prop.textBold,
                        italic: prop.xaxisTextItalic || prop.textItalic,
                        color:  prop.xaxisTextColor  || prop.textColor
                    });
                }
                // Add the minimum label if labels are enabled
                if (prop.xaxisLabelsCount > 0) {
                    var y   = obj.height - prop.gutterBottom + prop.xaxisLabelsOffsety + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10),
                        str = RG.SVG.numberFormat({
                            object:     obj,
                            num:        prop.xaxisMin.toFixed(prop.xaxisDecimals),
                            prepend:    prop.xaxisUnitsPre,
                            append:     prop.xaxisUnitsPost,
                            point:      prop.xaxisPoint,
                            thousand:   prop.xaxisThousand,
                            formatter:  prop.xaxisFormatter
                        });
                    var text = RG.SVG.text({
                        object: obj,
                        parent: obj.svg.all,
                        text: typeof prop.xaxisFormatter === 'function' ? (prop.xaxisFormatter)(this, prop.xaxisMin) : str,
                        x: prop.gutterLeft + prop.xaxisLabelsOffsetx,
                        y: y,
                        halign: 'center',
                        valign: 'top',
                        tag:    'labels.xaxis',
                        font:   prop.xaxisTextFont   || prop.textFont,
                        size:   prop.xaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                        bold:   prop.xaxisTextBold   || prop.textBold,
                        italic: prop.xaxisTextItalic || prop.textItalic,
                        color:  prop.xaxisTextColor  || prop.textColor
                    });
                }
            // =========================================================================
            } else {
                var segment = obj.graphWidth / prop.xaxisLabelsCount,
                    scale   = obj.scale;
                for (var i=0; i<scale.labels.length; ++i) {
                    var x = prop.gutterLeft + (segment * i) + segment + prop.xaxisLabelsOffsetx;
                    var y = (obj.height - prop.gutterBottom) + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;
                    RG.SVG.text({
                        object: obj,
                        parent: obj.svg.all,
                        text:   obj.scale.labels[i],
                        x:      x,
                        y:      y,
                        halign: 'center',
                        valign: 'top',
                        tag:    'labels.xaxis',
                        font:   prop.xaxisTextFont   || prop.textFont,
                        size:   prop.xaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                        bold:   prop.xaxisTextBold   || prop.textBold,
                        italic: prop.xaxisTextItalic || prop.textItalic,
                        color:  prop.xaxisTextColor  || prop.textColor
                    });
                }
                // Add the minimum label if labels are enabled
                if (prop.xaxisLabelsCount > 0) {
                    var y   = obj.height - prop.gutterBottom + prop.xaxisLabelsOffsety + (prop.xaxis ? prop.xaxisTickmarksLength + 6 : 10),
                        str = RG.SVG.numberFormat({
                            object:     obj,
                            num:        prop.xaxisMin.toFixed(prop.xaxisDecimals),
                            prepend:    prop.xaxisUnitsPre,
                            append:     prop.xaxisUnitsPost,
                            point:      prop.xaxisPoint,
                            thousand:   prop.xaxisThousand,
                            formatter:  prop.xaxisFormatter
                        });
                    var text = RG.SVG.text({
                        object: obj,
                        parent: obj.svg.all,
                        text: typeof prop.xaxisFormatter === 'function' ? (prop.xaxisFormatter)(this, prop.xaxisMin) : str,
                        x: prop.gutterLeft + prop.xaxisLabelsOffsetx,
                        y: y,
                        halign: 'center',
                        valign: 'top',
                        tag:    'labels.xaxis',
                        font:   prop.xaxisTextFont   || prop.textFont,
                        size:   prop.xaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                        bold:   prop.xaxisTextBold   || prop.textBold,
                        italic: prop.xaxisTextItalic || prop.textItalic,
                        color:  prop.xaxisTextColor  || prop.textColor
                    });
                }
            }
        //
        // Draw the X axis labels
        //
        } else {
            if (typeof prop.xaxisLabels === 'object' && !RG.SVG.isNull(prop.xaxisLabels) ) {
                var angle = prop.xaxisTextAngle;
                // Loop through the X labels
                if (prop.xaxisLabelsPosition === 'section') {
                    var segment = (obj.width - prop.gutterLeft - prop.gutterRight) / prop.xaxisLabels.length;
                    for (var i=0; i<prop.xaxisLabels.length; ++i) {
                        var x = prop.gutterLeft + (segment / 2) + (i * segment);
                        if (obj.scale.max <=0 && obj.scale.min < obj.scale.max) {
                            var y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10)  - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;
                            var valign = 'bottom';
                        } else {
                            var y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;
                            var valign = 'top';
                        }
                        RG.SVG.text({
                            object: obj,
                            parent: obj.svg.all,
                            text: prop.xaxisLabels[i],
                            x: x + prop.xaxisLabelsOffsetx,
                            y: y,
                            valign: (typeof angle === 'number' && angle) ? 'center' : valign,
                            halign: (typeof angle === 'number' && angle) ? 'right' : 'center',
                            angle: angle,
                            tag:    'labels.xaxis',
                            size:   prop.xaxisTextSize   || prop.textSize,
                            italic: prop.xaxisTextItalic || prop.textItalic,
                            font:   prop.xaxisTextFont   || prop.textFont,
                            bold:   prop.xaxisTextBold   || prop.textBold,
                            color:  prop.xaxisTextColor  || prop.textColor
                        });
                    }
                } else if (prop.xaxisLabelsPosition === 'edge') {
                    if (obj.type === 'line') {
                        var hmargin = prop.hmargin;
                    } else {
                        var hmargin = 0;
                    }
                    var segment = (obj.graphWidth - hmargin - hmargin) / (prop.xaxisLabels.length - 1);
                    for (var i=0; i<prop.xaxisLabels.length; ++i) {
                        var x = prop.gutterLeft + (i * segment) + hmargin;
                        if (obj.scale.max <= 0 && obj.scale.min < 0) {
                            valign = 'bottom';
                            y = prop.gutterTop - (RG.SVG.ISFF ? 5 : 10) - (prop.xaxisTickmarksLength - 5)  - (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety
                        } else {
                            valign = 'top';
                            y = obj.height - prop.gutterBottom + (RG.SVG.ISFF ? 5 : 10) + (prop.xaxisTickmarksLength - 5) + (prop.xaxisLinewidth || 1) + prop.xaxisLabelsOffsety;
                        }
                        RG.SVG.text({
                            object: obj,
                            parent: obj.svg.all,
                            text: prop.xaxisLabels[i],
                            x: x + prop.xaxisLabelsOffsetx,
                            y: y,
                            valign: (typeof angle === 'number' && angle) ? 'center' : valign,
                            halign: (typeof angle === 'number' && angle) ? 'right' : 'center',
                            angle: angle,
                            tag:    'labels.xaxis',
                            size:   prop.xaxisTextSize   ||  prop.textSize,
                            italic: prop.xaxisTextItalic ||  prop.textItalic,
                            font:   prop.xaxisTextFont   ||  prop.textFont,
                            bold:   prop.xaxisTextBold   ||  prop.textBold,
                            color:  prop.xaxisTextColor  ||  prop.textColor
                        });
                    }
                }
            }
        }
    };
    //
    // Draws an Y axis
    //
    //@param The chart object
    //
    RG.SVG.drawYAxis = function (obj)
    {
        var prop = obj.properties;
        if (prop.yaxis) {
            // The X coordinate that the Y axis is positioned at
            if (obj.type === 'hbar') {
                var x = obj.getXCoord(prop.xaxisMin > 0 ? prop.xaxisMin : 0);
                if (prop.xaxisMin < 0 && prop.xaxisMax <= 0) {
                    x = obj.getXCoord(prop.xaxisMax);
                }
            } else {
                var x = prop.gutterLeft;
            }
            var axis = RG.SVG.create({
                svg: obj.svg,
                parent: obj.svg.all,
                type: 'path',
                attr: {
                    d: 'M{1} {2} L{3} {4}'.format(
                        x,
                        prop.gutterTop,
                        x,
                        obj.height - prop.gutterBottom
                    ),
                    stroke: prop.yaxisColor,
                    fill: prop.yaxisColor,
                    'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1,
                    'shape-rendering': "crispEdges",
                    'stroke-linecap': 'square'
                }
            });
            if (obj.type === 'hbar') {
                var height = (obj.graphHeight - prop.vmarginTop - prop.vmarginBottom) / prop.yaxisLabels.length,
                    y      = prop.gutterTop + prop.vmarginTop,
                    len    = prop.yaxisLabels.length,
                    startX = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0),
                    endX   = obj.getXCoord(0) - prop.yaxisTickmarksLength;
                if (prop.xaxisMin < 0 && prop.xaxisMax <=0) {
                    startX = obj.getXCoord(prop.xaxisMax);
                    endX   = obj.getXCoord(prop.xaxisMax) + 5;
                }
                // A custom number of tickmarks
                if (typeof prop.yaxisLabelsPositionSectionTickmarksCount === 'number') {
                    len    = prop.yaxisLabelsPositionSectionTickmarksCount;
                    height = (obj.graphHeight - prop.vmarginTop - prop.vmarginBottom) / len;
                }
                //
                // Draw the tickmarks
                //
                if (prop.yaxisTickmarks) {
                    for (var i=0; i<len; ++i) {
                        // Draw the axis
                        var axis = RG.SVG.create({
                            svg: obj.svg,
                            parent: obj.svg.all,
                            type: 'path',
                            attr: {
                                d: 'M{1} {2} L{3} {4}'.format(
                                    startX,
                                    y,
                                    endX,
                                    y + 0.001
                                ),
                                stroke: prop.yaxisColor,
                                'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1,
                                'shape-rendering': "crispEdges"
                            }
                        });
                        y += height;
                    }
                    // Draw an extra tick if the X axis position is not zero or
                    // if the xaxis is not being shown
                    if (prop.xaxis === false) {
                        if (obj.type === 'hbar' && prop.xaxisMin <= 0 && prop.xaxisMax < 0) {
                            var startX = obj.getXCoord(prop.xaxisMax);
                            var endX   = obj.getXCoord(prop.xaxisMax) + prop.yaxisTickmarksLength;
                        } else {
                            var startX = obj.getXCoord(0) - prop.yaxisTickmarksLength;
                            var endX   = obj.getXCoord(0) + (prop.xaxisMin < 0 ? prop.yaxisTickmarksLength : 0);
                        }
                        var axis = RG.SVG.create({
                            svg: obj.svg,
                            parent: obj.svg.all,
                            type: 'path',
                            attr: {
                                d: 'M{1} {2} L{3} {4}'.format(
                                    startX,
                                    ma.round(obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom)),
                                    endX,
                                    ma.round(obj.height - prop.gutterBottom - parseFloat(prop.vmarginBottom))
                                ),
                                stroke: obj.properties.yaxisColor,
                                'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1,
                                'shape-rendering': "crispEdges"
                            }
                        });
                    }
                }
            //
            // Bar, Line etc types of chart
            //
            } else {
                var height = obj.graphHeight / prop.yaxisLabelsCount,
                    y      = prop.gutterTop,
                    len    = prop.yaxisLabelsCount,
                    startX = prop.gutterLeft,
                    endX   = prop.gutterLeft - prop.yaxisTickmarksLength;
                // A custom number of tickmarks
                if (typeof prop.yaxisLabelsPositionEdgeTickmarksCount === 'number') {
                    len    = prop.yaxisLabelsPositionEdgeTickmarksCount;
                    height = obj.graphHeight / len;
                }
                //
                // Draw the tickmarks
                //
                if (prop.yaxisTickmarks) {
                    for (var i=0; i<len; ++i) {
                        // Draw the axis
                        var axis = RG.SVG.create({
                            svg: obj.svg,
                            parent: obj.svg.all,
                            type: 'path',
                            attr: {
                                d: 'M{1} {2} L{3} {4}'.format(
                                    startX,
                                    y,
                                    endX,
                                    y
                                ),
                                stroke: prop.yaxisColor,
                                'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1,
                                'shape-rendering': "crispEdges"
                            }
                        });
                        y += height;
                    }
                    // Draw an extra tick if the X axis position is not zero or
                    //if the xaxis is not being shown
                    if (    (prop.yaxisMin !== 0 || prop.xaxis === false)
                        && !(obj.scale.min > 0 && obj.scale.max > 0) ) {
                        var axis = RG.SVG.create({
                            svg: obj.svg,
                            parent: obj.svg.all,
                            type: 'path',
                            attr: {
                                d: 'M{1} {2} L{3} {4}'.format(
                                    prop.gutterLeft - prop.yaxisTickmarksLength,
                                    obj.height - prop.gutterBottom,
                                    prop.gutterLeft,
                                    obj.height - prop.gutterBottom - 0.001
                                ),
                                stroke: prop.yaxisColor,
                                'stroke-width': typeof prop.yaxisLinewidth === 'number' ? prop.yaxisLinewidth : 1,
                                'shape-rendering': "crispEdges"
                            }
                        });
                    }
                }
            }
        }
        //
        // Draw the Y axis labels
        //
        if (prop.yaxisScale) {
            var segment = (obj.height - prop.gutterTop - prop.gutterBottom) / prop.yaxisLabelsCount;
            for (var i=0; i<obj.scale.labels.length; ++i) {
                var y = obj.height - prop.gutterBottom - (segment * i) - segment;
                RG.SVG.text({
                    object: obj,
                    parent: obj.svg.all,
                    text:   obj.scale.labels[i],
                    x:      prop.gutterLeft - 7 - (prop.yaxis ? (prop.yaxisTickmarksLength - 3) : 0) + prop.yaxisLabelsOffsetx,
                    y:      y + prop.yaxisLabelsOffsety,
                    halign: prop.yaxisLabelsHalign || 'right',
                    valign: prop.yaxisLabelsValign || 'center',
                    tag:    'labels.yaxis',
                    font:   prop.yaxisTextFont   || prop.textFont,
                    size:   prop.yaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                    bold:   prop.yaxisTextBold   || prop.textBold,
                    italic: prop.yaxisTextItalic || prop.textItalic,
                    color:  prop.yaxisTextColor  || prop.textColor
                });
            }
            //
            // Add the minimum label
            //
            var y   = obj.height - prop.gutterBottom,
                str = (prop.yaxisUnitsPre + prop.yaxisMin.toFixed(prop.yaxisDecimals).replace(/\./, prop.yaxisPoint) + prop.yaxisUnitsPost);
            var text = RG.SVG.text({
                object: obj,
                parent: obj.svg.all,
                text: typeof prop.yaxisFormatter === 'function' ? (prop.yaxisFormatter)(this, prop.yaxisMin) : str,
                x: prop.gutterLeft - 7 - (prop.yaxis ? (prop.yaxisTickmarksLength - 3) : 0) + prop.yaxisLabelsOffsetx,
                y: y + prop.yaxisLabelsOffsety,
                halign: 'right',
                valign: 'center',
                tag:    'labels.yaxis',
                font:   prop.yaxisTextFont   || prop.textFont,
                size:   prop.yaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                bold:   prop.yaxisTextBold   || prop.textBold,
                italic: prop.yaxisTextItalic || prop.textItalic,
                color:  prop.yaxisTextColor  || prop.textColor
            });
        //
        // Draw Y axis labels (eg when specific labels are defined or
        //the chart is an HBar
        //
        } else if (prop.yaxisLabels && prop.yaxisLabels.length) {
            for (var i=0; i<prop.yaxisLabels.length; ++i) {
                var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0) ) / prop.yaxisLabels.length,
                    y       = prop.gutterTop + (prop.vmarginTop || 0) + (segment * i) + (segment / 2) + prop.yaxisLabelsOffsety,
                    x       = prop.gutterLeft - 7 /*- (prop.yaxis ? (prop.yaxisTickmarksLength) : 0)*/ - (prop.yaxisLinewidth || 1) + prop.yaxisLabelsOffsetx,
                    halign  = 'right';
                // HBar labels
                if (obj.type === 'hbar' && obj.scale.min < obj.scale.max && obj.scale.max <= 0) {
                    halign = 'left';
                    x      = obj.width - prop.gutterRight + 7 + prop.yaxisLabelsOffsetx;
                // HBar labels (again?)
                } else if (obj.type === 'hbar' && !prop.yaxisLabelsSpecific) {
                    var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0) ) / (prop.yaxisLabels.length);
                    y = prop.gutterTop + (prop.vmarginTop || 0) + (segment * i) + (segment / 2) + prop.yaxisLabelsOffsety;
                // Specific scale
                } else {
                    var segment = (obj.graphHeight - (prop.vmarginTop || 0) - (prop.vmarginBottom || 0) ) / (prop.yaxisLabels.length - 1);
                    y = obj.height - prop.gutterBottom - (segment * i) + prop.yaxisLabelsOffsety;
                }
                var text = RG.SVG.text({
                    object: obj,
                    parent: obj.svg.all,
                    text:   prop.yaxisLabels[i] ? prop.yaxisLabels[i] : '',
                    x:      x,
                    y:      y,
                    halign: halign,
                    valign: 'center',
                    tag:    'labels.yaxis',
                    font:   prop.yaxisTextFont   || prop.textFont,
                    size:   prop.yaxisTextSize   || (typeof prop.textSize === 'number' ? prop.textSize + 'pt' : prop.textSize),
                    bold:   typeof prop.yaxisTextBold === 'boolean' ? prop.yaxisTextBold : prop.textBold,
                    italic: typeof prop.yaxisTextItalic === 'boolean' ? prop.yaxisTextItalic : prop.textItalic,
                    color:  prop.yaxisTextColor  || prop.textColor
                });
            }
        }
    };
    //
    // Draws the background
    //
    //@param The chart object
    //
    RG.SVG.drawBackground = function (obj)
    {
        var prop = obj.properties;
        // Set these properties so that if it doesn't exist things don't fail
        if (typeof prop.variant3dOffsetx !== 'number') prop.variant3dOffsetx = 0;
        if (typeof prop.variant3dOffsety !== 'number') prop.variant3dOffsety = 0;
        if (prop.backgroundColor) {
            RG.SVG.create({
                svg:  obj.svg,
                parent: obj.svg.all,
                type: 'rect',
                attr: {
                    x: -1 + prop.variant3dOffsetx + prop.gutterLeft,
                    y: -1 - prop.variant3dOffsety + prop.gutterTop,
                    width: parseFloat(obj.svg.getAttribute('width')) + 2 - prop.gutterLeft - prop.gutterRight,
                    height: parseFloat(obj.svg.getAttribute('height')) + 2 - prop.gutterTop - prop.gutterBottom,
                    fill: prop.backgroundColor
                }
            });
        }
        // Render a background image
        // <image xlink:href="firefox.jpg" x="0" y="0" height="50px" width="50px"/>
        if (prop.backgroundImage) {
            var attr = {
                'xlink:href': prop.backgroundImage,
                //preserveAspectRatio: 'xMidYMid slice',
                preserveAspectRatio: prop.backgroundImageAspect || 'none',
                x: prop.gutterLeft,
                y: prop.gutterTop
            };
            if (prop.backgroundImageStretch) {
                attr.x      = prop.gutterLeft + prop.variant3dOffsetx;
                attr.y      = prop.gutterTop + prop.variant3dOffsety;
                attr.width  = obj.width - prop.gutterLeft - prop.gutterRight;
                attr.height = obj.height - prop.gutterTop - prop.gutterBottom;
            } else {
                if (typeof prop.backgroundImageX === 'number') {
                    attr.x =  prop.backgroundImageX + prop.variant3dOffsetx;
                } else {
                    attr.x =  prop.gutterLeft + prop.variant3dOffsetx;
                }
                if (typeof prop.backgroundImageY === 'number') {
                    attr.y =  prop.backgroundImageY + prop.variant3dOffsety;
                } else {
                    attr.y =  prop.gutterTop + prop.variant3dOffsety;
                }
                if (typeof prop.backgroundImageW === 'number') {
                    attr.width =  prop.backgroundImageW;
                }
                if (typeof prop.backgroundImageH === 'number') {
                    attr.height =  prop.backgroundImageH;
                }
            }
            //
            // Account for the chart being 3d
            //
            if (prop.variant === '3d') {
                attr.x += prop.variant3dOffsetx;
                attr.y -= prop.variant3dOffsety;
            }
            var img = RG.SVG.create({
                svg:  obj.svg,
                parent: obj.svg.all,
                type: 'image',
                attr: attr,
                style: {
                    opacity: typeof prop.backgroundImageOpacity === 'number' ? prop.backgroundImageOpacity : 1
                }
            });
            // Set the width and height if necessary
            if (!prop.backgroundImageStretch) {
                var img2    = new Image();
                img2.src    = prop.backgroundImage;
                img2.onload = function ()
                {
                    img.setAttribute('width', typeof prop.backgroundImageW === 'number' ? prop.backgroundImageW : img2.width);
                    img.setAttribute('height', typeof prop.backgroundImageH === 'number' ? prop.backgroundImageH : img2.height);
                };
            }
        }
        if (prop .backgroundGrid) {
            var parts = [];
            // Add the horizontal lines to the path
            if (prop.backgroundGridHlines) {
                if (typeof prop.backgroundGridHlinesCount === 'number') {
                    var count = prop.backgroundGridHlinesCount;
                } else if (obj.type === 'hbar' || obj.type === 'bipolar') {
                    if (typeof prop.yaxisLabels === 'object' && !RG.SVG.isNull(prop.yaxisLabels) && prop.yaxisLabels.length) {
                        var count = prop.yaxisLabels.length;
                    } else if (obj.type === 'hbar') {
                        var count = obj.data.length;
                    } else if (obj.type === 'bipolar') {
                        var count = obj.left.length;
                    }
                } else {
                    var count = prop.yaxisLabelsCount || 5;
                }
                for (var i=0; i<=count; ++i) {
                    parts.push('M{1} {2} L{3} {4}'.format(
                        prop.gutterLeft + prop.variant3dOffsetx,
                        prop.gutterTop + (obj.graphHeight / count) * i - prop.variant3dOffsety,
                        obj.width - prop.gutterRight + prop.variant3dOffsetx,
                        prop.gutterTop + (obj.graphHeight / count) * i - prop.variant3dOffsety
                    ));
                }
                // Add an extra background grid line to the path - this its
                // underneath the X axis and shows up if its not there.
                parts.push('M{1} {2} L{3} {4}'.format(
                    prop.gutterLeft + prop.variant3dOffsetx,
                    obj.height - prop.gutterBottom - prop.variant3dOffsety,
                    obj.width - prop.gutterRight + prop.variant3dOffsetx,
                    obj.height - prop.gutterBottom - prop.variant3dOffsety
                ));
            }
            // Add the vertical lines to the path
            if (prop.backgroundGridVlines) {
                if (obj.type === 'line' && RG.SVG.isArray(obj.data[0])) {
                    var len = obj.data[0].length;
                } else if (obj.type === 'hbar') {
                    var len = prop.xaxisLabelsCount || 10;
                } else if (obj.type === 'bipolar') {
                    var len = prop.xaxisLabelsCount || 10;
                } else if (obj.type === 'scatter') {
                    var len = (prop.xaxisLabels && prop.xaxisLabels.length) || 10;
                } else if (obj.type === 'waterfall') {
                    var len = obj.data[0].length;
                } else {
                    var len = obj.data.length;
                }
                var count = typeof prop.backgroundGridVlinesCount === 'number' ? prop.backgroundGridVlinesCount : len;
                if (prop.xaxisLabelsPosition === 'edge') {
                    count--;
                }
                for (var i=0; i<=count; ++i) {
                    parts.push('M{1} {2} L{3} {4}'.format(
                        prop.gutterLeft + ((obj.graphWidth / count) * i) + prop.variant3dOffsetx,
                        prop.gutterTop - prop.variant3dOffsety,
                        prop.gutterLeft + ((obj.graphWidth / count) * i) + prop.variant3dOffsetx,
                        obj.height - prop.gutterBottom - prop.variant3dOffsety
                    ));
                }
            }
            // Add the box around the grid
            if (prop.backgroundGridBorder) {
                parts.push('M{1} {2} L{3} {4} L{5} {6} L{7} {8} z'.format(
                    prop.gutterLeft + prop.variant3dOffsetx,
                    prop.gutterTop  - prop.variant3dOffsety,
                    obj.width - prop.gutterRight + prop.variant3dOffsetx,
                    prop.gutterTop - prop.variant3dOffsety,
                    obj.width - prop.gutterRight + prop.variant3dOffsetx,
                    obj.height - prop.gutterBottom - prop.variant3dOffsety,
                    prop.gutterLeft + prop.variant3dOffsetx,
                    obj.height - prop.gutterBottom - prop.variant3dOffsety
                ));
            }
            // Get the dash array if its defined to be dotted or dashed
            var dasharray;
            if (prop.backgroundGridDashed) {
                dasharray = [3,5];
            } else if (prop.backgroundGridDotted) {
                dasharray = [1,3];
            } else if (prop.backgroundGridDashArray) {
                dasharray = prop.backgroundGridDashArray;
            } else {
                dasharray = '';
            }
            // Now draw the path
            var grid = RG.SVG.create({
                svg: obj.svg,
                parent: obj.svg.all,
                type: 'path',
                attr: {
                    className: 'rgraph_background_grid',
                    d: parts.join(' '),
                    stroke: prop.backgroundGridColor,
                    fill: 'rgba(0,0,0,0)',
                    'stroke-width': prop.backgroundGridLinewidth,
                    'shape-rendering': "crispEdges",
                    'stroke-dasharray': dasharray
                },
                style: {
                    pointerEvents: 'none'
                }
            });
        }
        // Draw the title and subtitle
        if (obj.type !== 'bipolar') {
            RG.SVG.drawTitle(obj);
        }
    };
    /**
    * Returns true/false as to whether the given variable is null or not
    * 
    * @param mixed arg The argument to check
    */
    RG.SVG.isNull = function (arg)
    {
        // must BE DOUBLE EQUALS - NOT TRIPLE
        if (arg == null || typeof arg === 'object' && !arg) {
            return true;
        }
        return false;
    };
    /**
    * Returns an appropriate scale. The return value is actualy an object consisting of:
    *  scale.max
    *  scale.min
    *  scale.scale
    * 
    * @param  obj object  The graph object
    * @param  prop object An object consisting of configuration properties
    * @return     object  An object containg scale information
    */
    RG.SVG.getScale = function (opt)
    {
        var obj          = opt.object,
            prop         = obj.properties,
            numlabels    = opt.numlabels,
            unitsPre     = opt.unitsPre,
            unitsPost    = opt.unitsPost,
            max          = Number(opt.max),
            min          = Number(opt.min),
            strict       = opt.strict,
            decimals     = Number(opt.decimals),
            point        = opt.point,
            thousand     = opt.thousand,
            originalMax  = max,
            round        = opt.round,
            scale        = {max:1,labels:[],values:[]},
            formatter    = opt.formatter;
        /**
        * Special case for 0
        * 
        * ** Must be first **
        */
        if (max === 0 && min === 0) {
            var max = 1;
            for (var i=0; i<numlabels; ++i) {
                var label = ((((max - min) / numlabels) * (i + 1)) + min).toFixed(decimals);
                scale.labels.push(unitsPre + label + unitsPost);
                scale.values.push(parseFloat(label))
            }
        /**
        * Manually do decimals
        */
        } else if (max <= 1 && !strict) {
            var arr = [
                1,0.5,
                0.10,0.05,
                0.010,0.005,
                0.0010,0.0005,
                0.00010,0.00005,
                0.000010,0.000005,
                0.0000010,0.0000005,
                0.00000010,0.00000005,
                0.000000010,0.000000005,
                0.0000000010,0.0000000005,
                0.00000000010,0.00000000005,
                0.000000000010,0.000000000005,
                0.0000000000010,0.0000000000005
            ], vals = [];
            for (var i=0; i<arr.length; ++i) {
                if (max > arr[i]) {
                    i--;
                    break;
                }
            }
            scale.max    = arr[i]
            scale.labels = [];
            scale.values = [];
            for (var j=0; j<numlabels; ++j) {
                var value = ((((arr[i] - min) / numlabels) * (j + 1)) + min).toFixed(decimals);
                scale.values.push(value);
                scale.labels.push(RG.SVG.numberFormat({
                    object: obj,
                    num: value,
                    prepend: unitsPre,
                    append: unitsPost,
                    point: prop.yaxisPoint,
                    thousand: prop.yaxisThousand,
                    formatter: formatter
                }));
            }
        } else if (!strict) {
            /**
            * Now comes the scale handling for integer values
            */
            // This accomodates decimals by rounding the max up to the next integer
            max = ma.ceil(max);
            var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)) );
            var topValue = interval;
            while (topValue < max) {
                topValue += (interval / 2);
            }
            // Handles cases where the max is (for example) 50.5
            if (Number(originalMax) > Number(topValue)) {
                topValue += (interval / 2);
            }
            // Custom if the max is greater than 5 and less than 10
            if (max <= 10) {
                topValue = (Number(originalMax) <= 5 ? 5 : 10);
            }
            // Added 02/11/2010 to create "nicer" scales
            if (obj && typeof(round) == 'boolean' && round) {
                topValue = 10 * interval;
            }
            scale.max = topValue;
            for (var i=0; i<numlabels; ++i) {
                var label = RG.SVG.numberFormat({
                    object: obj,
                    num: ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals),
                    prepend: unitsPre,
                    append: unitsPost,
                    point: point,
                    thousand: thousand,
                    formatter: formatter
                });
                scale.labels.push(label);
                scale.values.push(((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals));
            }
        } else if (typeof max === 'number' && strict) {
            /**
            * ymax is set and also strict
            */
            for (var i=0; i<numlabels; ++i) {
                scale.labels.push(RG.SVG.numberFormat({
                    object: obj,
                    formatter: formatter,
                    num: ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals),
                    prepend: unitsPre,
                    append: unitsPost,
                    point: point,
                    thousand: thousand
                }));
                scale.values.push(
                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals)
                );
            }
            // ???
            scale.max = max;
        }
        scale.unitsPre  = unitsPre;
        scale.unitsPost = unitsPost;
        scale.point     = point;
        scale.decimals  = decimals;
        scale.thousand  = thousand;
        scale.numlabels = numlabels;
        scale.round     = Boolean(round);
        scale.min       = min;
        //
        // Convert all of the scale values to numbers
        //
        for (var i=0; i<scale.values.length; ++i) {
            scale.values[i] = parseFloat(scale.values[i]);
        }
        return scale;
    };
    /**
    * Pads/fills the array
    * 
    * @param  array arr The array
    * @param  int   len The length to pad the array to
    * @param  mixed     The value to use to pad the array (optional)
    */
    RG.SVG.arrayFill = 
    RG.SVG.arrayPad  = function (opt)
    {
        var arr   = opt.array,
            len   = opt.length,
            value = (typeof opt.value === 'undefined' ? null : opt.value);
        if (arr.length < len) {            
            for (var i=arr.length; i<len; i+=1) {
                arr[i] = value;
            }
        }
        return arr;
    };
    /**
    * An array sum function
    * 
    * @param  array arr The  array to calculate the total of
    * @return int       The summed total of the arrays elements
    */
    RG.SVG.arraySum = function (arr)
    {
        // Allow integers
        if (typeof arr === 'number') {
            return arr;
        }
        // Account for null
        if (RG.SVG.isNull(arr)) {
            return 0;
        }
        var i, sum, len = arr.length;
        for(i=0,sum=0;i<len;sum+=arr[i++]);
        return sum;
    };
    /**
    * Returns the maximum numeric value which is in an array. This function IS NOT
    * recursive
    * 
    * @param  array arr The array (can also be a number, in which case it's returned as-is)
    * @param  int       Whether to ignore signs (ie negative/positive)
    * @return int       The maximum value in the array
    */
    RG.SVG.arrayMax = function (arr)
    {
        var max = null
        if (typeof arr === 'number') {
            return arr;
        }
        if (RG.SVG.isNull(arr)) {
            return 0;
        }
        for (var i=0,len=arr.length; i<len; ++i) {
            if (typeof arr[i] === 'number') {
                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];
                if (typeof max === 'number') {
                    max = ma.max(max, val);
                } else {
                    max = val;
                }
            }
        }
        return max;
    };
    /**
    * Returns the minimum numeric value which is in an array
    * 
    * @param  array arr The array (can also be a number, in which case it's returned as-is)
    * @param  int       Whether to ignore signs (ie negative/positive)
    * @return int       The minimum value in the array
    */
    RG.SVG.arrayMin = function (arr)
    {
        var max = null,
            min = null,
            ma  = Math;
        if (typeof arr === 'number') {
            return arr;
        }
        if (RG.SVG.isNull(arr)) {
            return 0;
        }
        for (var i=0,len=arr.length; i<len; ++i) {
            if (typeof arr[i] === 'number') {
                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];
                if (typeof min === 'number') {
                    min = ma.min(min, val);
                } else {
                    min = val;
                }
            }
        }
        return min;
    };
    /**
    * Returns the maximum value which is in an array
    * 
    * @param  array arr The array
    * @param  int   len The length to pad the array to
    * @param  mixed     The value to use to pad the array (optional)
    */
    RG.SVG.arrayPad = function (arr, len)
    {
        if (arr.length < len) {
            var val = arguments[2] ? arguments[2] : null;
            for (var i=arr.length; i<len; i+=1) {
                arr[i] = val;
            }
        }
        return arr;
    };
    /**
    * An array sum function
    * 
    * @param  array arr The  array to calculate the total of
    * @return int       The summed total of the arrays elements
    */
    RG.SVG.arraySum = function (arr)
    {
        // Allow integers
        if (typeof arr === 'number') {
            return arr;
        }
        // Account for null
        if (RG.SVG.isNull(arr)) {
            return 0;
        }
        var i, sum, len = arr.length;
        for(i=0,sum=0;i<len;sum+=arr[i++]);
        return sum;
    };
    /**
    * Takes any number of arguments and adds them to one big linear array
    * which is then returned
    * 
    * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays
    */
    RG.SVG.arrayLinearize = function ()
    {
        var arr  = [],
            args = arguments
        for (var i=0,len=args.length; i<len; ++i) {
            if (typeof args[i] === 'object' && args[i]) {
                for (var j=0,len2=args[i].length; j<len2; ++j) {
                    var sub = RG.SVG.arrayLinearize(args[i][j]);
                    for (var k=0,len3=sub.length; k<len3; ++k) {
                        arr.push(sub[k]);
                    }
                }
            } else {
                arr.push(args[i]);
            }
        }
        return arr;
    };
    /**
    * Takes one off the front of the given array and returns the new array.
    * 
    * @param array arr The array from which to take one off the front of array 
    * 
    * @return array The new array
    */
    RG.SVG.arrayShift = function(arr)
    {
        var ret = [];
        for(var i=1,len=arr.length; i<len; ++i) {
            ret.push(arr[i]);
        }
        return ret;
    };
    /**
    * Reverses the order of an array
    * 
    * @param array arr The array to reverse
    */
    RG.SVG.arrayReverse = function (arr)
    {
        if (!arr) {
            return;
        }
        var newarr=[];
        for(var i=arr.length - 1; i>=0; i-=1) {
            newarr.push(arr[i]);
        }
        return newarr;
    };
    /**
    * Makes a clone of an object
    * 
    * @param obj val The object to clone
    */
    RG.SVG.arrayClone = function (obj)
    {
        if(obj === null || typeof obj !== 'object') {
            return obj;
        }
        if (RG.SVG.isArray(obj)) {
            var temp = [];
            for (var i=0,len=obj.length;i<len; ++i) {
                if (typeof obj[i]  === 'number') {
                    temp[i] = (function (arg) {return Number(arg);})(obj[i]);
                } else if (typeof obj[i]  === 'string') {
                    temp[i] = (function (arg) {return String(arg);})(obj[i]);
                } else if (typeof obj[i] === 'function') {
                    temp[i] = obj[i];
                } else {
                    temp[i] = RG.SVG.arrayClone(obj[i]);
                }
            }
        } else if (typeof obj === 'object') {
            var temp = {};
            for (var i in obj) {
                if (typeof i === 'string') {
                    temp[i] = obj[i];
                }
            }
        }
        return temp;
    };
    //
    // Converts an the truthy values to falsey values and vice-versa
    //
    RG.SVG.arrayInvert = function (arr)
    {
        for (var i=0,len=arr.length; i<len; ++i) {
            arr[i] = !arr[i];
        }
        return arr;
    };
    //
    // An array_trim function that removes the empty elements off
    //both ends
    //
    RG.SVG.arrayTrim = function (arr)
    {
        var out = [], content = false;
        // Trim the start
        for (var i=0; i<arr.length; i++) {
            if (arr[i]) {
                content = true;
            }
            if (content) {
                out.push(arr[i]);
            }
        }
        // Reverse the array and trim the start again
        out = RG.SVG.arrayReverse(out);
        var out2 = [], content = false ;
        for (var i=0; i<out.length; i++) {
            if (out[i]) {
                content = true;
            }
            if (content) {
                out2.push(out[i]);
            }
        }
        // Now reverse the array and return it
        out2 = RG.SVG.arrayReverse(out2);
        return out2;
    };
    /**
    * Determines if the given object is an array or not
    * 
    * @param mixed obj The variable to test
    */
    RG.SVG.isArray = function (obj)
    {
        if (obj && obj.constructor) {
            var pos = obj.constructor.toString().indexOf('Array');
        } else {
            return false;
        }
        return obj != null &&
               typeof pos === 'number' &&
               pos > 0 &&
               pos < 20;
    };
    /**
    * Returns the absolute value of a number. You can also pass in an
    * array and it will run the abs() function on each element. It
    * operates recursively so sub-arrays are also traversed.
    * 
    * @param array arr The number or array to work on
    */
    RG.SVG.abs = function (value)
    {
        if (typeof value === 'string') {
            value = parseFloat(value) || 0;
        }
        if (typeof value === 'number') {
            return ma.abs(value);
        }
        if (typeof value === 'object') {
            for (i in value) {
                if (   typeof i === 'string'
                    || typeof i === 'number'
                    || typeof i === 'object') {
                    value[i] = RG.SVG.abs(value[i]);
                }
            }
            return value;
        }
        return 0;
    };
    //
    // Formats a number with thousand seperators so it's easier to read
    //
    // @param opt object The options to the function
    //
    RG.SVG.numberFormat = function (opt)
    {
        var obj                = opt.object,
            prepend            = opt.prepend ? String(opt.prepend) : '',
            append             = opt.append ? String(opt.append) : '',
            output             = '',
            decimal_seperator  = typeof opt.point === 'string' ? opt.point : '.',
            thousand_seperator = typeof opt.thousand === 'string' ? opt.thousand : ',',
            num                = opt.num
            decimals_trim      = opt.decimals_trim;
        RegExp.$1   = '';
        if (typeof opt.formatter === 'function') {
            return opt.formatter(obj, num);
        }
        // Ignore the preformatted version of "1e-2"
        if (String(num).indexOf('e') > 0) {
            return String(prepend + String(num) + append);
        }
        // We need then number as a string
        num = String(num);
        // Take off the decimal part - we re-append it later
        if (num.indexOf('.') > 0) {
            var tmp = num;
            num     = num.replace(/\.(.*)/, ''); // The front part of the number
            decimal = tmp.replace(/(.*)\.(.*)/, '$2'); // The decimal part of the number
        } else {
            decimal = '';
        }
        // Thousand seperator
        //var seperator = arguments[1] ? String(arguments[1]) : ',';
        var seperator = thousand_seperator;
        /**
        * Work backwards adding the thousand seperators
        */
        var foundPoint;
        for (i=(num.length - 1),j=0; i>=0; j++,i--) {
            var character = num.charAt(i);
            if ( j % 3 == 0 && j != 0) {
                output += seperator;
            }
            /**
            * Build the output
            */
            output += character;
        }
        /**
        * Now need to reverse the string
        */
        var rev = output;
        output = '';
        for (i=(rev.length - 1); i>=0; i--) {
            output += rev.charAt(i);
        }
        // Tidy up
        //output = output.replace(/^-,/, '-');
        if (output.indexOf('-' + thousand_seperator) == 0) {
            output = '-' + output.substr(('-' + thousand_seperator).length);
        }
        // Reappend the decimal
        if (decimal.length) {
            output =  output + decimal_seperator + decimal;
            decimal = '';
            RegExp.$1 = '';
        }
        //
        // Trim the decimals if it's all zeros
        //
        if (decimals_trim) {
            output = output.replace(/0+$/,'');
            output = output.replace(/\.$/,'');
        }
        // Minor bugette
        if (output.charAt(0) == '-') {
            output = output.replace(/-/, '');
            prepend = '-' + prepend;
        }
        return prepend + output + append;
    };
    //
    // A function that adds text to the chart
    //
    RG.SVG.text = function (opt)
    {
        var obj        = opt.object,
            parent     = opt.parent || opt.object.svg.all,
            size       = typeof opt.size === 'number' ? opt.size + 'pt' : (typeof opt.size === 'string' ? opt.size.replace(/pt$/,'') : 12) + 'pt',
            bold       = opt.bold ? 'bold' : 'normal',
            font       = opt.font ? opt.font : 'sans-serif',
            italic     = opt.italic ? 'italic' : 'normal',
            halign     = opt.halign,
            valign     = opt.valign,
            str        = opt.text,
            x          = opt.x,
            y          = opt.y,
            color      = opt.color ? opt.color : 'black',
            background = opt.background || null,
            padding    = opt.padding || 0,
            link       = opt.link || '',
            linkTarget = opt.linkTarget || '_blank',
            events     = (opt.events === false ? false : true),
            angle      = opt.angle;
        //
        // Change numbers to strings
        //
        if (typeof str === 'number') {
            str = String(str);
        }
        //
        // If the string starts with a carriage return add a unicode non-breaking
        // space to the start of it.
        //
        if (str.substr(0,2) == '\r\n' || str.substr(0,1) === '\n') {
            str = "\u00A0" + str;
        }
        // Horizontal alignment
        if (halign === 'right') {
            halign = 'end';
        } else if (halign === 'center' || halign === 'middle') {
            halign = 'middle';
        } else {
            halign = 'start';
        }
        // Vertical alignment
        if (valign === 'top') {
            valign = 'hanging';
        } else if (valign === 'center' || valign === 'middle') {
            valign = 'central';
            valign = 'middle';
        } else {
            valign = 'bottom';
        }
        //
        // If a link has been specified then the text node should
        // be a child of an a node
        if (link) {
            var a = RGraph.SVG.create({
                svg: obj.svg,
                type: 'a',
                parent: parent,
                attr: {
                    'xlink:href': link,
                    target: linkTarget
                }
            });
        }
        //
        // Text does not include carriage returns
        //
        if (str && str.indexOf && str.indexOf("\n") === -1) {
            var text = RG.SVG.create({
                svg: obj.svg,
                parent: link ? a : opt.parent,
                type: 'text',
                attr: {
                    tag: opt.tag ? opt.tag : '',
                    fill: color,
                    x: x,
                    y: y,
                    'font-size':         size,
                    'font-weight':       bold,
                    'font-family':       font,
                    'font-style':        italic,
                    'text-anchor':       halign,
                    'dominant-baseline': valign
                }
            });
            var textNode = document.createTextNode(str);
            text.appendChild(textNode);
            if (!events) {
                text.style.pointerEvents = 'none';
            }
        //
        // Includes carriage returns
        //
        } else if (str && str.indexOf) {
            // Measure the text
            var dimensions = RG.SVG.measureText({
                text: 'My',
                bold: bold,
                font: font,
                size: size
            });
            var lineHeight = dimensions[1];
            str = str.split(/\r?\n/);
            //
            // Account for the carriage returns and move the text
            // up as required
            //
            if (valign === 'bottom') {
                y -= str.length * lineHeight;
            }
            if (valign === 'center' || valign === 'middle') {
                y -= (str.length * lineHeight) / 2;
            }
            var text = RG.SVG.create({
                svg: obj.svg,
                parent: link ? a : opt.parent,
                type: 'text',
                attr: {
                    tag: opt.tag ? opt.tag : '',
                    fill: color,
                    x: x,
                    y: y,
                    'font-size':         size,
                    'font-weight':       bold,
                    'font-family':       font,
                    'font-style':        italic,
                    'text-anchor':       halign,
                    'dominant-baseline': valign
                }
            });
            if (!events) {
                text.style.pointerEvents = 'none';
            }
            for (var i=0; i<str.length; ++i) {
                var tspan = RG.SVG.create({
                    svg: obj.svg,
                    parent: text,
                    type: 'tspan',
                    attr: {
                        x: x,
                        dy: dimensions ? (dimensions[1] * (i ? 1 : 0)) + 3 : 0
                    }
                });
                var textNode = document.createTextNode(str[i]);
                tspan.appendChild(textNode);
                if (!events) {
                    tspan.style.pointerEvents = 'none';
                }
                var dimensions = RG.SVG.measureText({
                    text: str[i],
                    bold: bold,
                    font: font,
                    size: parseInt(size)
                });
            }
        }
        // Now add the rotation if necessary
        if (typeof angle === 'number' && angle && text) {
            text.setAttribute('x', 0);
            text.setAttribute('y', 0);
            text.setAttribute('transform', 'translate({1} {2}) rotate({3})'.format(x, y, -1 * angle));
        }
        //
        // Add a background color if specified
        //
        if (typeof background === 'string') {
            var parent = link ? a : parent;
            var bbox = text.getBBox(),
                rect = RG.SVG.create({
                    svg:    obj.svg,
                    parent: parent,
                    type:   'rect',
                    attr: {
                        x:      bbox.x - padding,
                        y:      bbox.y - padding,
                        width:  bbox.width + (padding * 2),
                        height: bbox.height + (padding * 2),
                        fill:   background
                    }
                });
                if (!events) {
                    rect.style.pointerEvents = 'none';
                }
            text.parentNode.insertBefore(rect, text);
        }
        if (RG.SVG.ISIE && (valign === 'hanging') && text) {
            text.setAttribute('y', y + (text.scrollHeight / 2));
        } else if (RG.SVG.ISIE && valign === 'middle') {
            text.setAttribute('y', y + (text.scrollHeight / 3));
        }
        if (RG.SVG.ISFF && text) {
            Y = y + (text.scrollHeight / 3);
        }
        return text;
    };
    //
    // Helps you get hold of the SPAN tag nodes that hold the text on the chart
    //
    RG.SVG.text.find = function (opt)
    {
        // Search criteria should include:
        //  o text (literal string and regex)
        if (typeof opt.object === 'object' && opt.object.isRGraph) {
            var svg = opt.object.svg;
        } else if (typeof opt.svg === 'object' && opt.svg.all) {
            var svg = opt.svg;
        }
        // Look for text nodes based on the text
        var nodes = svg.getElementsByTagName('text');
        var found = [];
        for (var i=0,len=nodes.length; i<len; ++i) {
            var text = false,
                tag  = false;
            // Exact match or regex on the text
            if (typeof opt.text === 'string' && nodes[i].innerHTML === opt.text) {
                text = true;
            } else if (typeof opt.text === 'object' && nodes[i].innerHTML.match(opt.text)) {
                text = true;
            } else if (typeof opt.text === 'undefined') {
                text = true;
            }
            // Exact match or regex on the tag
            if (typeof opt.tag === 'string' && nodes[i].getAttribute('tag') === opt.tag) {
                tag = true;
            } else if (typeof opt.tag === 'object' && nodes[i].getAttribute('tag').match(opt.tag)) {
                tag = true;
            } else if (typeof opt.tag === 'undefined') {
                tag = true;
            }
            // Did all of the conditions pass?
            if (text === true && tag === true) {
                found.push(nodes[i])
            }
        }
        return found;
    };
    //
    // Creates a UID that is applied to the object
    //
    RG.SVG.createUID = function ()
    {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)
        {
            var r = ma.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    };
    //
    // Determines if the SVG DIV container is fixed
    //
    RG.SVG.isFixed = function (svg)
    {
        var obj = svg.parentNode,
            i   = 0;
        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {
            if (obj.style.position === 'fixed') {
                return obj;
            }
            obj = obj.offsetParent;
        }
        return false;
    };
    /**
    * Sets an object in the RGraph registry
    * 
    * @param string name The name of the value to set
    */
    RG.SVG.REG.set = function (name, value)
    {
        RG.SVG.REG.store[name] = value;
        return value;
    };
    /**
    * Gets an object from the RGraph registry
    * 
    * @param string name The name of the value to fetch
    */
    RG.SVG.REG.get = function (name)
    {
        return RG.SVG.REG.store[name];
    };
    /**
    * Removes white-space from the start aqnd end of a string
    * 
    * @param string str The string to trim
    */
    RG.SVG.trim = function (str)
    {
        return RG.SVG.ltrim(RG.SVG.rtrim(str));
    };
    /**
    * Trims the white-space from the start of a string
    * 
    * @param string str The string to trim
    */
    RG.SVG.ltrim = function (str)
    {
        return str.replace(/^(\s|\0)+/, '');
    };
    /**
    * Trims the white-space off of the end of a string
    * 
    * @param string str The string to trim
    */
    RG.SVG.rtrim = function (str)
    {
        return str.replace(/(\s|\0)+$/, '');
    };
    //
    // Hides the currently shown tooltip
    //
    RG.SVG.hideTooltip = function ()
    {
        var tooltip = RG.SVG.REG.get('tooltip');
        if (tooltip && tooltip.parentNode /*&& (!uid || uid == tooltip.__canvas__.uid)*/) {
            tooltip.parentNode.removeChild(tooltip);
            tooltip.style.display = 'none';                
            tooltip.style.visibility = 'hidden';
            RG.SVG.REG.set('tooltip', null);
        }
        if (tooltip && tooltip.__object__) {
            RG.SVG.removeHighlight(tooltip.__object__);
        }
    };
    //
    // Creates a shadow
    //
    RG.SVG.setShadow = function (options)
    {
        var obj     = options.object,
            offsetx = options.offsetx  || 0,
            offsety = options.offsety || 0,
            blur    = options.blur || 0,
            opacity = options.opacity || 0,
            id      = options.id;
        var filter = RG.SVG.create({
            svg: obj.svg,
            parent: obj.svg.defs,
            type: 'filter',
            attr: {
                id: id,
                 width: "130%",
                 height: "130%"
            }
        });
        RG.SVG.create({
            svg: obj.svg,
            parent: filter,
            type: 'feOffset',
            attr: {
                result: 'offOut',
                'in': 'SourceGraphic',
                dx: offsetx,
                dy: offsety
            }
        });
        RG.SVG.create({
            svg: obj.svg,
            parent: filter,
            type: 'feColorMatrix',
            attr: {
                result: 'matrixOut',
                'in': 'offOut',
                type: 'matrix',
                values: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 {1} 0'.format(
                    opacity
                )
            }
        });
        RG.SVG.create({
            svg: obj.svg,
            parent: filter,
            type: 'feGaussianBlur',
            attr: {
                result: 'blurOut',
                'in': 'matrixOut',
                stdDeviation: blur
            }
        });
        RG.SVG.create({
            svg: obj.svg,
            parent: filter,
            type: 'feBlend',
            attr: {
                'in': 'SourceGraphic',
                'in2': 'blurOut',
                mode: 'normal'
            }
        });
    };
    /**
    * Takes a sequential index and returns the group/index variation of it. Eg if you have a
    * sequential index from a grouped bar chart this function can be used to convert that into
    * an appropriate group/index combination
    * 
    * @param nindex number The sequential index
    * @param data   array  The original data (which is grouped)
    * @return              The group/index information
    */
    RG.SVG.sequentialIndexToGrouped = function (index, data)
    {
        var group         = 0,
            grouped_index = 0;
        while (--index >= 0) {
            if (RG.SVG.isNull(data[group])) {
                group++;
                grouped_index = 0;
                continue;
            }
            // Allow for numbers as well as arrays in the dataset
            if (typeof data[group] == 'number') {
                group++
                grouped_index = 0;
                continue;
            }
            grouped_index++;
            if (grouped_index >= data[group].length) {
                group++;
                grouped_index = 0;
            }
        }
        return [group, grouped_index];
    };
    //
    // This is the reverse of the above function - converting
    // group/index to a sequential index
    //
    // @return number The sequential index
    //
    RG.SVG.groupedIndexToSequential = function (opt)
    {
        var dataset = opt.dataset,
            index   = opt.index,
            obj     = opt.object;
        for (var i=0,seq=0; i<=dataset; ++i) {
            for (var j=0; j<obj.data[dataset].length; ++j) {
                if (i === dataset && j === index) {
                    return seq;
                }
                seq++;
            }
        }
        return seq;
    };
    //
    // This function converts coordinates into the type understood by
    // SVG for drawing arcs
    //
    RG.SVG.TRIG.toCartesian = function (options)
    {
        return {
            x: options.cx + (options.r * ma.cos(options.angle)),
            y: options.cy + (options.r * ma.sin(options.angle))
        };
    };
    //
    // Gets a path that is usable by the SVG A path command
    //
    // @patam object options The options/arg to the function
    //
    // NB ** Still used by the Pie chart and the semi-circular Meter **
    //
    RG.SVG.TRIG.getArcPath = function (options)
    {
        //
        // Make circles start at the top instead of the right hand side
        //
        options.start -= 1.57;
        options.end   -= 1.57;
        var start = RG.SVG.TRIG.toCartesian({
            cx:    options.cx,
            cy:    options.cy,
            r:     options.r,
            angle: options.start}
        );
        var end = RG.SVG.TRIG.toCartesian({
            cx:    options.cx,
            cy:    options.cy,
            r:     options.r,
            angle: options.end
        });
        var diff = options.end - options.start;
        // Initial values
        var largeArc = '0';
        var sweep    = '0';
        if (options.anticlockwise && diff > 3.14) {
            largeArc = '0';
            sweep    = '0';
        } else if (options.anticlockwise && diff <= 3.14) {
            largeArc = '1';
            sweep    = '0';
        } else if (!options.anticlockwise && diff > 3.14) {
            largeArc = '1';
            sweep    = '1';
        } else if (!options.anticlockwise && diff <= 3.14) {
            largeArc = '0';
            sweep    = '1';
        }
        if (options.start > options.end && options.anticlockwise && diff <= 3.14) {
            largeArc = '0';
            sweep    = '0';
        }
        if (options.start > options.end && options.anticlockwise && diff > 3.14) {
            largeArc = '1';
            sweep    = '1';
        }
        if (typeof options.moveto === 'boolean' && options.moveto === false) {
            var d = [
                "A", options.r, options.r, 0, largeArc, sweep, end.x, end.y
            ];
        } else {
            var d = [
                "M", start.x, start.y, 
                "A", options.r, options.r, 0, largeArc, sweep, end.x, end.y
            ];
        }
        if (options.array === true) {
            return d;
        } else {
            return d.join(" ");
        }
    };
    //
    // Gets a path that is usable by the SVG A path command
    //
    // @patam object options The options/arg to the function
    //
    RG.SVG.TRIG.getArcPath2 = function (options)
    {
        //
        // Make circles start at the top instead of the right hand side
        //
        options.start -= 1.57;
        options.end   -= 1.57;
        var start = RG.SVG.TRIG.toCartesian({
            cx:    options.cx,
            cy:    options.cy,
            r:     options.r,
            angle: options.start
        });
        var end = RG.SVG.TRIG.toCartesian({
            cx:    options.cx,
            cy:    options.cy,
            r:     options.r,
            angle: options.end
        });
        var diff = ma.abs(options.end - options.start);
        // Initial values
        var largeArc = '0';
        var sweep    = '0';
        //TODO Put various options here for the correct combination of flags to use
        if (!options.anticlockwise) {
            if (diff > RG.SVG.TRIG.PI) {
                largeArc = '1';
                sweep    = '1';
            } else {
                largeArc = '0';
                sweep    = '1';
            }
        } else {
            if (diff > RG.SVG.TRIG.PI) {
                largeArc = '1';
                sweep    = '0';
            } else {
                largeArc = '0';
                sweep    = '0';
            }
        }
        if (typeof options.lineto === 'boolean' && options.lineto === false) {
            var d = [
                "M", start.x, start.y,
                "A", options.r, options.r, 0, largeArc, sweep, end.x, end.y
            ];
        } else {
            var d = [
                "M", options.cx, options.cy,
                "L", start.x, start.y, 
                "A", options.r, options.r, 0, largeArc, sweep, end.x, end.y
            ];
        }
        if (options.array === true) {
            return d;
        } else {
            return d.join(" ");
        }
    };
    //
    // Gets a path that is usable by the SVG A path command
    //
    // @param object options The options/arg to the function
    //
    RG.SVG.TRIG.getArcPath3 = function (options)
    {
        //
        // Make circles start at the top instead of the right hand side
        //
        options.start -= (ma.PI / 2);
        options.end   -= (ma.PI / 2);
        var start = RG.SVG.TRIG.toCartesian({
            cx:    options.cx,
            cy:    options.cy,
            r:     options.r,
            angle: options.start
        });
        var end = RG.SVG.TRIG.toCartesian({
            cx:    options.cx,
            cy:    options.cy,
            r:     options.r,
            angle: options.end
        });
        var diff = ma.abs(options.end - options.start);
        // Initial values
        var largeArc = '0';
        var sweep    = '0';
        //TODO Put various options here for the correct combination of flags to use
        if (!options.anticlockwise) {
            if (diff > RG.SVG.TRIG.PI) {
                largeArc = '1';
                sweep    = '1';
            } else {
                largeArc = '0';
                sweep    = '1';
            }
        } else {
            if (diff > RG.SVG.TRIG.PI) {
                largeArc = '1';
                sweep    = '0';
            } else {
                largeArc = '0';
                sweep    = '0';
            }
        }
        if (typeof options.lineto === 'boolean' && options.lineto === false) {
            var d = [
                "M", start.x, start.y,
                "A", options.r, options.r, 0, largeArc, sweep, end.x, end.y
            ];
        } else {
            var d = [
                "L", start.x, start.y,
                "A", options.r, options.r, 0, largeArc, sweep, end.x, end.y
            ];
        }
        if (options.array === true) {
            return d;
        } else {
            return d.join(" ");
        }
    };
    /**
    * This function gets the end point (X/Y coordinates) of a given radius.
    * You pass it the center X/Y and the radius and this function will return
    * the endpoint X/Y coordinates.
    * 
    * @param number cx    The center X coord
    * @param number cy    The center Y coord
    * @param number r     The length of the radius
    * @param number angle The anle to use
    */
    RG.SVG.TRIG.getRadiusEndPoint = function (opt)
    {
        // Allow for two arguments style
        if (arguments.length === 1) {
            var angle = opt.angle,
                r     = opt.r;
        } else if (arguments.length === 4) {
            var angle = arguments[0],
                r     = arguments[1];
        }
        var x = ma.cos(angle) * r,
            y = ma.sin(angle) * r;
        return [x, y];
    };
    /**
    * This function draws the title. This function also draws the subtitle.
    */
    RG.SVG.drawTitle = function (obj)
    {
        var prop                   = obj.properties,
            valign                 = 'bottom',
            originalTitleX         = prop.titleX,
            originalTitleY         = prop.titleY,
            originalTitleSubtitleX = prop.titleSubtitleX,
            originalTitleSubtitleY = prop.titleSubtitleY;
        if (typeof originalTitleX === 'string')         originalTitleX.replace(/^\+/,'');
        if (typeof originalTitleY === 'string')         originalTitleY.replace(/^\+/,'');
        if (typeof originalTitleSubtitleX === 'string') originalTitleSubtitleX.replace(/^\+/,'');
        if (typeof originalTitleSubtitleY === 'string') originalTitleSubtitleY.replace(/^\+/,'');
        //
        // The Pie chart title should default to being above the centerx
        //
        if (obj.type === 'pie') {
            if (RG.SVG.isNull(prop.titleX)) {
                prop.titleX         = obj.centerx;
                prop.titleSubtitleX = obj.centerx;
            }
            if (RG.SVG.isNull(prop.titleY)) {
                prop.titleY = obj.centery - obj.radius - 10;
            }
        }
        if (obj.scale && obj.scale.max <= 0 && obj.scale.min < 0 && typeof prop.titleY !== 'number' && obj.type !== 'hbar') {
            prop.titleY = obj.height - prop.gutterBottom + 10;
            var positionBottom = true;
            valign = 'top';
        } else if (typeof prop.titleY !== 'number') {
            var positionBottom = false;
            prop.titleY = prop.gutterTop - 10;
            valign      = 'bottom';
            // Account for the key
            if (!RG.SVG.isNull(prop.key)) {
                prop.titleY -= (2 * (prop.keyTextSize || prop.textSize));
            }
        }
        // If a subtitle is specified move the title up a bit in
        // order to accommodate it
        if (prop.titleSubtitle && typeof prop.titleSubtitleY !== 'number' && !positionBottom) {
            prop.titleY = prop.titleY - (prop.titleSubtitleSize * 1.5);
        }
        // Work out the subtitle size
        prop.titleSubTitleSize = prop.titleSubTitleSize || prop.textSize;
        // Work out the subtitle Y position
        prop.titleSubtitleY = prop.titleSubtitleY || prop.titleY + 18;
        if (positionBottom && typeof prop.titleSubtitleY !== 'number') {
            prop.titleSubtitleY = prop.titleY + 26;
        }
        // Draw the title
        if (prop.title) {
            var x = typeof prop.titleX === 'number' ? prop.titleX + (prop.variant3dOffsetx || 0) : prop.gutterLeft + (obj.graphWidth / 2) + (prop.variant3dOffsetx || 0);
            var y = prop.titleY + (prop.variant3dOffsety || 0);
            // Add any adjustment to the positioning
            if (typeof originalTitleX === 'string') {
                x += parseFloat(originalTitleX);
            }
            if (typeof originalTitleY === 'string') {
                y += parseFloat(originalTitleY);
            }
            RG.SVG.text({
                object: obj,
                svg:    obj.svg,
                parent: obj.svg.all,
                tag:    'title',
                text:   prop.title.toString(),
                size:   prop.titleSize   || (prop.textSize + 4) || 16,
                x:      x,
                y:      y,
                halign: prop.titleHalign || 'center',
                valign: prop.titleValign || valign,
                color:  prop.titleColor  || prop.textColor || 'black',
                bold:   prop.titleBold   || false,
                italic: prop.titleItalic || false,
                font:   prop.titleFont   || prop.textFont || 'Arial'
            });
        }
        // Draw the subtitle
        if (typeof prop.title === 'string' && typeof prop.titleSubtitle === 'string') {
            // By default, the X and Y coordinates place the subtitle
            // underneath the title. Though the y coord is now adjusted
            // so that the subtitle sits underneath the title.
            y += (prop.titleSubtitleSize * 1.5);
            // Is the subtitleX or subtitleY are numbers then just use those
            if (typeof originalTitleSubtitleX === 'number') {
                x = originalTitleSubtitleX;
            }
            if (typeof originalTitleSubtitleY === 'number') {
                y = originalTitleSubtitleY;
            }
            // Add the subtitles adjustment to the position
            if (typeof originalTitleSubtitleX === 'string') {
                x += parseFloat(originalTitleSubtitleX);
            }
            // Add the subtitles adjustment to the position
            if (typeof originalTitleSubtitleY === 'string') {
                y += parseFloat(originalTitleSubtitleY);
            }
            RG.SVG.text({
                object: obj,
                svg: obj.svg,
                parent: obj.svg.all,
                tag:    'subtitle',
                text:   prop.titleSubtitle,
                size:   prop.titleSubtitleSize,
                x:      x,
                y:      y,
                halign: prop.titleSubtitleHalign || 'center',
                valign: prop.titleSubtitleValign || valign,
                color:  prop.titleSubtitleColor  || prop.textColor || '#aaa',
                bold:   prop.titleSubtitleBold   || false,
                italic: prop.titleSubtitleItalic || false,
                font:   prop.titleSubtitleFont   || prop.textFont || 'Arial'
            });
        }
    };
    /**
    * Removes white-space from the start and end of a string
    * 
    * @param string str The string to trim
    */
    RG.SVG.trim = function (str)
    {
        return RG.SVG.ltrim(RG.SVG.rtrim(str));
    };
    /**
    * Trims the white-space from the start of a string
    * 
    * @param string str The string to trim
    */
    RG.SVG.ltrim = function (str)
    {
        return String(str).replace(/^(\s|\0)+/, '');
    };
    /**
    * Trims the white-space off of the end of a string
    * 
    * @param string str The string to trim
    */
    RG.SVG.rtrim = function (str)
    {
        return String(str).replace(/(\s|\0)+$/, '');
    };
    /**
    * This parses a single color value
    */
    RG.SVG.parseColorLinear = function (opt)
    {
        var obj   = opt.object,
            color = opt.color;
        if (!color || typeof color !== 'string') {
            return color;
        }
        if (color.match(/^gradient\((.*)\)$/i)) {
            var parts = RegExp.$1.split(':'),
                diff  = 1 / (parts.length - 1);
            if (opt && opt.direction && opt.direction === 'horizontal') {
                var grad = RG.SVG.create({
                    type: 'linearGradient',
                    parent: obj.svg.defs,
                    attr: {
                        id: 'RGraph-linear-gradient-' + obj.uid + '-' + obj.gradientCounter,
                        x1: opt.start || 0,
                        x2: opt.end || '100%',
                        y1: 0,
                        y2: 0,
                        gradientUnits: "userSpaceOnUse"
                    }
                });
            } else {
                var grad = RG.SVG.create({
                    type: 'linearGradient',
                    parent: obj.svg.defs,
                    attr: {
                        id: 'RGraph-linear-gradient-' + obj.uid + '-' + obj.gradientCounter,
                        x1: 0,
                        x2: 0,
                        y1: opt.start || 0,
                        y2: opt.end || '100%',
                        gradientUnits: "userSpaceOnUse"
                    }
                });
            }
            // Add the first color stop
            var stop = RG.SVG.create({
                type: 'stop',
                parent: grad,
                attr: {
                    offset: '0%',
                    'stop-color': RG.SVG.trim(parts[0])
                }
            });
            // Add the rest of the color stops
            for (var j=1,len=parts.length; j<len; ++j) {
                RG.SVG.create({
                    type: 'stop',
                    parent: grad,
                    attr: {
                        offset: (j * diff * 100) + '%',
                        'stop-color': RG.SVG.trim(parts[j])
                    }
                });
            }
        }
        color = grad ? 'url(#RGraph-linear-gradient-' + obj.uid + '-' + (obj.gradientCounter++) + ')' : color;
        return color;
    };
    /**
    * This parses a single color value
    */
    RG.SVG.parseColorRadial = function (opt)
    {
        var obj   = opt.object,
            color = opt.color;
        if (!color || typeof color !== 'string') {
            return color;
        }
        if (color.match(/^gradient\((.*)\)$/i)) {
            var parts = RegExp.$1.split(':'),
                diff  = 1 / (parts.length - 1);
            var grad = RG.SVG.create({
                type: 'radialGradient',
                parent: obj.svg.defs,
                attr: {
                    id: 'RGraph-radial-gradient-' + obj.uid + '-' + obj.gradientCounter,
                    gradientUnits: opt.gradientUnits || 'userSpaceOnUse',
                    cx: opt.cx || obj.centerx,
                    cy: opt.cy || obj.centery,
                    fx: opt.fx || obj.centerx,
                    fy: opt.fy || obj.centery,
                    r:  opt.r  || obj.radius
                }
            });
            // Add the first color stop
            var stop = RG.SVG.create({
                type: 'stop',
                parent: grad,
                attr: {
                    offset: '0%',
                    'stop-color': RG.SVG.trim(parts[0])
                }
            });
            // Add the rest of the color stops
            for (var j=1,len=parts.length; j<len; ++j) {
                RG.SVG.create({
                    type: 'stop',
                    parent: grad,
                    attr: {
                        offset: (j * diff * 100) + '%',
                        'stop-color': RG.SVG.trim(parts[j])
                    }
                });
            }
        }
        color = grad ? 'url(#RGraph-radial-gradient-' + obj.uid + '-' + (obj.gradientCounter++) + ')' : color;
        return color;
    };
    /**
    * Reset all of the color values to their original values
    * 
    * @param object
    */
    RG.SVG.resetColorsToOriginalValues = function (opt)
    {
        var obj = opt.object;
        if (obj.originalColors) {
            // Reset the colors to their original values
            for (var j in obj.originalColors) {
                if (typeof j === 'string') {
                    obj.properties[j] = RG.SVG.arrayClone(obj.originalColors[j]);
                }
            }
        }
        /**
        * If the function is present on the object to reset specific
        * colors - use that
        */
        if (typeof obj.resetColorsToOriginalValues === 'function') {
            obj.resetColorsToOriginalValues();
        }
        // Hmmm... Should this be necessary? I don't think it will
        // do any harm to leave it in.
        obj.originalColors = {};
        // Reset the colorsParsed flag so that they're parsed for gradients again
        obj.colorsParsed = false;
        // Reset the gradient counter
        obj.gradientCounter = 1;
    };
    //
    // Clear the SVG tag by deleting all of its
    // child nodes
    //
    // @param object svg The SVG tag (same as what is returned
    //                   by document.getElementById() )
    //
    RG.SVG.clear = function (svg)
    {
        // Clear all the layer nodes
        for (var i=1; i<=100; ++i) {
            if (svg['background' + i]) {
                // Clear all the nodes within this group
                while (svg['background' + i].lastChild) {
                    svg['background' + i].removeChild(svg['background' + i].lastChild);
                }
            } else {
                break;
            }
        }
        // Clear all the node within the "all" group
        while (svg.all.lastChild) {
            svg.all.removeChild(svg.all.lastChild);
        }
        // Clear Line chart hotspots
        if (svg.all.line_tooltip_hotspots) {
            while (svg.all.line_tooltip_hotspots.lastChild) {
                svg.all.line_tooltip_hotspots.removeChild(svg.all.line_tooltip_hotspots.lastChild);
            }
        }
    };
    /**
    * Adds an event listener
    * 
    * @param object obj   The graph object
    * @param string event The name of the event, eg ontooltip
    * @param object func  The callback function
    */
    RG.SVG.addCustomEventListener = function (obj, name, func)
    {
        // Initialise the events array if necessary
        if (typeof RG.SVG.events[obj.uid] === 'undefined') {
            RG.SVG.events[obj.uid] = [];
        }
        // Prepend "on" if necessary
        if (name.substr(0, 2) !== 'on') {
            name = 'on' + name;
        }
        RG.SVG.events[obj.uid].push({
            object: obj,
            event:  name,
            func:   func
        });
        return RG.SVG.events[obj.uid].length - 1;
    };
    /**
    * Used to fire one of the RGraph custom events
    * 
    * @param object obj   The graph object that fires the event
    * @param string event The name of the event to fire
    */
    RG.SVG.fireCustomEvent = function (obj, name)
    {
        if (obj && obj.isRGraph) {
            var uid = obj.uid;
            if (   typeof uid === 'string'
                && typeof RG.SVG.events === 'object'
                && typeof RG.SVG.events[uid] === 'object'
                && RG.SVG.events[uid].length > 0) {
                for(var j=0,len=RG.SVG.events[uid].length; j<len; ++j) {
                    if (RG.SVG.events[uid][j] && RG.SVG.events[uid][j].event === name) {
                        RG.SVG.events[uid][j].func(obj);
                    }
                }
            }
        }
    };
    /**
    * Clears all the custom event listeners that have been registered
    * 
    * @param string optional Limits the clearing to this object UID
    */
    RG.SVG.removeAllCustomEventListeners = function ()
    {
        var uid = arguments[0];
        if (uid && RG.SVG.events[uid]) {
            RG.SVG.events[uid] = {};
        } else {
            RG.SVG.events = [];
        }
    };
    /**
    * Clears a particular custom event listener
    * 
    * @param object obj The graph object
    * @param number i   This is the index that is return by .addCustomEventListener()
    */
    RG.SVG.removeCustomEventListener = function (obj, i)
    {
        if (   typeof RG.SVG.events === 'object'
            && typeof RG.SVG.events[obj.uid] === 'object'
            && typeof RG.SVG.events[obj.uid][i] === 'object') {
            RG.SVG.events[obj.uid][i] = null;
        }
    };
    //
    // Removes the highlight from the chart added by tooltips (possibly others too)
    //
    RG.SVG.removeHighlight = function (obj)
    {
        var highlight = RG.SVG.REG.get('highlight');
        if (highlight && RG.SVG.isArray(highlight) && highlight.length) {
            for (var i=0,len=highlight.length; i<len; ++i) {
                if (highlight[i].parentNode) {
                    //obj.svg.removeChild(highlight[i]);
                    highlight[i].parentNode.removeChild(highlight[i]);
                }
            }
        } else if (highlight && highlight.parentNode) {
            if (obj.type === 'scatter') {
                highlight.setAttribute('fill', 'transparent');
            } else {
                highlight.parentNode.removeChild(highlight);
            }
        }
    };
    //
    // Removes the highlight from the chart added by tooltips (possibly others too)
    //
    RG.SVG.redraw = function ()
    {
        if (arguments.length === 1) {
            var svg = arguments[0];
            RG.SVG.clear(svg);
            var objects = RG.SVG.OR.get('id:' + svg.parentNode.id);
            for (var i=0,len=objects.length; i<len; ++i) {
                // Reset the colors to the original values
                RG.SVG.resetColorsToOriginalValues({object: objects[i]});
                objects[i].draw();
            }
        } else {
            var tags = RG.SVG.OR.tags();
            for (var i in tags) {
                RG.SVG.redraw(tags[i]);
            }
        }
    };
    //
    // A better, more flexible, date parsing function
    //
    //@param  string str The string to parse
    //@return number     A number, as returned by Date.parse()
    //
    RG.SVG.parseDate = function (str)
    {
        var d = new Date();
        // Initialise the default values
        var defaults = {
            seconds: '00',
            minutes: '00',
            hours: '00',
            date: d.getDate(),
            month: d.getMonth() + 1,
            year: d.getFullYear()
        };
        // Create the months array for turning textual months back to numbers
        var months       = ['january','february','march','april','may','june','july','august','september','october','november','december'],
            months_regex = months.join('|');
        for (var i=0; i<months.length; ++i) {
            months[months[i]] = i;
            months[months[i].substring(0,3)] = i;
            months_regex = months_regex + '|' + months[i].substring(0,3);
        }
        // These are the seperators allowable for d/m/y and y/m/d dates
        // (Its part of a regexp so the position of the square brackets
        //  is crucial)
        var sep = '[-./_=+~#:;,]+';
        // Tokenise the string
        var tokens = str.split(/ +/);
        // Loop through each token checking what is is
        for (var i=0,len=tokens.length; i<len; ++i) {
            if (tokens[i]) {
                // Year
                if (tokens[i].match(/^\d\d\d\d$/)) {
                    defaults.year = tokens[i];
                }
                // Month
                var res = isMonth(tokens[i]);
                if (typeof res === 'number') {
                    defaults.month = res + 1; // Months are zero indexed
                }
                // Date
                if (tokens[i].match(/^\d?\d(?:st|nd|rd|th)?$/)) {
                    defaults.date = parseInt(tokens[i]);
                }
                // Time
                if (tokens[i].match(/^(\d\d):(\d\d):?(?:(\d\d))?$/)) {
                    defaults.hours   = parseInt(RegExp.$1);
                    defaults.minutes = parseInt(RegExp.$2);
                    if (RegExp.$3) {
                        defaults.seconds = parseInt(RegExp.$3);
                    }
                }
                // Dateformat: XXXX-XX-XX
                if (tokens[i].match(new RegExp('^(\\d\\d\\d\\d)' + sep + '(\\d\\d)' + sep + '(\\d\\d)$', 'i'))) {
                    defaults.date  = parseInt(RegExp.$3);
                    defaults.month = parseInt(RegExp.$2);
                    defaults.year  = parseInt(RegExp.$1);
                }
                // Dateformat: XX-XX-XXXX
                if (tokens[i].match(new RegExp('^(\\d\\d)' + sep + '(\\d\\d)' + sep + '(\\d\\d\\d\\d)$','i') )) {
                    defaults.date  = parseInt(RegExp.$1);
                    defaults.month = parseInt(RegExp.$2);
                    defaults.year  = parseInt(RegExp.$3);
                }
            }
        }
        // Now put the defaults into a format thats recognised by Date.parse()
        str = '{1}/{2}/{3} {4}:{5}:{6}'.format(
            defaults.year,
            String(defaults.month).length     === 1 ? '0' + (defaults.month) : defaults.month,
            String(defaults.date).length      === 1 ? '0' + (defaults.date)      : defaults.date,
            String(defaults.hours).length     === 1 ? '0' + (defaults.hours)     : defaults.hours,
            String(defaults.minutes).length   === 1 ? '0' + (defaults.minutes)   : defaults.minutes,
            String(defaults.seconds).length   === 1 ? '0' + (defaults.seconds)   : defaults.seconds
        );
        return Date.parse(str);
        //
        // Support functions
        //
        function isMonth(str)
        {
            var res = str.toLowerCase().match(months_regex);
            return res ? months[res[0]] : false;
        }
    };
    // The ObjectRegistry add function
    RG.SVG.OR.add = function (obj)
    {
        RG.SVG.OR.objects.push(obj);
        return obj;
    };
    // The ObjectRegistry function that returns all of the objects. Th argument
    // can aither be:
    //
    // o omitted  All of the registered objects are returned
    // o id:XXX  All of the objects on that SVG tag are returned
    // o type:XXX All the objects of that type are returned
    //
    RG.SVG.OR.get = function ()
    {
        // Fetch objects that are on a particular SVG tag
        if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'id:') {
            var ret = [];
            for (var i=0; i<RG.SVG.OR.objects.length; ++i) {
                if (RG.SVG.OR.objects[i].id === arguments[0].substr(3)) {
                    ret.push(RG.SVG.OR.objects[i]);
                }
            }
            return ret;
        }
        // Fetch objects that are of a particular type
        //
        // TODO Allow multiple types to be specified
        if (typeof arguments[0] === 'string' && arguments[0].substr(0, 4).toLowerCase() === 'type') {
            var ret = [];
            for (var i=0; i<RG.SVG.OR.objects.length; ++i) {
                if (RG.SVG.OR.objects[i].type === arguments[0].substr(5)) {
                    ret.push(RG.SVG.OR.objects[i]);
                }
            }
            return ret;
        }
        // Fetch an object that has a specific UID
        if (typeof arguments[0] === 'string' && arguments[0].substr(0, 3).toLowerCase() === 'uid') {
            var ret = [];
            for (var i=0; i<RG.SVG.OR.objects.length; ++i) {
                if (RG.SVG.OR.objects[i].uid === arguments[0].substr(4)) {
                    ret.push(RG.SVG.OR.objects[i]);
                }
            }
            return ret;
        }
        return RG.SVG.OR.objects;
    };
    // The ObjectRegistry function that returns all of the registeredt SVG tags
    //
    RG.SVG.OR.tags = function ()
    {
        var tags = [];
        for (var i=0; i<RG.SVG.OR.objects.length; ++i) {
            if (!tags[RG.SVG.OR.objects[i].svg.parentNode.id]) {
                tags[RG.SVG.OR.objects[i].svg.parentNode.id] = RG.SVG.OR.objects[i].svg;
            }
        }
        return tags;
    };
    //
    // This function returns a two element array of the SVG x/y position in
    // relation to the page
    // 
    // @param object svg
    //
    RG.SVG.getSVGXY = function (svg)
    {
        var x  = 0,
            y  = 0,
            el = svg.parentNode; // !!!
        do {
            x += el.offsetLeft;
            y += el.offsetTop;
            // Account for tables in webkit
            if (el.tagName.toLowerCase() == 'table' && (RG.SVG.ISCHROME || RG.SVG.ISSAFARI)) {
                x += parseInt(el.border) || 0;
                y += parseInt(el.border) || 0;
            }
            el = el.offsetParent;
        } while (el && el.tagName && el.tagName.toLowerCase() != 'body');
        var paddingLeft = svg.style.paddingLeft ? parseInt(svg.style.paddingLeft) : 0,
            paddingTop  = svg.style.paddingTop ? parseInt(svg.style.paddingTop) : 0,
            borderLeft  = svg.style.borderLeftWidth ? parseInt(svg.style.borderLeftWidth) : 0,
            borderTop   = svg.style.borderTopWidth  ? parseInt(svg.style.borderTopWidth) : 0;
        if (navigator.userAgent.indexOf('Firefox') > 0) {
            x += parseInt(document.body.style.borderLeftWidth) || 0;
            y += parseInt(document.body.style.borderTopWidth) || 0;
        }
        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];
    };
    //
    // This function is a compatibility wrapper around
    // the requestAnimationFrame function.
    //
    // @param function func The function to give to the
    //                      requestAnimationFrame function
    //
    RG.SVG.FX.update = function (func)
    {
        win.requestAnimationFrame =
            win.requestAnimationFrame ||
            win.webkitRequestAnimationFrame ||
            win.msRequestAnimationFrame ||
            win.mozRequestAnimationFrame ||
            (function (func){setTimeout(func, 16.666);});
        win.requestAnimationFrame(func);
    };
    /**
    * This function returns an easing multiplier for effects so they eas out towards the
    * end of the effect.
    * 
    * @param number frames The total number of frames
    * @param number frame  The frame number
    */
    RG.SVG.FX.getEasingMultiplier = function (frames, frame)
    {
        var multiplier = ma.pow(ma.sin((frame / frames) * RG.SVG.TRIG.HALFPI), 3);
        return multiplier;
    };
    /**
    * Measures text by creating a DIV in the document and adding the relevant
    * text to it, then checking the .offsetWidth and .offsetHeight.
    * 
    * @param  object opt An object containing the following:
    *                        o text( string) The text to measure
    *                        o bold (bool)   Whether the text is bold or not
    *                        o font (string) The font to use
    *                        o size (number) The size of the text (in pts)
    * 
    * @return array         A two element array of the width and height of the text
    */
    RG.SVG.measureText = function (opt)
    {
        //text, bold, font, size
        var text = opt.text || '',
            bold = opt.bold || false,
            font = opt.font || 'Arial',
            size = opt.size || 10,
            str  = text + ':' + bold + ':' + font + ':' + size;
        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs
        if (typeof RG.SVG.measuretext_cache === 'undefined') {
            RG.SVG.measuretext_cache = [];
        }
        if (typeof RG.SVG.measuretext_cache == 'object' && RG.SVG.measuretext_cache[str]) {
            return RG.SVG.measuretext_cache[str];
        }
        if (!RG.SVG.measuretext_cache['text-span']) {
            var span = document.createElement('SPAN');
                span.style.position = 'absolute';
                //span.style.backgroundColor = 'red';
                span.style.padding    = 0;
                span.style.display    = 'inline';
                span.style.top        = '-200px';
                span.style.left       = '-200px';
                span.style.lineHeight = '1em';
            document.body.appendChild(span);
            // Now store the newly created DIV
            RG.SVG.measuretext_cache['text-span'] = span;
        } else if (RG.SVG.measuretext_cache['text-span']) {
            var span = RG.SVG.measuretext_cache['text-span'];
        }
        span.innerHTML        = text.replace(/\r?\n/g, '<br />');
        span.style.fontFamily = font;
        span.style.fontWeight = bold ? 'bold' : 'normal';
        span.style.fontSize   = String(size).replace(/pt$/, '') + 'pt';
        var sizes = [span.offsetWidth, span.offsetHeight];
        //document.body.removeChild(span);
        RG.SVG.measuretext_cache[str] = sizes;
        return sizes;
    };
    /**
    * This function converts an array of strings to an array of numbers. Its used by the meter/gauge
    * style charts so that if you want you can pass in a string. It supports various formats:
    * 
    * '45.2'
    * '-45.2'
    * ['45.2']
    * ['-45.2']
    * '45.2,45.2,45.2' // A CSV style string
    * 
    * @param number frames The string or array to parse
    */
    RG.SVG.stringsToNumbers = function (str)
    {
        // An optional seperator to use intead of a comma
        var sep = arguments[1] || ',';
        // If it's already a number just return it
        if (typeof str === 'number') {
            return str;
        }
        if (typeof str === 'string') {
            if (str.indexOf(sep) != -1) {
                str = str.split(sep);
            } else {
                str = parseFloat(str);
            }
        }
        if (typeof str === 'object') {
            for (var i=0,len=str.length; i<len; i+=1) {
                str[i] = parseFloat(str[i]);
            }
        }
        return str;
    };
    // This function allows for numbers that are given as a +/- adjustment
    RG.SVG.getAdjustedNumber = function (opt)
    {
        var value = opt.value,
            prop  = opt.prop;
        if (typeof prop === 'string' && match(/^(\+|-)([0-9.]+)/)) {
            if (RegExp.$1 === '+') {
                value += parseFloat(RegExp.$2);
            } else if (RegExp.$1 === '-') {
                value -= parseFloat(RegExp.$2);
            }
        }
        return value;
    };
    // NOT USED ANY MORE
    RG.SVG.attribution=function(){return;};
    /**
    * Parse a gradient and returns the various parts
    * 
    * @param string str The gradient string
    */
    RG.SVG.parseGradient = function (str)
    {
    };
    /**
    * Generates a random number between the minimum and maximum
    * 
    * @param number min The minimum value
    * @param number max The maximum value
    * @param number     OPTIONAL Number of decimal places
    */
    RG.SVG.random = function (opt)
    {
        var min = opt.min,
            max = opt.max,
            dp  = opt.dp || opt.decimals || 0,
            r   = ma.random();
        return Number((((max - min) * r) + min).toFixed(dp));
    };
    /**
    * Fill an array full of random numbers
    */
    RG.SVG.arrayRand    =
    RG.SVG.arrayRandom  =
    RG.SVG.random.array = function (opt)
    {
        var num = opt.num,
            min = opt.min,
            max = opt.max,
            dp  = opt.dp || opt.decimals || 0;
        for(var i=0,arr=[]; i<num; i+=1) {
            arr.push(RG.SVG.random({min: min, max: max, dp: dp}));
        }
        return arr;
    };
    //
    // This function is called by each objects setter so that common BC
    // and adjustments are centralised. And there's less typing for me too.
    //
    // @param object opt An object of options to the function, which are:
    //                    object: The chart object
    //                    name:   The name of the config parameter
    //                    value:  The value thats being set
    //
    RG.SVG.commonSetter = function (opt)
    {
        var obj   = opt.object,
            name  = opt.name,
            value = opt.value;
        // The default event for tooltips is click
        if (name === 'tooltipsEvent'&& value !== 'click' && value !== 'mousemove') {
            value = 'click';
        }
        return {
            name:  name,
            value: value
        };
    };
    //
    // Generates logs for... log charts
    //
    // @param object opt The options:
    //                     o num  The number
    //                     o base The base
    //
    RG.SVG.log = function (opt)
    {
        var num  = opt.num,
            base = opt.base;
        return ma.log(num) / (base ? ma.log(base) : 1);
    };
    RG.SVG.donut = function (opt)
    {
        var arcPath1 = RG.SVG.TRIG.getArcPath3({
            cx: opt.cx,
            cy: opt.cy,
            r: opt.outerRadius,
            start: 0,
            end: RG.SVG.TRIG.TWOPI,
            anticlockwise: false,
            lineto: false
        });
        var arcPath2 = RG.SVG.TRIG.getArcPath3({
            cx: opt.cx,
            cy: opt.cy,
            r: opt.innerRadius,
            start: RG.SVG.TRIG.TWOPI,
            end: 0,
            anticlockwise: true,
            lineto: false
        });
        //
        // Create the red circle
        //
        var path = RG.SVG.create({
            svg: opt.svg,
            type: 'path',
            attr: {
                d: arcPath1 + arcPath2,
                stroke: opt.stroke,
                fill: opt.fill
            }
        });
        return path;
    };
    //
    // Copy the globals (if any have been set) from the global object to
    // this instances configuration
    //
    RG.SVG.getGlobals = function (obj)
    {
        var prop = obj.properties;
        for (i in RG.SVG.GLOBALS) {
            if (typeof i === 'string') {
                prop[i] = RG.SVG.arrayClone(RG.SVG.GLOBALS[i]);
            }
        }
    };
    //
    // This function adds a link to the SVG document
    //
    // @param object opt The various options to the function
    //
    RG.SVG.link = function (opt)
    {
        var a = RGraph.SVG.create({
            svg: bar.svg,
            type: 'a',
            parent: bar.svg.all,
            attr: {
                'xlink:href': href,
                target:       target
            }
        });
        var text = RGraph.SVG.create({
            svg: bar.svg,
            type: 'text',
            parent: a,
            attr: {
                x: x,
                y: y,
                fill: fill
            }
        });
        text.innerHTML = text;
    };
    // This function is used to get the errorbar MAXIMUM value. Its in the common
    // file because it's used by multiple chart libraries
    //
    // @param object opt An object containing the arguments to the function
    //         o object: The chart object
    //         o index:  The index to fetch
    RG.SVG.getErrorbarsMaxValue = function (opt)
    {
        var obj   = opt.object,
            prop  = obj.properties,
            index = opt.index;
        if (typeof prop.errorbars === 'object' && !RG.SVG.isNull(prop.errorbars) && typeof prop.errorbars[index] === 'number') {
            var value = prop.errorbars[index];
        } else if (   typeof prop.errorbars === 'object'
                   && !RG.SVG.isNull(prop.errorbars)
                   && typeof prop.errorbars[index] === 'object'
                   && !RG.SVG.isNull(prop.errorbars[index])
                   && typeof prop.errorbars[index].max === 'number'
                  ) {
            var value = prop.errorbars[index].max;
        } else {
            var value = 0;
        }
        return value;
    };
    // This function is used to get the errorbar MINIMUM value. Its in the common
    // file because it's used by multiple chart libraries
    //
    // @param object opt An object containing the arguments to the function
    //         o object: The chart object
    //         o index:  The index to fetch
    RG.SVG.getErrorbarsMinValue = function (opt)
    {
        var obj   = opt.object,
            prop  = obj.properties,
            index = opt.index;
        if (   typeof prop.errorbars === 'object'
            && !RG.SVG.isNull(prop.errorbars)
            && typeof prop.errorbars[index] === 'object'
            && !RG.SVG.isNull(prop.errorbars[index])
            && typeof prop.errorbars[index].min === 'number'
           ) {
            var value = prop.errorbars[index].min;
        } else {
            var value = null;
        }
        return value;
    };
    // This function is used to get the errorbar color. Its in the common
    // file because it's used by multiple chart libraries
    //
    // @param object opt An object containing the arguments to the function
    //         o object: The chart object
    //         o index:  The index to fetch
    RG.SVG.getErrorbarsColor = function (opt)
    {
        var obj   = opt.object,
            prop  = obj.properties,
            index = opt.index;
        var color = prop.errorbarsColor || 'black';
        if (typeof prop.errorbars === 'object' && !RG.SVG.isNull(prop.errorbars) && typeof prop.errorbars[index] === 'object' && !RG.SVG.isNull(prop.errorbars[index]) && typeof prop.errorbars[index].color === 'string') {
            color = prop.errorbars[index].color;
        }
        return color;
    };
    // This function is used to get the errorbar linewidth. Its in the common
    // file because it's used by multiple chart libraries
    //
    // @param object opt An object containing the arguments to the function
    //         o object: The chart object
    //         o index:  The index to fetch
    RG.SVG.getErrorbarsLinewidth = function (opt)
    {
        var obj   = opt.object,
            prop  = obj.properties,
            index = opt.index;
        var linewidth = prop.errorbarsLinewidth || 1
        if (typeof prop.errorbars === 'object' && !RG.SVG.isNull(prop.errorbars) && typeof prop.errorbars[index] === 'object' && !RG.SVG.isNull(prop.errorbars[index]) && typeof prop.errorbars[index].linewidth === 'number') {
            linewidth = prop.errorbars[index].linewidth;
        }
        return linewidth;
    };
    // This function is used to get the errorbar capWidth. Its in the common
    // file because it's used by multiple chart libraries
    //
    // @param object opt An object containing the arguments to the function
    //         o object: The chart object
    //         o index:  The index to fetch
    RG.SVG.getErrorbarsCapWidth = function (opt)
    {
        var obj   = opt.object,
            prop  = obj.properties,
            index = opt.index;
        var capwidth = prop.errorbarsCapwidth || 10
        if (   typeof prop.errorbars === 'object'
            && !RG.SVG.isNull(prop.errorbars)
            && typeof prop.errorbars[index] === 'object'
            && !RG.SVG.isNull(prop.errorbars[index])
            && typeof prop.errorbars[index].capwidth === 'number'
            ) {
            capwidth = prop.errorbars[index].capwidth;
        }
        return capwidth;
    };
    //
    // This is here so that if the tooltip library has not
    // been included, this function will show an alert
    //informing the user
    //
    if (typeof RG.SVG.tooltip !== 'function') {
        RG.SVG.tooltip = function ()
        {
            $$a('The tooltip library has not been included!');
        };
    }
// End module pattern
})(window, document);
/**
* Loosly mimicks the PHP function print_r();
*/
window.$p = function (obj)
{
    var indent = (arguments[2] ? arguments[2] : '    ');
    var str    = '';
    var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;
    if (counter >= 5) {
        return '';
    }
    switch (typeof obj) {
        case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;
        case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;
        case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;
        case 'function':  str += 'function () {}'; break;
        case 'undefined': str += 'undefined'; break;
        case 'null':      str += 'null'; break;
        case 'object':
            // In case of null
            if (RGraph.SVG.isNull(obj)) {
                str += indent + 'null\n';
            } else {
                str += indent + 'Object {' + '\n'
                for (j in obj) {
                    str += indent + '    ' + j + ' => ' + window.$p(obj[j], true, indent + '    ', counter + 1) + '\n';
                }
                str += indent + '}';
            }
            break;
        default:
            str += 'Unknown type: ' + typeof obj + '';
            break;
    }
    /**
    * Finished, now either return if we're in a recursed call, or alert()
    * if we're not.
    */
    if (!arguments[1]) {
        alert(str);
    }
    return str;
};
/**
* A shorthand for the default alert() function
*/
window.$$a = function (v)
{
    alert(v);
};
/**
* Short-hand for console.log
* 
* @param mixed v The variable to log to the console
*/
window.$cl = function (v)
{
    return console.log(v);
};
/**
* A basic string formatting function. Use it like this:
* 
* var str = '{1} {2} {3}'.format('a', 'b', 'c');
* 
* Outputs: a b c
*/
if (!String.prototype.format) {
  String.prototype.format = function()
  {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(str, idx)
    {
      return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;
    });
  };
};
// version: 2018-06-24-143455
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    /**
    * Initialise the various objects
    */
    RGraph = window.RGraph || {isRGraph: true};
    RGraph.CSV = function (url, func)
    {
        var RG  = RGraph,
            ua  = navigator.userAgent,
            ma  = Math;
        /**
        * Some default values
        */
        this.url       = url;
        this.ready     = func;
        this.data      = null;
        this.numrows   = null;
        this.numcols   = null;
        this.seperator = arguments[2] || ',';
        this.endofline = arguments[3] || /\r?\n/;
        /**
        * A Custom split function
        * 
        * @param string str  The CSV string to split
        * @param mixed  char The character to split on - or it can also be an object like this:
        *                    {
        *                        preserve: false, // Whether to preserve whitespace
        *                        char: ','        // The character to split on
        *                    }
        */
        this.splitCSV = function (str, split)
        {
            // Defaults
            var arr            = [];
            var field          = '';
            var inDoubleQuotes = false;
            var inSingleQuotes = false;
            var preserve       = (typeof split === 'object' && split.preserve) ? true : false;
            // The character to split the CSV string on
            if (typeof split === 'object') {
                if (typeof split.char === 'string') {
                    split = split.char;
                } else {
                    split = ',';
                }
            } // If not an object just leave the char as it's supplied
            for (var i=0,len=str.length; i<len; i+=1) {
                char = str.charAt(i);
                if ( (char === '"') && !inDoubleQuotes) {
                    inDoubleQuotes = true;
                    continue;
                } else if ( (char === '"') && inDoubleQuotes) {
                    inDoubleQuotes = false;
                    continue;
                }
                if ( (char === "'") && !inSingleQuotes) {
                    inSingleQuotes = true;
                    continue;
                } else if ( (char === "'") && inSingleQuotes) {
                    inSingleQuotes = false;
                    continue;
                } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {
// TODO look ahead in order to allow for multi-character seperators
                    arr.push(field);
                    field = '';
                    continue;
                } else {
                    field = field + char;
                }
            }
            // Add the last field
            arr.push(field);
            // Now trim each value if necessary
            if (!preserve) {
                for (i=0,len=arr.length; i<len; i+=1) {
                    arr[i] = arr[i].trim();
                }
            }
            return arr;
        };
        /**
        * This function splits the CSV data into an array so that it can be useful.
        */
        this.fetch = function ()
        {
            var sep = this.seperator,
                eol = this.endofline,
                obj = this;
            if (this.url.substring(0,3) === 'id:' || this.url.substring(0,4) === 'str:') {
                // Get rid of any surrounding whitespace
                if (this.url.substring(0,3) === 'id:') {
                    var data = document.getElementById(this.url.substring(3)).innerHTML.trim();
                } else if (this.url.substring(0,4) === 'str:') {
                    var data = this.url.substring(4).trim();
                }
                // Store the CSV data on the CSV object (ie - this object)
                obj.data = data.split(eol);
                // Store the number of rows
                obj.numrows = obj.data.length;
                for (var i=0,len=obj.data.length; i<len; i+=1) {
                    /**
                    * Split the individual line
                    */
                    //var row = obj.data[i].split(sep);
                    var row = obj.splitCSV(obj.data[i], {preserve: false, char: sep});
                    if (!obj.numcols) {
                        obj.numcols = row.length;
                    }
                    /**
                    * If the cell is purely made up of numbers - convert it
                    */
                    for (var j=0; j<row.length; j+=1) {
                        if ((/^\-?[0-9.]+$/).test(row[j])) {
                            row[j] = parseFloat(row[j]);
                        }
                        // Assign the split-up-row back to the data array
                        obj.data[i] = row;
                    }
                }
                // Call the ready function straight away
                obj.ready(obj);
            } else {
                RGraph.SVG.AJAX.getString(this.url, function (data)
                {
                    data = data.replace(/(\r?\n)+$/, '');
                    /**
                    * Split the lines in the CSV
                    */
                    obj.data = data.split(eol);
                    /**
                    * Store the number of rows
                    */
                    obj.numrows = obj.data.length;
                    /**
                    * Loop thru each lines in the CSV file
                    */
                    for (var i=0,len=obj.data.length; i<len; i+=1) {
                        /**
                        * Use the new split function to split each row NOT preserving whitespace
                        */
                        //var row = obj.data[i].split(sep);
                        var row = obj.splitCSV(obj.data[i], {preserve: false, char: sep});
                        if (!obj.numcols) {
                            obj.numcols = row.length;
                        }
                        /**
                        * If the cell is purely made up of numbers - convert it
                        */
                        for (var j=0; j<row.length; j+=1) {
                            if ((/^\-?[0-9.]+$/).test(row[j])) {
                                row[j] = parseFloat(row[j]);
                            }
                            // Assign the split-up-row back to the data array
                            obj.data[i] = row;
                        }
                    }
                    // Call the ready function straight away
                    obj.ready(obj);
                });
            }
        };
        /**
        * Returns a row of the CSV file
        * 
        * @param number index The index of the row to fetch
        * @param        start OPTIONAL If desired you can specify a column to start at (which starts at 0 by default)
        */
        this.getRow = function (index)
        {
            var row   = [];
            var start = arguments[1] || 0;
            for (var i=start; i<this.numcols; i+=1) {
                row.push(this.data[index][i]);
            }
            return row;
        };
        /**
        * Returns a column of the CSV file
        * 
        * @param number index The index of the column to fetch
        * @param        start OPTIONAL If desired you can specify a row to start at (which starts at 0 by default)
        */
        this.getCol =
        this.getColumn = function (index)
        {
            var col   = [];
            var start = arguments[1] || 0;
            for (var i=start; i<this.numrows; i+=1) {
                col.push(this.data[i][index]);
            }
            return col;
        };
        // Fetch the CSV file
        this.fetch();
    };;
// version: 2018-06-24-143455
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    /**
    * This is a library of a few functions that make it easier to do
    * effects like fade-ins or eaxpansion.
    */
    /**
    * Initialise the various objects
    */
    RGraph        = window.RGraph || {isRGraph: true};
    RGraph.SVG    = RGraph.SVG    || {};
    RGraph.SVG.FX = RGraph.SVG.FX || {};
// Module pattern
(function (win, doc, undefined)
{
    var RG = RGraph,
        ua = navigator.userAgent,
        ma = Math;
    /**
    * This functions adds the generic effects to thechart object
    * 
    * @param object obj The chart object
    */
    RG.SVG.FX.decorate = function (obj)
    {
        for (i in RG.SVG.FX) {
            if (typeof RG.SVG.FX[i] === 'function') {
                obj[i] = RG.SVG.FX[i];
            }
        }
    };
    /**
    * fadeIn
    * 
    * This function simply uses the CSS opacity property - initially set to zero and
    * increasing to 1 over the period of 0.5 second
    */
    RG.SVG.FX.fadein = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {};
        // Initially the opacity should be zero
        obj.svg.style.opacity = 0;
        // Draw the chart
        RG.SVG.redraw(this.svg);
        // Now fade the chart in
        for (var i=1; i<=frames; ++i) {
            (function (index)
            {
                setTimeout(function ()
                {
                    obj.svg.style.opacity = (index / frames);
                    if (index >= frames) {
                        callback(obj);
                    }
                }, (index / frames) * duration);
            })(i)
        }
        return this;
    };
    /**
    * fadeOut
    * 
    * This function is a reversal of the above function - fading out instead of in
    */
    RG.SVG.FX.fadeout = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {};
         //RG.SVG.redraw()
        // Now fade the chart out
        for (var i=1; i<=frames; ++i) {
            (function (index)
            {
                setTimeout(function ()
                {
                    obj.svg.style.opacity = 1 - (index / frames);
                    if (index >= frames) {
                        callback(obj);
                    }
                }, (index / frames) * duration);
            })(i)
        }
        return this;
    };
    /**
    * fadeSlideIn
    * 
    * This function fades the canvas in in a sliding motion
    */
    RG.SVG.FX.fadeslidein = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            frame    = 0,
            pc       = -20,
            step     = (120 - pc) / frames,
            color    = opt.color || 'white',
            width    = this.container.offsetWidth,
            height   = this.container.offsetHeight,
            callback = opt.callback || function () {};
        // Draw the chart
        RG.SVG.redraw(this.svg);
        // Create the cover
        $('<div id="rgraph_fadeslide_cover_' + obj.id + '"></div>').css({
            background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)',
            width:      width  + 'px',
            height:     height + 'px',
            top:        0,
            left:       0,
            position:   'absolute'
        }).appendTo($(this.container));
        function iterator ()
        {
            if (pc < 120) {
                $('div#rgraph_fadeslide_cover_' + obj.id).css({
                    background: 'linear-gradient(135deg, rgba(255,255,255,0) ' + pc + '%, ' + color + ' ' + (pc + 20) + '%)'
                });
                pc += step;
                RG.SVG.FX.update(iterator);
            } else {
                $('div#rgraph_fadeslide_cover_' + obj.id).remove();
                callback(obj);
            }
        }
        iterator();
        return this;
    };
    //
    // fadeSlideOut
    //
    // Fades the canvas out in a sliding motion. This function gets added
    // to the chart object - so the this variable is the chart object
    //
    RG.SVG.FX.fadeslideout = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            frame    = 0,
            pc       = -20,
            step     = (120 - pc) / frames,
            canvasXY = RG.SVG.getSVGXY(obj.svg),
            color    = opt.color || 'white',
            width    = this.container.offsetWidth,
            height   = this.container.offsetHeight,
            callback = opt.callback || function () {};
        // Draw the chart
        //RG.SVG.redraw(this.svg);
        // Create the cover
        $('<div id="rgraph_fadeslide_cover_' + obj.id + '"></div>').css({
            background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)',
            width:      width + 'px',
            height:     height + 'px',
            top:        0,
            left:       0,
            position:   'absolute'
        }).appendTo($(obj.svg.parentNode));
        function iterator ()
        {
            if (pc < 120) {
                $('div#rgraph_fadeslide_cover_' + obj.id).css({
                                                               background: 'linear-gradient(135deg, ' + color + ' ' + pc + '%, rgba(255,255,255,0) ' + (pc + 20) + '%)'
                                                              });
                pc += step;
                RG.SVG.FX.update(iterator);
            } else {
                RG.SVG.clear(obj.svg);
                $('div#rgraph_fadeslide_cover_' + obj.id).remove();
                callback(obj);
            }
        }
        iterator();
        return this;
    };
    //
    // fadeCircularIn
    // 
    // This function uses radial CSS gradients to cover the canvas with a radial fade in effect
    // (from the center outwards)
    //
    RG.SVG.FX.fadecircularinoutwards = function ()
    {
        // This function gets added to the chart object - so the 'this'
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            frame    = 1,
            radius   = 0,
            svgXY    = RG.SVG.getSVGXY(obj.svg),
            color    = opt.color || 'white',
            callback = opt.callback || function () {};
        // Draw the chart
        RG.SVG.redraw(this.svg);
        // Create the cover
        $('<div id="rgraph_fadecircularinoutwards_cover_' + obj.id + '"></div>').css({
            background: 'radial-gradient(rgba(255,255,255,0) 0%, ' + color + ' ' + radius + '%)',
            width:      this.container.offsetWidth + 'px',
            height:     this.container.offsetHeight + 'px',
            top:        0,
            left:       0,
            position:   'absolute'
        }).appendTo($(obj.svg.parentNode));
        function iterator ()
        {
            if (frame < frames) {
                    $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).css({
                        background: 'radial-gradient(rgba(255,255,255,0) ' + ((frame++ / frames) * 100) + '%, ' + color + ' ' + ((frame++ / frames) * 150) + '%)'
                    });
                    RG.SVG.FX.update(iterator);
            } else {
                $('div#rgraph_fadecircularinoutwards_cover_' + obj.id).remove();
                callback(obj);
            }
        }
        iterator();
        return this;
    };
    //
    // fadecircularoutoutwards
    // 
    // This function uses radial CSS gradients to cover the canvas with a radial fade out effect
    // (from the center outwards)
    //
    RG.SVG.FX.fadecircularoutoutwards = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            frame    = 0,
            width    = this.container.offsetWidth,
            height   = this.container.offsetHeight,
            canvasXY = RG.SVG.getSVGXY(obj.svg),
            color    = opt.color || 'white',
            callback = opt.callback || function () {};
        // Draw the chart
        //RG.SVG.redraw(this.svg);
        // Create the cover
        $('<div id="rgraph_fadeslide_cover_' + obj.id + '"></div>').css({
            background: 'radial-gradient(rgba(255,255,255,0) 0%, transparent 0%)',
            width:      width + 'px',
            height:     height + 'px',
            top:        0,
            left:       0,
            position:   'absolute'
        }).appendTo($(obj.svg.parentNode));
        function iterator ()
        {
            if (frame < frames) {
                    $('div#rgraph_fadeslide_cover_' + obj.id).css({
                        background: 'radial-gradient(' + color + ' ' + ((frame++ / frames) * 100) + '%, rgba(255,255,255,0) ' + ((frame++ / frames) * 150) + '%)'
                    });
                    RG.SVG.FX.update(iterator);
            } else {
                RG.SVG.clear(obj.svg);
                $('div#rgraph_fadeslide_cover_' + obj.id).remove();
                callback(obj);
            }
        }
        iterator();
        return this;
    };
    //
    // fadeCircularInInwards
    //
    // This function gets added to the chart object - so the 'this'
    // variable is the chart object
    //
    RG.SVG.FX.fadecircularininwards = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            frame    = 0,
            radius   = ma.max(
                obj.container.offsetWidth,
                obj.container.offsetHeight
            ),
            color    = opt.color || 'white',
            callback = opt.callback || function () {};
        // Draw the chart
        RG.SVG.redraw(this.svg);
        // Create the cover
        $('<div id="rgraph_fadeslide_cover_' + obj.id + '"></div>').css({
            background: 'radial-gradient(rgba(255,255,255,0) 100%, rgba(255,255,255,0) 0%)',
            width:      this.container.offsetWidth + 'px',
            height:     this.container.offsetHeight + 'px',
            top:        0,
            left:       0,
            position:   'absolute'
        }).appendTo($(obj.svg.parentNode));
        function iterator ()
        {
            if (frame < frames) {
                    $('div#rgraph_fadeslide_cover_' + obj.id).css({
                        background: 'radial-gradient(' + color + ' ' + (( (frames - frame++) / frames) * 100) + '%, rgba(255,255,255,0) ' + (( (frames - frame++) / frames) * 120) + '%)'
                    });
                    RG.SVG.FX.update(iterator);
            } else {
                $('div#rgraph_fadeslide_cover_' + obj.id).remove();
                callback(obj);
            }
        }
        iterator();
        return this;
    };
    //
    // fadecircularoutinwards
    //
    // This function gets added to the chart object - so the this
    // variable is the chart object
    //
    RG.SVG.FX.fadecircularoutinwards = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            frame    = 0,
            radius   = ma.max(
                this.container.offsetWidth,
                this.container.offsetHeight
            ),
            color    = opt.color || 'white',
            callback = opt.callback || function () {};
        // Draw the chart
        //RG.SVG.redraw(this.svg);
        // Create the cover
        $('<div id="rgraph_fadeslide_cover_' + this.id + '"></div>').css({
            background: 'radial-gradient(rgba(255,255,255,0) 0%, rgba(255,255,255,0) 0%)',
            width:      this.container.offsetWidth + 'px',
            height:     this.container.offsetHeight + 'px',
            top:        0,
            left:       0,
            position:   'absolute'
        }).appendTo($(obj.svg.parentNode));
        function iterator ()
        {
            if (frame < frames) {
                    $('div#rgraph_fadeslide_cover_' + obj.id).css({
                        background: 'radial-gradient(rgba(255,255,255,0) ' + (( (frames - frame++) / frames) * 100) + '%, ' + color + ' ' + (( (frames - frame++) / frames) * 120) + '%)'
                    });
                    RG.SVG.FX.update(iterator);
            } else {
                RG.SVG.clear(obj.svg);
                $('div#rgraph_fadeslide_cover_' + obj.id).remove();
                callback(obj);
            }
        }
        iterator();
        return this;
    };
    //
    // Reveal
    // 
    // With this effect the chart is slowly revealed from the centre outwards. This
    // function gets added to the chart object - so the 'this' variable is the chart
    // object
    // 
    // @param object    Options for the effect. You can give frames here
    // @param function  An optional callback function
    //
    RG.SVG.FX.reveal = function ()
    {
        var obj       = this,
            opt       = arguments[0] || {}
            color     = opt.color    || 'white',
            frames    = opt.frames   || 90,
            duration  = (frames / 60) * 1000,
            callback  = opt.callback || function () {}
        var divs = [
            ['rgraph_reveal_left_'   + this.id, 0, 0, this.container.offsetWidth  / 2, this.container.offsetHeight],
            ['rgraph_reveal_right_'  + this.id,(this.container.offsetWidth  / 2),0,(this.container.offsetWidth  / 2),this.container.offsetHeight],
            ['rgraph_reveal_top_'    + this.id,0,0,this.container.offsetWidth,(this.container.offsetHeight / 2)],
            ['rgraph_reveal_bottom_' + this.id,0,(this.container.offsetHeight  / 2),this.container.offsetWidth,(this.container.offsetHeight / 2)]
        ];
        for (var i=0,len=divs.length; i<len; ++i) {
            var div = doc.createElement('DIV');
                div.id                    = divs[i][0];
                div.style.left            = divs[i][1] + 'px';
                div.style.top             = divs[i][2] + 'px';
                div.style.width           = divs[i][3] + 'px';
                div.style.height          = divs[i][4] + 'px';
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            this.container.appendChild(div);
        }
        // Redraw
        RG.SVG.redraw(obj.svg);
        // Animate the shrinking of the DIVs
        jQuery('#rgraph_reveal_left_'   + obj.id).animate({width: 0}, duration);
        jQuery('#rgraph_reveal_right_'  + obj.id).animate({left: '+=' + (this.container.offsetWidth / 2),width: 0}, duration);
        jQuery('#rgraph_reveal_top_'    + obj.id).animate({height: 0}, duration);
        jQuery('#rgraph_reveal_bottom_' + obj.id).animate({top: '+=' + (this.container.offsetHeight / 2),height: 0}, duration);
        // Remove the DIVs from the DOM 100ms after the animation ends
        setTimeout(function ()
        {
            obj.container.removeChild(doc.getElementById("rgraph_reveal_top_" + obj.id));
            obj.container.removeChild(doc.getElementById("rgraph_reveal_bottom_" + obj.id));
            obj.container.removeChild(doc.getElementById("rgraph_reveal_left_" + obj.id));
            obj.container.removeChild(doc.getElementById("rgraph_reveal_right_" + obj.id));
            callback(obj);
        }, duration);
        return this;
    };
    //
    // Conceal
    // 
    // This effect is the reverse of the Reveal effect - instead of revealing
    // the canvas it conceals it. Combined with the reveal effect would make
    // for a nice wipe effect.
    // 
    // @param object obj The chart object
    ///
    RG.SVG.FX.conceal = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames   || 90,
            callback = opt.callback || function () {},
            color    = opt.color    || 'white',
            duration = (frames / 60) * 1000,
            frame    = 0;
        var divs = [
            ['rgraph_conceal_left_' + obj.id, 0, 0, 0, this.container.offsetHeight],
            ['rgraph_conceal_right_' + obj.id,this.container.offsetWidth,0,0,this.container.offsetHeight],
            ['rgraph_conceal_top_' + obj.id,0,0,this.container.offsetWidth,0],
            ['rgraph_conceal_bottom_' + obj.id,0,this.container.offsetHeight,this.container.offsetWidth,0]
        ];
        for (var i=0,len=divs.length; i<len; ++i) {
            var div = doc.createElement('DIV');
                div.id                    = divs[i][0];
                div.style.left            = divs[i][1] + 'px';
                div.style.top             = divs[i][2] + 'px';
                div.style.width           = divs[i][3] + 'px';
                div.style.height          = divs[i][4] + 'px';
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            this.container.appendChild(div);
        }
        jQuery('#rgraph_conceal_left_' + obj.id).animate({width: '+=' + (this.container.offsetWidth / 2)}, duration);
        jQuery('#rgraph_conceal_right_' + obj.id).animate({left: '-=' + (this.container.offsetWidth / 2),width: (this.container.offsetWidth / 2)}, duration);
        jQuery('#rgraph_conceal_top_' + obj.id).animate({height: '+=' + (this.container.offsetHeight / 2)}, duration);
        jQuery('#rgraph_conceal_bottom_' + obj.id).animate({top: '-=' + (this.container.offsetHeight / 2),height: (this.container.offsetHeight / 2)}, duration);
        // Remove the DIVs from the DOM 100ms after the animation ends
        setTimeout(
            function ()
            {
                obj.container.removeChild(doc.getElementById("rgraph_conceal_top_" + obj.id));
                obj.container.removeChild(doc.getElementById("rgraph_conceal_bottom_" + obj.id));
                obj.container.removeChild(doc.getElementById("rgraph_conceal_left_" + obj.id));
                obj.container.removeChild(doc.getElementById("rgraph_conceal_right_" + obj.id));
                RG.SVG.clear(obj.svg);
                callback(obj);
            },
            duration
        );
        return this;
    };
    //
    // Horizontal Blinds (open)
    // 
    // @params object obj The graph object
    //
    RG.SVG.FX.hblindsopen = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color || 'white',
            height   = this.container.offsetHeight / 5;
        //
        // First draw the chart
        //
        RG.SVG.redraw(this.svg);
        for (var i=0; i<5; ++i) {
            var div = doc.createElement('DIV');
                div.id                    = 'rgraph_hblinds_' + i + '_' + obj.id;
                div.style.left            = 0;
                div.style.top             = ((this.container.offsetHeight * (i / 5))) + 'px';
                div.style.width           = this.container.offsetWidth + 'px';
                div.style.height          = (this.container.offsetHeight / 5) + 'px';
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            this.container.appendChild(div);
            jQuery('#rgraph_hblinds_' + i + '_' + obj.id).animate({height: 0}, duration);
        }
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));}, duration);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));}, duration);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));}, duration);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));}, duration);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));}, duration);
        setTimeout(function () {callback(obj);}, duration);
        return this;
    };
    //
    // Horizontal Blinds (close)
    // 
    // This function gets added to the chart object - so the this
    // variable is the chart object
    //
    // @params object obj The graph object
    //
    RG.SVG.FX.hblindsclose = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color = 'white',
            height   = this.container.offsetHeight / 5;
        for (var i=0; i<5; ++i) {
            var div = doc.createElement('DIV');
                div.id                    = 'rgraph_hblinds_' + i + '_' + obj.id;
                div.style.left            = 0;
                div.style.top             = (this.container.offsetHeight * (i / 5)) + 'px';
                div.style.width           = this.container.offsetWidth + 'px';
                div.style.height          = 0;
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            this.container.appendChild(div);
            jQuery('#rgraph_hblinds_' + i + '_' + obj.id)
                .animate({
                    height: height + 'px'
                }, duration);
        }
        setTimeout(function () {RG.SVG.clear(obj.svg);}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_0_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_1_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_2_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_3_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_hblinds_4_' + obj.id));}, duration + 100);
        setTimeout(function () {callback(obj);}, duration + 100);
    };
    //
    // Vertical Blinds (open)
    // 
    // @params object obj The graph object
    //
    // This function gets added to the chart object - so the this
    // variable is the chart object
    RG.SVG.FX.vblindsopen = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color || 'white',
            width    = this.container.offsetWidth / 10;
        //
        // First draw the chart
        //
        RG.SVG.redraw(obj.svg);
        for (var i=0; i<10; ++i) {
            var div = doc.createElement('DIV');
                div.id = 'rgraph_vblinds_' + i + '_' + obj.id;
                div.style.width           =  width + 'px';
                div.style.height          = this.container.offsetHeight + 'px';
                div.style.left            = (this.container.offsetWidth * (i / 10)) + 'px';
                div.style.top             = 0;
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            obj.container.appendChild(div);
            jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({width: 0}, duration);
        }
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));}, duration + 100);
        setTimeout(function () {callback(obj);}, duration + 100);
        return this;
    };
    //
    // Vertical Blinds (close)
    //
    // This function gets added to the chart object - so the this
    // variable is the chart object
    // 
    // @params object obj The graph object
    //
    RG.SVG.FX.vblindsclose = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color || 'white',
            width    = this.container.offsetWidth / 10;
        // Create the blinds
        for (var i=0; i<10; ++i) {
            var div = doc.createElement('DIV');
                div.id                    = 'rgraph_vblinds_' + i + '_' + obj.id;
                div.style.left            = (this.container.offsetWidth * (i / 10)) + 'px';
                div.style.top             = 0;
                div.style.width           = 0;
                div.style.height          = this.container.offsetHeight + 'px';
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            this.container.appendChild(div);
            jQuery('#rgraph_vblinds_' + i + '_' + obj.id).animate({width: width}, duration);
        }
        setTimeout(function () {RG.SVG.clear(obj.svg);}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_0_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_1_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_2_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_3_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_4_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_5_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_6_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_7_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_8_' + obj.id));}, duration + 100);
        setTimeout(function () {obj.container.removeChild(doc.getElementById('rgraph_vblinds_9_' + obj.id));}, duration + 100);
        setTimeout(function () {callback(obj);}, duration + 100);
        return this;
    };
    //
    // Slide in
    // 
    // This function is a wipe that can be used when switching the canvas to a
    // new graph
    //
    // This function gets added to the chart object - so the this
    // variable is the chart object
    // 
    // @param object obj The graph object
    //
    RG.SVG.FX.slidein = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color || 'white',
            width    = this.container.offsetWidth / 10,
            from     = opt.from || 'left';
        this.container.style.overflow = 'hidden';
        RG.SVG.redraw(this.svg);
        this.svg.style.position = 'relative';
        if (from == 'left') {
            this.svg.style.left = (0 - this.container.offsetWidth) + 'px';
            this.svg.style.top  = 0;
        } else if (from == 'top') {
            this.svg.style.left = 0;
            this.svg.style.top  = (0 - this.container.offsetHeight) + 'px';
        } else if (from == 'bottom') {
            this.svg.style.left = 0;
            this.svg.style.top  = this.container.offsetHeight + 'px';
        } else {
            this.svg.style.left = this.container.offsetWidth + 'px';
            this.svg.style.top  = 0;
        }
        jQuery(this.svg).animate({left:0,top:0}, duration, function ()
        {
            callback(obj);
        });
        return this;
    };
    //
    // Slide out
    // 
    // This function is a wipe that can be used when switching the canvas to a new graph
    // 
    // @param object   Optional object containing configuration.
    // @param function Optional callback function
    //
    RG.SVG.FX.slideout = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var opt      = arguments[0] || {},
            frames   = opt.frames   || 90,
            color    = opt.color    || 'white',
            to       = opt.to       || 'left',
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            width    = this.container.offetsWidth / 10;
        this.container.style.overflow= 'hidden';
        this.svg.style.position = 'relative';
        this.svg.style.left     = 0;
        this.svg.style.top      = 0;
        if (to == 'left') {
            jQuery(this.svg).animate({left: (0 - this.container.offsetWidth) + 'px'}, duration, function () {callback(this);});
        } else if (to == 'top') {
            jQuery(this.svg).animate({left: 0, top: (0 - this.container.offsetHeight) + 'px'}, duration, function () {callback(this);});
        } else if (to == 'bottom') {
            jQuery(this.svg).animate({top: (0 + this.container.offsetHeight) + 'px'}, duration, function () {callback(this);});
        } else {
            jQuery(this.svg).animate({left: (0 + this.container.offsetWidth) + 'px'}, duration, function () {callback(this);});
        }
        return this;
    };
    //
    // Horizontal Scissors (open)
    //
    // This function gets added to the chart object - so the this
    // variable is the chart object
    // 
    // @param object      Optional array of options
    // @param function     Optional callback function
    // 
    //
    RG.SVG.FX.hscissorsopen = function ()
    {
        var opt      = arguments[0] || {},
            obj      = this,
            frames   = opt.frames   || 90,
            callback = opt.callback || function () {},
            color    = opt.color    || 'white',
            to       = opt.to       || 'left',
            frame    = 0,
            duration = (frames / 60) * 1000,
            width    = this.container.offsetWidth / 10,
            height   = this.container.offsetHeight / 5;
        //
        // First draw the chart
        //
        RG.SVG.redraw(this.svg);
        for (var i=0; i<5; ++i) {
            var div = doc.getElementById("rgraph_hscissors_" + i + '_' + this.id)
            if (!div) {
                var div    = doc.createElement('DIV');
                    div.id = 'rgraph_hscissors_' + i + '_' + this.id;
                    div.style.width =  this.container.offsetWidth + 'px';
                    div.style.height = (this.container.offsetHeight / 5) + 'px';
                    div.style.left   = 0;
                    div.style.top   = (this.container.offsetHeight * (i / 5)) + 'px';
                    div.style.position = 'absolute';
                    div.style.backgroundColor = color;
                this.container.appendChild(div);
            }
            if (i % 2 == 0) {
                jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({left: this.container.offsetWidth + 'px', width: 0}, duration);
            } else {
                jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({width: 0}, duration);
            }
        }
        setTimeout(function ()
        {
            obj.container.removeChild(doc.getElementById('rgraph_hscissors_0_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_hscissors_1_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_hscissors_2_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_hscissors_3_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_hscissors_4_' + obj.id));
            callback(obj);
        }, duration);
        return this;
    };
    //
    // Horizontal Scissors (Close)
    //
    // This function gets added to the chart object - so the this
    // variable is the chart object
    // 
    // @param @object      Optional object of options
    // @param function     Optional callback function
    // 
    //
    RG.SVG.FX.hscissorsclose = function ()
    {
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 60,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color || 'white',
            height   = this.container.offsetHeight / 5;
        for (var i=0; i<5; ++i) {
            var div                       = doc.createElement('DIV');
                div.id                    = 'rgraph_hscissors_' + i + '_' + this.id;
                div.style.width           = 0;
                div.style.height          = height + 'px';
                div.style.left            = (i % 2 == 0 ? this.container.offsetWidth : 0) + 'px';
                div.style.top             = (this.container.offsetHeight * (i / 5)) + 'px';
                div.style.position        = 'absolute';
                div.style.backgroundColor = color;
            this.container.appendChild(div);
            if (i % 2 == 0) {
                jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({left: 0, width: this.container.offsetWidth + 'px'}, duration);
            } else {
                jQuery('#' + 'rgraph_hscissors_' + i + '_' + this.id).animate({width: this.container.offsetWidth + 'px'}, duration);
            }
        }
        setTimeout(function ()
        {
            RG.SVG.clear(obj.svg);
            jQuery('#' + 'rgraph_hscissors_' + 0 + '_' + obj.id).remove();
            jQuery('#' + 'rgraph_hscissors_' + 1 + '_' + obj.id).remove();
            jQuery('#' + 'rgraph_hscissors_' + 2 + '_' + obj.id).remove();
            jQuery('#' + 'rgraph_hscissors_' + 3 + '_' + obj.id).remove();
            jQuery('#' + 'rgraph_hscissors_' + 4 + '_' + obj.id).remove();
            callback(obj);
        }, duration);
        return this;
    };
    //
    // Vertical Scissors (open)
    // 
    // @param @object  Optional An object of options. It can consist of:
    //                  o color    - The color of the scissors. The default is white
    //                  o frames   - Number of animation frames in the effect. Default
    //                               is 60
    //                  o callback - A function that's called when the effect is
    //                               finished
    //
    RG.SVG.FX.vscissorsopen = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color || 'white',
            width    = this.container.offsetWidth / 10;
        //
        // First (re)draw the chart
        //
        RG.SVG.redraw(this.svg);
        for (var i=0; i<10; ++i) {
            var div = doc.getElementById("rgraph_vscissors_" + i + '_' + this.id);
            if (!div) {
                var div = doc.createElement('DIV');
                    div.id = 'rgraph_vscissors_' + i + '_' + this.id;
                    div.style.width           =  width + 'px';
                    div.style.height          = this.container.offsetHeight + 'px';
                    div.style.left            = this.container.offsetWidth * (i / 10) + 'px';
                    div.style.top             = 0;
                    div.style.position        = 'absolute';
                    div.style.backgroundColor = color;
                this.container.appendChild(div);
            }
            if (i % 2 == 0) {
                jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({top: this.container.offsetHeight + 'px', height: 0}, duration);
            } else {
                jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({height: 0}, duration);
            }
        }
        setTimeout(function ()
        {
            obj.container.removeChild(doc.getElementById('rgraph_vscissors_0' + '_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_vscissors_1' + '_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_vscissors_2' + '_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_vscissors_3' + '_' + obj.id));
            obj.container.removeChild(doc.getElementById('rgraph_vscissors_4' + '_' + obj.id));
            callback(obj);
        }, duration);
        return this;
    };
    //
    // Vertical Scissors (close)
    //
    RG.SVG.FX.vscissorsclose = function ()
    {
        // This function gets added to the chart object - so the this
        // variable is the chart object
        var obj      = this,
            opt      = arguments[0] || {},
            frames   = opt.frames || 90,
            duration = (frames / 60) * 1000,
            frame    = 0,
            callback = opt.callback || function () {},
            color    = opt.color  || 'white',
            width    = this.container.offsetWidth / 10;
        for (var i=0; i<10; ++i) {
            var div = doc.getElementById("rgraph_vscissors_" + i + '_' + this.id)
            if (!div) {
                var div                = doc.createElement('DIV');
                    div.id             = 'rgraph_vscissors_' + i + '_' + this.id;
                    div.style.width    =  width + 'px';
                    div.style.height   = 0;
                    div.style.left     = (width * i) + 'px';
                    div.style.top      = (i % 2 == 0 ? this.container.offsetHeight : 0) + 'px';
                    div.style.position = 'absolute';
                    div.style.backgroundColor = color;
                this.container.appendChild(div);
            }
            if (i % 2 == 0) {
                jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({top: 0, height: this.container.offsetHeight + 'px'}, duration);
            } else {
                jQuery('#' + 'rgraph_vscissors_' + i + '_' + this.id).animate({height: this.container.offsetHeight + 'px'}, duration);
            }
        }
        setTimeout(function ()
        {
            RG.SVG.clear(obj.svg);
            for (var i=0; i<10; i++) {
                jQuery('#rgraph_vscissors_' + i + '_' + obj.id).remove();
            }
            callback(obj);
        }, duration);
        return this;
    };
// End Module pattern
})(window, document);;
// version: 2018-06-24-143455
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    RGraph          = window.RGraph || {isRGraph: true};
    RGraph.SVG      = RGraph.SVG || {};
    RGraph.SVG.HTML = RGraph.SVG.HTML || {};
// Module pattern
(function (win, doc, undefined)
{
    var RG = RGraph,
        ua = navigator.userAgent,
        ma = Math;
    /**
    * Draws the graph key (used by various graphs)
    * 
    * @param object obj The graph object
    * @param array  key An array of the texts to be listed in the key
    * @param colors An array of the colors to be used
    */
    RG.SVG.drawKey = function (obj)
    {
        var prop          = obj.properties,
            key           = prop.key,
            colors        = prop.keyColors || prop.colors,
            defaultFont   = 'Arial',
            blobSize      = 0,
            width         = 0,
            keyColorShape = prop.keyColorShape;
        // Work out the center point of the SVG tag
        var centerx = obj.svg.getAttribute('width') / 2;
        // If we're drawing a key on a funnel then work out the center of
        // the chart differently. This may be useful to other chart types
        // too
        if (obj.type === 'funnel') {
            centerx = (obj.graphWidth / 2) + prop.gutterLeft;
        }
        // Loop thru the key and draw them
        if (key && key.length) {
            // First measure the length so that the key can be centered
            for (var i=0,length = 0; i<key.length; i++) {
                // First measure the text
                var textDimensions = RG.SVG.measureText({
                    text: key[i],
                    bold: prop.keyTextBold || false,
                    font: prop.keyTextFont || prop.textFont || defaultFont,
                    size: prop.keyTextSize || prop.textSize
                });
                blobSize = ma.max(blobSize, textDimensions[1]);
                width = width + 10 + blobSize + 5 + textDimensions[0];
            }
            // Center the key
            x = centerx - width / 2;
            for (var i=0,y=prop.gutterTop - 5; i<key.length; ++i) {
                // Do this on the first iteration only
                if (i === 0) {
                    if (obj.type === 'pie' && prop.highlightStyle == 'outline') {
                        y -= prop.highlightStyleOutlineWidth;
                    }
                }
                // First measure the text
                var textDimensions = RG.SVG.measureText({
                    text: key[i],
                    bold: prop.keyTextBold || false,
                    font: prop.keyTextFont || prop.textFont || defaultFont,
                    size: prop.keyTextSize || prop.textSize
                });
                //
                // Draw the blob of color (accounting for it being an array first)
                //
                var shape = prop.keyColorShape;
                if (typeof shape === 'object') {
                    shape = prop.keyColorShape[i];
                }
                // A circle
                if (shape === 'circle') {
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'circle',
                        parent: obj.svg.all,
                        attr: {
                            cx: x + (blobSize / 2)  + prop.keyOffsetx,
                            cy: y - (blobSize / 2) + prop.keyOffsety,
                            r: blobSize / 2,
                            fill: colors[i]
                        }
                    });
                // A triangle
                } else if (shape === 'triangle') {
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'path',
                        parent: obj.svg.all,
                        attr: {
                            d: 'M {1} {2} L {3} {4} L {5} {6} z'.format(
                                x + prop.keyOffsetx + (blobSize / 2),
                                y - blobSize + prop.keyOffsety,
                                x + prop.keyOffsetx + blobSize,
                                y + prop.keyOffsety,
                                x + prop.keyOffsetx,
                                y + prop.keyOffsety                                
                            ),
                            fill: colors[i]
                        }
                    });
                // A line
                } else if (shape === 'line') {
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'path',
                        parent: obj.svg.all,
                        attr: {
                            d: 'M {1} {2} L {3} {4}'.format(
                                x + prop.keyOffsetx,
                                y - (blobSize / 2) + prop.keyOffsety,
                                x + prop.keyOffsetx + blobSize,
                                y - (blobSize / 2) + prop.keyOffsety
                            ),
                            stroke: colors[i],
                            'stroke-width': 2,
                            'stroke-linecap': 'round'
                        }
                    });
                // A dot
                } else if (shape === 'dot') {
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'path',
                        parent: obj.svg.all,
                        attr: {
                            d: 'M {1} {2} L {3} {4}'.format(
                                x + prop.keyOffsetx,
                                y - (blobSize / 2) + prop.keyOffsety,
                                x + prop.keyOffsetx + blobSize,
                                y - (blobSize / 2) + prop.keyOffsety
                            ),
                            stroke: colors[i],
                            'stroke-width': 2,
                            'stroke-linecap': 'round'
                        }
                    });
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'circle',
                        parent: obj.svg.all,
                        attr: {
                            cx: x + (blobSize / 2)  + prop.keyOffsetx,
                            cy: y - (blobSize / 2) + prop.keyOffsety,
                            r: blobSize / 4,
                            fill: colors[i]
                        }
                    });
                // A dot
                } else if (shape === 'squaredot' || shape === 'rectdot') {
                    // Create the line
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'path',
                        parent: obj.svg.all,
                        attr: {
                            d: 'M {1} {2} L {3} {4}'.format(
                                x + prop.keyOffsetx,
                                y - (blobSize / 2) + prop.keyOffsety,
                                x + prop.keyOffsetx + blobSize,
                                y - (blobSize / 2) + prop.keyOffsety
                            ),
                            stroke: colors[i],
                            'stroke-width': 2,
                            'stroke-linecap': 'round'
                        }
                    });
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'rect',
                        parent: obj.svg.all,
                        attr: {
                            x: x + (blobSize / 4) + prop.keyOffsetx,
                            y: y + (blobSize / 4) - blobSize + prop.keyOffsety,
                            width: blobSize / 2,
                            height: blobSize / 2,
                            fill: colors[i]
                        }
                    });
                // Ccustom
                } else if (typeof shape === 'function') {
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'path',
                        parent: obj.svg.all,
                        attr: {
                            d: 'M {1} {2} L {3} {4}'.format(
                                x + prop.keyOffsetx,
                                y - (blobSize / 2) + prop.keyOffsety,
                                x + prop.keyOffsetx + blobSize,
                                y - (blobSize / 2) + prop.keyOffsety
                            ),
                            stroke: colors[i],
                            'stroke-width': 2,
                            'stroke-linecap': 'round'
                        }
                    });
                // A rectangle default
                } else {
                    RG.SVG.create({
                        svg: obj.svg,
                        type: 'rect',
                        parent: obj.svg.all,
                        attr: {
                            x: x + prop.keyOffsetx,
                            y: y - blobSize + prop.keyOffsety,
                            width: blobSize,
                            height: blobSize,
                            fill: colors[i]
                        }
                    });
                }
                //
                // Add the text
                //
                RGraph.SVG.text({
                    object:     obj,
                    parent:     obj.svg.all,
                    tag:        'key',
                    size:       prop.keyTextSize || prop.textSize,
                    bold:       typeof prop.keyTextBold === 'boolean' ? prop.keyTextBold : prop.textBold,
                    italic:     typeof prop.keyTextItalic === 'boolean' ? prop.keyTextItalic : prop.textItalic,
                    font:       prop.keyTextFont || prop.textFont,
                    halign:     'left',
                    valign:     'bottom',
                    text:       key[i],
                    x:          x + blobSize + 5 + prop.keyTextOffsetx + prop.keyOffsetx,
                    y:          y + prop.keyTextOffsety + prop.keyOffsety,
                    color:      prop.keyTextColor || 'black',
                    background: prop.keyTextBackground || 'white',
                    padding:    0
                })
                x += 10 + blobSize + 5 + textDimensions[0];
            }
        }
    };
    /**
    * Create a TABLE based HTML key. There's lots of options so it's
    * suggested that you consult the documentation page
    * 
    * @param mixed id   This should be a string consisting of the ID of the container
    * @param object prop An object map of the various properties that you can use to
    *                    configure the key. See the documentation page for a list.
    */
    RG.SVG.HTML.key = function (id, prop)
    {
        var div = doc.getElementById(id);
        /**
        * Create the table that becomes the key
        */
        var str = '<table border="0" cellspacing="0" cellpadding="0" id="rgraph_key" style="display: inline;' + (function ()
            {
                var style = ''
                for (i in prop.tableCss) {
                    if (typeof i === 'string') {
                        style = style + i + ': ' + prop.tableCss[i] + ';';
                    }
                }
                return style;
            })() + '" ' + (prop.tableClass ? 'class="' + prop.tableClass + '"' : '') + '>';
        /**
        * Add the individual key elements
        */
        for (var i=0; i<prop.labels.length; i+=1) {
            str += '<tr><td><div style="' + (function ()
            {
                var style = '';
                for (var j in prop.blobCss) {
                    if (typeof j === 'string') {
                        style = style + j + ': ' + prop.blobCss[j] + ';';
                    }
                }
                return style;
            })() + 'display: inline-block; margin-right: 5px; margin-top: 4px; width: 15px; height: 15px; background-color: ' + prop.colors[i] + '"' + (prop.blobClass ? 'class="' + prop.blobClass + '"' : '') + '>&nbsp;</div><td>' + (prop.links && prop.links[i] ? '<a href="' + prop.links[i] + '">' : '') + '<span ' + (prop.labelClass ? 'class="' + prop.labelClass + '"' : '') + '" style="' + (function ()
            {
                var style = '';
                for (var j in prop.labelCss) {
                    if (typeof j === 'string') {
                        style = style + j + ': ' + prop.labelCss[j] + ';';
                    }
                }
                return style;
            })() + '" ' + (function ()
            {
                var style = '';
                if (prop['labelCss_' + i]) {
                    for (var j in prop['labelCss_' + i]) {
                        style = style + j + ': ' + prop['labelCss_' + i][j] + ';';
                    }
                }
                return style ? 'style="' + style + '"' : '';
            })() + '>' + prop.labels[i] + '</span>' + (prop.links && prop.links[i] ? '</a>' : '') + '</td></tr>';
        }
        div.innerHTML += (str + '</table>');
        // Return the TABLE object that is the HTML key
        return doc.getElementById('rgraph_key');
    };
// End module pattern
})(window, document);;
// version: 2018-06-24-143455
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    /**
    * Initialise the various objects
    */
    RGraph = window.RGraph || {isRGraph: true};
// Module pattern
(function (win, doc, undefined)
{
    RGraph.Sheets = function (key)
    {
        var worksheet,
            callback,
            letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        // 3 arguments
        if (arguments.length === 3) {
            worksheet = Number(arguments[1]);
            callback  = arguments[2];
        // 2 arguments
        } else {
            worksheet = 1;
            callback  = arguments[1];
        }
        var url = 'https://spreadsheets.google.com/feeds/cells/[KEY]/[WORKSHEET]/public/full?alt=json-in-script&callback=__rgraph_JSONPCallback'.replace(/\[KEY\]/, key).replace(/\[WORKSHEET\]/, worksheet);
        /*
        * https://spreadsheets.google.com/feeds/cells/1q_BMjvKO_kKbAO3VjoaITSDyrLAk8f0SK5UFMmE3oRs/2/public/full?alt=json-in-script
        */
        //
        // Loads the spreadsheet
        //
        this.load = function(url, userCallback)
        {
            var obj = this;
            // A global on purpose
            __rgraph_JSONPCallback = function (json)
            {
                // Save the JSON on the RGraph.Sheets object
                obj.json = json;
                //
                // Put the entries in the JSON feed into a grid
                //
                var grid = [], row = 0, col = 0;
                for (var i=0; i<json.feed.entry.length; ++i) {
                    row = json.feed.entry[i].gs$cell.row - 1;
                    col = json.feed.entry[i].gs$cell.col - 1;
                    if (!grid[row]) {
                        grid[row] = [];
                    }
                    grid[row][col] = json.feed.entry[i].content.$t;
                }
                //
                // Determine the longest row
                //
                var maxcols = 0; // The max length of the rows
                for (var i=0; i<grid.length; ++i) {
                    maxcols = grid[i] ? Math.max(maxcols, grid[i].length) : maxcols;
                }
                //
                // Now go through the array and fill in any blank holes.
                //
                for (var i=0; i<grid.length; ++i) {
                    if (typeof grid[i] === 'undefined') {
                        grid[i] = new Array(maxcols);
                    }
                    for (var j=0; j<maxcols; j++) {
                        if (typeof grid[i][j] === 'undefined') {
                            grid[i][j] = '';
                        }
                        // Convert numbers to real numbers and floats here too
                        if (grid[i][j].match(/^[0-9]+$/)) {
                            grid[i][j] = parseInt(grid[i][j]);
                        } else if (grid[i][j].match(/^[0-9.]+$/)) {
                            grid[i][j] = parseFloat(grid[i][j]);
                        }
                    }
                }
                //
                // Save the grid on the object
                //
                obj.data = grid;
                //
                // Call the users callback function. Users can access the raw data if
                // they want with the obj.data property or by using the accessor
                // methods (better)
                //
                userCallback(obj);
            };
            // Add the new script tag to the document that pulls in the JSON
            //
            // With jQuery...
            //
            //jQuery('body').append("\u003Cscript src='" + url + "'>\u003C/script\u003E");
            //
            // And without jQuery...
            var scriptNode = document.createElement('SCRIPT');
            scriptNode.src = url;
            document.body.appendChild(scriptNode);
        };
        //
        // Fetches a row of data and returns it
        //
        // @param id    number The numeric index of the column to fetch (starts at 1)
        // @param start number The index to start fetching/returning at. The first
        //                     character is 1
        // @param opt        An option object containing options
        //
        this.row = function (index, start)
        {
            var opt = {}, row;
            // Default for start is 1
            start = start || 1;
            //
            // Parse the .trim argument
            //
            if (arguments && typeof arguments[2] === 'object' && typeof arguments[2].trim === 'boolean') {
                opt.trim = arguments[2].trim;
            } else {
                opt.trim = true;
            }
            row = this.data[index - 1].slice(start - 1);
            // Trim the array if required
            if (opt.trim) {
                row = RGraph.SVG.arrayTrim(row);
            }
            return row;
        };
        //
        // Fetches a column of data and returns it
        //
        // @param id    number The letter that corresponds to the column
        // @param start number The index to start fetching/returning at. The first
        //                     character is 1
        // @param opt        An option object containing options
        //
        this.col = function (index, start)
        {
            var opt = {},
                col = [];
            // Default for start is 1
            start = start || 1;
            if (arguments && typeof arguments[2] === 'object' && typeof arguments[2].trim === 'boolean') {
                opt.trim = arguments[2].trim;
            } else {
                opt.trim = true;
            }
            for (var i=0; i<this.data.length; ++i) {
                col.push(this.data[i][index - 1]);
            }
            // Trim the array if required
            if (opt.trim) {
                col = RGraph.SVG.arrayTrim(col);
            }
            // Now account for the start index
            col = col.slice(start - 1);
            return col;
        };
        //
        // Returns the index (zero index) of the given letters
        //
        this.getIndexOfLetters = function (l)
        {
            var parts = l.split('');
            if (parts.length === 1) {
                return letters.indexOf(l) + 1;
            } else if (parts.length === 2){
                var idx = ((letters.indexOf(parts[0]) + 1) * 26) + (letters.indexOf(parts[1]) + 1);
                return idx;
            }
        }
        //
        // The get method makes retrieving cells very straightforward,
        // for example: obj.get('B1');
        //
        // @param str string The cells(s) to fetch
        // @param     string Optional set of options that are passed
        //                   to the relevant row/col function
        //
        this.get = function (str)
        {
            // Uppercase letters please!
            str = str.toUpperCase();
            //
            // Handle the style of .get('C') or .get('AA'
            //
            if (str.match(/^[a-z]+$/i)) {
                if (str.length === 1) {
                    var index = letters.indexOf(str) + 1;
                    return this.col(index, 1, arguments[1]);
                } else if (str.length === 2) {
                    var index = ((letters.indexOf(str[0]) + 1) * 26) + letters.indexOf(str[1]) + 1;
                    return this.col(index, 1, arguments[1]);
                }
            }
            //
            // Handle the style of .get('2');
            //(fetching a whole row
            //
            if (str.match(/^[0-9]+$/i)) {
                return this.row(str, null, arguments[1]);
            }
            //
            // Handle the style of .get('E2');
            //(fetching a single cell)
            //
            if (str.match(/^([a-z]{1,2})([0-9]+)$/i)) {
                var letter = RegExp.$1,
                    number = RegExp.$2,
                    col    = this.get(letter, {trim: false});
                return col[number - 1];
            }
            //
            // Handle the style of .get('B2:E2');
            //(fetching the E2 cell to the E2 cell)
            //
            if (str.match(/^([a-z]{1,2})([0-9]+):([a-z]{1,2})([0-9]+)$/i)) {
                var letter1 = RegExp.$1,
                    number1 = RegExp.$2,
                    letter2 = RegExp.$3,
                    number2 = RegExp.$4
                if (letter1 === letter2) {
                    var cells = [],
                        index = this.getIndexOfLetters(letter1),
                        col   = this.col(index, null, {trim: false});
                    for (var i=(number1 - 1); i<=(number2 - 1); ++i) {
                        cells.push(col[i]);
                    }
                } else if (number1 === number2) {
                    var cells = [],
                        row   = this.row(number1, null, {trim: false}),
                        index1 = this.getIndexOfLetters(letter1),
                        index2 = this.getIndexOfLetters(letter2)
                    for (var i=(index1 - 1); i<=(index2 - 1); ++i) {
                        cells.push(row[i]);
                    }
                }
                // Trim the results
                if (arguments[1] && arguments[1].trim === false) {
                    // Nada
                } else {
                    cells = RGraph.SVG.arrayTrim(cells);
                }
                return cells;
            }
        };
        //
        // Load the data
        //
        this.load(url, callback);
    };
// End module pattern
})(window, document);;
// version: 2018-06-24-143455
    /**
    * o--------------------------------------------------------------------------------o
    * | This file is part of the RGraph package - you can learn more at:               |
    * |                                                                                |
    * |                          http://www.rgraph.net                                 |
    * |                                                                                |
    * | RGraph is licensed under the Open Source MIT license. That means that it's     |
    * | totally free to use and there are no restrictions on what you can do with it!  |
    * o--------------------------------------------------------------------------------o
    */
    RGraph     = window.RGraph || {isRGraph: true,isRGraphSVG: true};
    RGraph.SVG = RGraph.SVG || {};
// Module pattern
(function (win, doc, undefined)
{
    var RG  = RGraph,
        ua  = navigator.userAgent,
        ma  = Math;
    /**
    * This is used in two functions, hence it's here
    */
    RG.SVG.tooltips       = {};
    RG.SVG.tooltips.style = {
        display:    'inline-block',
        position:   'absolute',
        padding:    '6px',
        fontFamily: 'Arial',
        fontSize:   '12pt',
        fontWeight: 'normal',
        textAlign:  'center',
        left:       0,
        top:        0,
        backgroundColor: 'rgb(255,255,239)',
        color:      'black',
        visibility: 'visible',
        zIndex:     3,
        borderRadius: '5px',
        boxShadow:  'rgba(96,96,96,0.5) 0 0 5px',
        transition: 'left ease-out .25s, top ease-out .25s'
    };
    //
    // Shows a tooltip
    //
    // @param obj The chart object
    // @param opt The options
    //
    RG.SVG.tooltip = function (opt)
    {
        var obj = opt.object;
        // Fire the beforetooltip event
        RG.SVG.fireCustomEvent(obj, 'onbeforetooltip');
        if (!opt.text || typeof opt.text === 'undefined' || RG.SVG.trim(opt.text).length === 0) {
            return;
        }
        var prop = obj.properties;
        /**
        * chart.tooltip.override allows you to totally take control of rendering the tooltip yourself
        */
        if (typeof prop.tooltipsOverride === 'function') {
            // Add the body click handler that clears the highlight if necessary
            //
            document.body.addEventListener('mouseup', function (e)
            {
                obj.removeHighlight();
            }, false);
            return (prop.tooltipsOverride)(obj, opt);
        }
        // Create the tooltip DIV element
        if (!RG.SVG.REG.get('tooltip')) {
            var tooltipObj        = document.createElement('DIV');
            tooltipObj.className  = prop.tooltipsCssClass;
            // Add the default CSS to the tooltip
            for (var i in RG.SVG.tooltips.style) {
                if (typeof i === 'string') {
                    tooltipObj.style[i] = RG.SVG.tooltips.style[i];
                }
            }
        // Reuse an existing tooltip
        } else {
            var tooltipObj = RG.SVG.REG.get('tooltip');
            tooltipObj.__object__.removeHighlight();
            // This prevents the object from continuously growing
            tooltipObj.style.width = '';
        }
        if (RG.SVG.REG.get('tooltip-lasty')) {
            tooltipObj.style.left = RG.SVG.REG.get('tooltip-lastx') + 'px';
            tooltipObj.style.top  = RG.SVG.REG.get('tooltip-lasty') + 'px';
        }
        tooltipObj.innerHTML  = opt.text;
        tooltipObj.__text__   = opt.text; // This is set because the innerHTML can change when it's set
        tooltipObj.id         = '__rgraph_tooltip_' + obj.id + '_' + obj.uid + '_'+  opt.index;
        tooltipObj.__event__  = prop.tooltipsEvent || 'click';
        tooltipObj.__object__ = obj;
        // Add the index
        if (typeof opt.index === 'number') {
            tooltipObj.__index__ = opt.index;
        }
        // Add the dataset
        if (typeof opt.dataset === 'number') {
            tooltipObj.__dataset__ = opt.dataset;
        }
        // Add the group
        if (typeof opt.group === 'number' || RG.SVG.isNull(opt.group)) {
            tooltipObj.__group__ = opt.group;
        }
        // Add the sequentialIndex
        if (typeof opt.sequentialIndex === 'number') {
            tooltipObj.__sequentialIndex__ = opt.sequentialIndex;
        }
        // Add the tooltip to the document
        document.body.appendChild(tooltipObj);
        var width  = tooltipObj.offsetWidth,
            height = tooltipObj.offsetHeight;
        // Move the tooltip into position
        tooltipObj.style.left = opt.event.pageX - (width / 2) + 'px';
        tooltipObj.style.top  = opt.event.pageY - height - 15 + 'px';
        /**
        * Set the width on the tooltip so it doesn't resize if the window is resized
        */
        tooltipObj.style.width = width + 'px';
        // Fade the tooltip in if the tooltip is not the first view
        if (!RG.SVG.REG.get('tooltip-lastx')) {
            for (var i=0; i<=30; ++i) {
                (function (idx)
                {
                    setTimeout(function ()
                    {
                        tooltipObj.style.opacity = (idx / 30) * 1;
                    }, (idx / 30) * 200);
                })(i);
            }
        }
        // If the left is less than zero - set it to 5
        if (parseFloat(tooltipObj.style.left) <= 5) {
            tooltipObj.style.left = '5px';
        }
        // If the tooltip goes over the right hand edge then
        // adjust the positioning
        if (parseFloat(tooltipObj.style.left) + parseFloat(tooltipObj.style.width) > window.innerWidth) {
            tooltipObj.style.left  = ''
            tooltipObj.style.right = '5px'
        }
        // If the canvas has fixed positioning then set the tooltip position to
        // fixed too
        if (RG.SVG.isFixed(obj.svg)) {
            var scrollTop = window.scrollY || document.documentElement.scrollTop;
            tooltipObj.style.position = 'fixed';
            tooltipObj.style.top      = opt.event.pageY - scrollTop - height - 10 + 'px';
        }
        // Cancel the mousedown event
        tooltipObj.onmousedown = function (e)
        {
            e.stopPropagation();
        };
        // Cancel the mouseup event
        tooltipObj.onmouseup = function (e)
        {
            e.stopPropagation();
        };
        // Cancel the click event
        tooltipObj.onclick  = function (e)
        {
            if (e.button == 0) {
                e.stopPropagation();
            }
        };
        // Add the body click handler that clears the tooltip
        document.body.addEventListener('mouseup', function (e)
        {
            RG.SVG.hideTooltip();
        }, false);
        /**
        * Keep a reference to the tooltip in the registry
        */
        RG.SVG.REG.set('tooltip', tooltipObj);
        RG.SVG.REG.set('tooltip-lastx', parseFloat(tooltipObj.style.left));
        RG.SVG.REG.set('tooltip-lasty', parseFloat(tooltipObj.style.top));
        //
        // Fire the tooltip event
        //
        RG.SVG.fireCustomEvent(obj, 'ontooltip');
    };
// End module pattern
})(window, document);;
RGraph.SVG.tooltips.style.zIndex     = '10000';
DLG1_DlgObj._layoutMode = 'containerwidth';
DLG1_DlgObj._responsiveRulesMode = 'firsttrue';
DLG1_DlgObj.__controlNesting = {
}
DLG1_DlgObj._listsDV = [];
DLG1_DlgObj._listControls = [];
DLG1_DlgObj._formBoxControls = [];
DLG1_DlgObj._localStorageSettings = {namespace: 'ALPHA_ed9a90e3290248e3aa6ab7a17cf9a41e',friendlyName: '',description: '',persistVariableValues: false,__version: 1,persistComponentState: false,workingPreviewTestingFolder: '',restore: {variables: false,data: false,state: false},compressData: false,minify: false,variablesToNotPersist: '',workingPreviewTestingMode: 'Browser',compressListData: false}
;
DLG1_DlgObj.__r = [];
$e.add(window,'resize',function() {
	if(DLG1_DlgObj._findActiveLayoutRule) DLG1_DlgObj._findActiveLayoutRule();
},null,false,'DLG1.DIALOG');
DLG1_DlgObj.__flagIsStaticHTML = true;
DLG1_DlgObj._EDITOR_EDITORSET = {};
DLG1_DlgObj.styleName = 'Alpha-Aqua';
DLG1_DlgObj.styleVersion = 4
DLG1_DlgObj.framesInfo = {
};
DLG1_DlgObj._noPersist = []
DLG1_DlgObj._ssdecimal = '.';
$u.decimal = '.';
$u.comma = ',';
DLG1_DlgObj._mobilePreview = false;
DLG1_DlgObj._modernFrames = {};
DLG1_DlgObj._listsWithDependentTFControls = DLG1_DlgObj._listsWithDependentTFControls = {}
DLG1_DlgObj.__r = [];
window.__preventDefault = function(event) { event.preventDefault()};
setTimeout(function() {; },100);
DLG1_DlgObj.__flagIsStaticHTML = true;
DLG1_DlgObj._listInsideCards = {
}
;DLG1_DlgObj.__workingPreviewProject = 'D:/Nibble-TM/Nibble-TM.WebProjects/MRG5.WebProject';
;
;

$e.add('DLG1.V.R1.BUTTON_2',A5.d.evnts.click,function(e) {
var _disabled = this.disabled; if(typeof _disabled == 'undefined') _disabled = false; if(!_disabled) {var xbasicFunction = 'system:savereportaspdf';
  var additionalData = '__functionname=SaveReportAsPDF_3f9d23c0856d4d57b905458ccc8145e9';
  var onAjaxCompleteFunction = function() {
   var _o = {
 "fileName": DLG1_DlgObj.__filenameNativeViewer,
 "onSuccess": function() { },
 "onError": function(e) { }
};
var flagFound = false;
try {
 var _open = cordova.plugins.disusered.open;
 flagFound = true;
} catch(e) {
 alert('Cordova-open plugin not loaded');
}
var downloadOptions = {
 "forceDownloadIfFileExists": false,
 "showProgress": false,
 "onDeviceOffline": function() { },
 "progress": {
  "color": "#9fa1e8",
  "width": "300px",
  "allowCancel": false,
  "progressElement": "DLG1.V.R1."
 }
};
var obj = {
 "targetFileSystem": "temp",
 "targetFolder": "__AATEMPFILES",
 "sourceFileSystem": "persistent",
 "sourceFolder": "__AATEMPFILES",
 "sourceFileName": _o.fileName,
 "options": downloadOptions,
 "flagMustDownload": true,
 "targetFileName": DLG1_DlgObj.__filenameFriendlyNativeViewer
};
var _onError = function(e) { _o.onError(e);};
var _onSuccess = function() { _o.onSuccess(); };
DLG1_DlgObj.phoneGapOpenFileWithNativeViewer(obj,_onSuccess,_onError);
  }
  var ajaxErrorFunction = function() {  };
  var deviceOfflineAjaxFunction = function() {   }
  DLG1_DlgObj.ajaxCallback('','',xbasicFunction,'',additionalData,{errorFunction: ajaxErrorFunction, onComplete: onAjaxCompleteFunction, deviceOfflineFunction: deviceOfflineAjaxFunction });;var that = this; this.disabled = true; setTimeout(function() { that.disabled = false; },300);}
},this,false,'DLG1.V.R1.BUTTON_2');

DLG1_DlgObj.prepare();DLG1_DlgObj.populate(DLG1_DlgObj.originalValues[0]);
DLG1_DlgObj._fireWatches(1);


if(!A5.flags.isMobile) $e.add(window,'resize',DLG1_DlgObj._functions.calcOrientation,null,false,'DLG1.DIALOG');
else $e.add(window,'orientationchange',DLG1_DlgObj._orientationChangeHandler,DLG1_DlgObj,true,'DLG1.DIALOG');
DLG1_DlgObj._functions.calcOrientation();

DLG1_DlgObj._functions._windowResize = function() { 
	var _d = 50;
	 
	if(DLG1_DlgObj.resizeFormBoxes) { DLG1_DlgObj.resizeFormBoxes(); }
	if(typeof DLG1_DlgObj._windowResizeDelay != 'undefined') _d = DLG1_DlgObj._windowResizeDelay;
	clearTimeout(DLG1_DlgObj._wrTO);
	DLG1_DlgObj._wrTo = setTimeout(function() { 
		DLG1_DlgObj._executeEvent('onWindowResize',{});
	},_d);
}
$e.add(window,'resize',DLG1_DlgObj._functions._windowResize,null,false,'DLG1.DIALOG');
setTimeout(function() { 
	if(DLG1_DlgObj.resizeLists) { DLG1_DlgObj.resizeLists(); }  ;
	//do initial formbox resize
	if(DLG1_DlgObj.resizeFormBoxes) { DLG1_DlgObj.resizeFormBoxes(); }
	  
},0);

;





setTimeout(function() { },0);


DLG1_DlgObj._executeEvent('onInitializeComplete');
DLG1_DlgObj.initialized = true;







DLG1_DlgObj._onRenderComplete = function() { DLG1_DlgObj._runJSOnLoad(); DLG1_DlgObj._findActiveLayoutRule(); }; 


setTimeout(function() {
	DLG1_DlgObj._executeEvent('onRenderComplete');
	DLG1_DlgObj.flagRenderComplete = true;
	var _flagPGApp = false;
	if(typeof _phoneGapSettings == 'function') {
		_flagPGApp = true;
		/*
		if(typeof cordova == 'object') {
			DLG1_DlgObj._cordovaReady = true;
		} else {
			DLG1_DlgObj._cordovaReady = false;
		};
		*/
	};



	//alert('is a pg app: ' + _flagPGApp + '  _cordovaReady: ' + DLG1_DlgObj._cordovaReady );
	if(!_flagPGApp) {
		DLG1_DlgObj._restoreFromLocalStorage();
	} else {

		//phonegap app, but phonegap may not yet be loaded
		//alert('register the _restoreFormLocalStorage to fire when phonegap is ready');

		DLG1_DlgObj._delayTillPhoneGapReady(DLG1_DlgObj._restoreFromLocalStorage,DLG1_DlgObj);
	}

 },1);
;
;

var o2 = 'portrait';
if(window.innerHeight < window.innerWidth) o2 = 'landscape';
DLG1_DlgObj._screen = {h: window.innerHeight, w: window.innerWidth, o: o2};

DLG1_DlgObj._getOnlineStatus();
try {
$e.removeGroup('window_offline_event');
$e.add(window,'offline',function() { if(DLG1_DlgObj) DLG1_DlgObj._fireOnConnectionChangeEvent('offline') }, null,false,'window_offline_event');
$e.add(window,'online',function() {  if(DLG1_DlgObj) DLG1_DlgObj._fireOnConnectionChangeEvent('online') }, null,false,'window_offline_event')
//window.addEventListener("offline",function() {  DLG1_DlgObj._fireOnConnectionChangeEvent('offline') });
//window.addEventListener("online",function() { DLG1_DlgObj._fireOnConnectionChangeEvent('online') });
} catch(err){}


;

if(DLG1_DlgObj.restoreListLayouts) DLG1_DlgObj.restoreListLayouts();
setTimeout(function() {
;},10);;
setTimeout(function() { },10);;
DLG1_DlgObj._activeLanguage = '<Default>';
</script>
<script>

</script>
</body>
</html>